package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"regexp"

	. "github.com/mmcloughlin/avo/build"
	"github.com/mmcloughlin/avo/ir"
	. "github.com/mmcloughlin/avo/operand"
)

var testhelp = flag.String("testhelp", "", "test helpers")

func main() {
	emitAlignments := func(emit func(variant, align int)) {
		for align := 8; align <= 16; align++ {
			for v := 0; v <= 4; v++ {
				emit(v, align)
			}
		}
	}

	emitAlignments(AxpyPointer)
	emitAlignments(AxpyPointerLoop)
	emitAlignments(AxpyUnsafe)
	emitAlignments(AxpyUnsafeR4)

	Generate()

	if *testhelp != "" {
		generateTestHelp("axpy_amd64.go", *testhelp)
	}
}

func generateTestHelp(stubs, out string) {
	data, err := os.ReadFile(stubs)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
	}

	fns := []string{}

	rx := regexp.MustCompile("func ([a-zA-Z0-9_]+)\\(")
	for _, match := range rx.FindAllStringSubmatch(string(data), -1) {
		fns = append(fns, match[1])
	}

	var b bytes.Buffer
	pf := func(format string, args ...interface{}) {
		fmt.Fprintf(&b, format, args...)
	}

	pf("// Code generated by command. DO NOT EDIT.\n\n")
	pf("package compare\n\n")
	pf("type axpyDecl struct {\n")
	pf("	name string\n")
	pf("	fn   func(alpha float32, xs *float32, incx uintptr, ys *float32, incy uintptr, n uintptr)\n")
	pf("}\n\n")

	pf("var axpyDecls = []axpyDecl{\n")
	for _, fn := range fns {
		pf("	{name: %q, fn: %v},\n", fn, fn)
	}
	pf("}\n")

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		fmt.Fprintln(os.Stderr, b.Bytes())
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	os.WriteFile(out, formatted, 0755)
}

func AxpyPointer(variant, align int) {
	TEXT(fmt.Sprintf("AxpyPointer_V%vA%v", variant, align), NOSPLIT, "func(alpha float32, xs *float32, incx uintptr, ys *float32, incy uintptr, n uintptr)")

	alpha := Load(Param("alpha"), XMM())

	xs := Mem{Base: Load(Param("xs"), GP64())}
	incx := Load(Param("incx"), GP64())

	ys := Mem{Base: Load(Param("ys"), GP64())}
	incy := Load(Param("incy"), GP64())

	n := Load(Param("n"), GP64())

	end := n
	SHLQ(U8(0x2), end)
	IMULQ(incx, end)
	ADDQ(xs.Base, end)
	JMP(LabelRef("check_limit"))

	MISALIGN(align)
	Label("loop")
	{
		tmp := XMM()
		MOVSS(xs, tmp)
		MULSS(alpha, tmp)
		ADDSS(ys, tmp)
		MOVSS(tmp, ys)

		LEAQ(xs.Idx(incx, 4), xs.Base)
		LEAQ(ys.Idx(incy, 4), ys.Base)

		Label("check_limit")

		CMPQ(end, xs.Base)
		JHI(LabelRef("loop"))
	}

	RET()
}

func AxpyPointerLoop(variant, align int) {
	TEXT(fmt.Sprintf("AxpyPointerLoop_V%vA%v", variant, align), NOSPLIT, "func(alpha float32, xs *float32, incx uintptr, ys *float32, incy uintptr, n uintptr)")

	alpha := Load(Param("alpha"), XMM())

	xs := Mem{Base: Load(Param("xs"), GP64())}
	incx := Load(Param("incx"), GP64())

	ys := Mem{Base: Load(Param("ys"), GP64())}
	incy := Load(Param("incy"), GP64())

	n := Load(Param("n"), GP64())
	counter := GP64()
	XORQ(counter, counter)

	JMP(LabelRef("check_limit"))

	MISALIGN(align)
	Label("loop")
	{
		tmp := XMM()
		MOVSS(xs, tmp)
		MULSS(alpha, tmp)
		ADDSS(ys, tmp)
		MOVSS(tmp, ys)

		INCQ(counter)

		LEAQ(xs.Idx(incx, 4), xs.Base)
		LEAQ(ys.Idx(incy, 4), ys.Base)

		Label("check_limit")

		CMPQ(n, counter)
		JHI(LabelRef("loop"))
	}

	RET()
}

func AxpyUnsafe(variant, align int) {
	TEXT(fmt.Sprintf("AxpyUnsafe_V%vA%v", variant, align), NOSPLIT, "func(alpha float32, xs *float32, incx uintptr, ys *float32, incy uintptr, n uintptr)")

	alpha := Load(Param("alpha"), XMM())

	xs := Mem{Base: Load(Param("xs"), GP64())}
	incx := Load(Param("incx"), GP64())

	ys := Mem{Base: Load(Param("ys"), GP64())}
	incy := Load(Param("incy"), GP64())

	n := Load(Param("n"), GP64())

	xi, yi := GP64(), GP64()
	XORQ(xi, xi)
	XORQ(yi, yi)

	JMP(LabelRef("check_limit"))

	MISALIGN(align)
	Label("loop")
	{
		tmp := XMM()
		MOVSS(xs.Idx(xi, 4), tmp)
		MULSS(alpha, tmp)
		ADDSS(ys.Idx(yi, 4), tmp)
		MOVSS(tmp, ys.Idx(yi, 4))

		DECQ(n)
		ADDQ(incx, xi)
		ADDQ(incy, yi)

		Label("check_limit")

		CMPQ(n, U8(0))
		JHI(LabelRef("loop"))
	}

	RET()
}

func AxpyUnsafeR4(variant, align int) {
	TEXT(fmt.Sprintf("AxpyUnsafe_V%vA%vR4", variant, align), NOSPLIT, "func(alpha float32, xs *float32, incx uintptr, ys *float32, incy uintptr, n uintptr)")

	alpha := Load(Param("alpha"), XMM())

	xs := Mem{Base: Load(Param("xs"), GP64())}
	incx := Load(Param("incx"), GP64())

	ys := Mem{Base: Load(Param("ys"), GP64())}
	incy := Load(Param("incy"), GP64())

	n := Load(Param("n"), GP64())

	xi, yi := GP64(), GP64()
	XORQ(xi, xi)
	XORQ(yi, yi)

	JMP(LabelRef("check_limit_r4"))

	MISALIGN(align)
	Label("loop_r4")
	{
		for unroll := 0; unroll < 4; unroll++ {
			tmp := XMM()

			xat := Mem{Base: xs.Base, Index: xi, Scale: 4, Disp: 4 * unroll}
			yat := Mem{Base: ys.Base, Index: yi, Scale: 4, Disp: 4 * unroll}
			MOVSS(xat, tmp)
			MULSS(alpha, tmp)
			ADDSS(yat, tmp)
			MOVSS(tmp, yat)
		}

		SUBQ(Imm(4), n)

		LEAQ(Mem{Base: xi, Index: incx, Scale: 4}, xi)
		LEAQ(Mem{Base: yi, Index: incy, Scale: 4}, yi)

		Label("check_limit_r4")

		CMPQ(n, U8(4))
		JHI(LabelRef("loop_r4"))
	}

	JMP(LabelRef("check_limit"))
	Label("loop")
	{
		tmp := XMM()
		MOVSS(xs.Idx(xi, 4), tmp)
		MULSS(alpha, tmp)
		ADDSS(ys.Idx(yi, 4), tmp)
		MOVSS(tmp, ys.Idx(yi, 4))

		DECQ(n)
		ADDQ(incx, xi)
		ADDQ(incy, yi)

		Label("check_limit")

		CMPQ(n, U8(0))
		JHI(LabelRef("loop"))
	}

	RET()
}

func MISALIGN(n int) {
	if n == 0 {
		return
	}

	nearestPowerOf2 := 8
	for n >= nearestPowerOf2*2 {
		nearestPowerOf2 *= 2
	}
	if nearestPowerOf2 >= 8 {
		Instruction(&ir.Instruction{
			Opcode:   "PCALIGN",
			Operands: []Op{Imm(uint64(nearestPowerOf2))},
		})
		n -= nearestPowerOf2
	}

	for i := 0; i < n; i++ {
		NOP()
	}
}
