package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"regexp"

	. "github.com/mmcloughlin/avo/build"
	"github.com/mmcloughlin/avo/ir"
	. "github.com/mmcloughlin/avo/operand"
)

var testhelp = flag.String("testhelp", "", "test helpers")

func main() {
	emitAlignments := func(emit func(align int)) {
		for align := 8; align <= 16; align++ {
			emit(align)
		}
	}

	emitAlignments(AxpyPointer)
	emitAlignments(AxpyPointerLoop)
	emitAlignments(AxpyUnsafe)

	Generate()

	if *testhelp != "" {
		generateTestHelp("axpy_amd64.go", *testhelp)
	}
}

func generateTestHelp(stubs, out string) {
	data, err := os.ReadFile(stubs)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
	}

	fns := []string{}

	rx := regexp.MustCompile("func ([a-zA-Z0-9_]+)\\(")
	for _, match := range rx.FindAllStringSubmatch(string(data), -1) {
		fns = append(fns, match[1])
	}

	var b bytes.Buffer
	pf := func(format string, args ...interface{}) {
		fmt.Fprintf(&b, format, args...)
	}

	pf("// Code generated by command. DO NOT EDIT.\n\n")
	pf("package compare\n\n")
	pf("type axpyDecl struct {\n")
	pf("	name string\n")
	pf("	fn   func(alpha float32, xs *float32, incx uintptr, ys *float32, incy uintptr, n uintptr)\n")
	pf("}\n\n")

	pf("var axpyDecls = []axpyDecl{\n")
	for _, fn := range fns {
		pf("	{name: %q, fn: %v},\n", fn, fn)
	}
	pf("}\n")

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		fmt.Fprintln(os.Stderr, b.Bytes())
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	os.WriteFile(out, formatted, 0755)
}

func AxpyPointer(align int) {
	TEXT(fmt.Sprintf("AxpyPointer_A%v", align), NOSPLIT, "func(alpha float32, xs *float32, incx uintptr, ys *float32, incy uintptr, n uintptr)")

	alpha := Load(Param("alpha"), XMM())

	xs := Mem{Base: Load(Param("xs"), GP64())}
	incx := Load(Param("incx"), GP64())

	ys := Mem{Base: Load(Param("ys"), GP64())}
	incy := Load(Param("incy"), GP64())

	n := Load(Param("n"), GP64())

	end := n
	SHLQ(U8(0x2), end)
	IMULQ(incx, end)
	ADDQ(xs.Base, end)
	JMP(LabelRef("check_limit"))

	Align(align)
	Label("loop")
	{
		tmp := XMM()
		MOVSS(xs, tmp)
		MULSS(alpha, tmp)
		ADDSS(ys, tmp)
		MOVSS(tmp, ys)

		LEAQ(xs.Idx(incx, 4), xs.Base)
		LEAQ(ys.Idx(incy, 4), ys.Base)

		Label("check_limit")

		CMPQ(end, xs.Base)
		JHI(LabelRef("loop"))
	}

	RET()
}

func AxpyPointerLoop(align int) {
	TEXT(fmt.Sprintf("AxpyPointerLoop_A%v", align), NOSPLIT, "func(alpha float32, xs *float32, incx uintptr, ys *float32, incy uintptr, n uintptr)")

	alpha := Load(Param("alpha"), XMM())

	xs := Mem{Base: Load(Param("xs"), GP64())}
	incx := Load(Param("incx"), GP64())

	ys := Mem{Base: Load(Param("ys"), GP64())}
	incy := Load(Param("incy"), GP64())

	n := Load(Param("n"), GP64())
	counter := GP64()
	XORQ(counter, counter)

	JMP(LabelRef("check_limit"))

	Align(align)
	Label("loop")
	{
		tmp := XMM()
		MOVSS(xs, tmp)
		MULSS(alpha, tmp)
		ADDSS(ys, tmp)
		MOVSS(tmp, ys)

		INCQ(counter)

		LEAQ(xs.Idx(incx, 4), xs.Base)
		LEAQ(ys.Idx(incy, 4), ys.Base)

		Label("check_limit")

		CMPQ(n, counter)
		JHI(LabelRef("loop"))
	}

	RET()
}

func AxpyUnsafe(align int) {
	TEXT(fmt.Sprintf("AxpyUnsafe_A%v", align), NOSPLIT, "func(alpha float32, xs *float32, incx uintptr, ys *float32, incy uintptr, n uintptr)")

	alpha := Load(Param("alpha"), XMM())

	xs := Mem{Base: Load(Param("xs"), GP64())}
	incx := Load(Param("incx"), GP64())

	ys := Mem{Base: Load(Param("ys"), GP64())}
	incy := Load(Param("incy"), GP64())

	n := Load(Param("n"), GP64())

	counter, xi, yi := GP64(), GP64(), GP64()
	XORQ(counter, counter)
	XORQ(xi, xi)
	XORQ(yi, yi)

	JMP(LabelRef("check_limit"))

	Align(align)
	Label("loop")
	{
		tmp := XMM()
		MOVSS(xs.Idx(xi, 4), tmp)
		MULSS(alpha, tmp)
		ADDSS(ys.Idx(yi, 4), tmp)
		MOVSS(tmp, ys.Idx(yi, 4))

		INCQ(counter)
		ADDQ(incx, xi)
		ADDQ(incy, yi)

		Label("check_limit")

		CMPQ(n, counter)
		JHI(LabelRef("loop"))
	}

	RET()
}

func Align(n int) {
	if n < 8 {
		panic(fmt.Sprint("alignment %v not supported", n))
	}

	nearestPowerOf2 := 8
	for n >= nearestPowerOf2*2 {
		nearestPowerOf2 *= 2
	}

	Instruction(&ir.Instruction{
		Opcode:   "PCALIGN",
		Operands: []Op{Imm(uint64(nearestPowerOf2))},
	})

	n -= nearestPowerOf2
	for i := 0; i < n; i++ {
		NOP()
	}
}
