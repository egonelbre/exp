typedef struct combiner combiner_t;
typedef struct combiner_arg combiner_arg_t;
struct combiner_arg {
   combiner_arg_t* next;
};
 
combiner_t* combiner_create(void (*fn)(combiner_arg_t*));
void combiner_destroy(combiner_t* c);
void combiner_execute(combiner_t* c, combiner_arg_t* arg);


struct combiner {
   void (*fn)(combiner_arg_t* arg);
   combiner_arg_t* head;
};
 
combiner_t* combiner_create(void (*fn)(combiner_arg_t*)) {
   combiner_t* c = (combiner_t*)malloc(sizeof(combiner_t));
   c->head = 0;
   c->fn = fn;
   return c;
}
 
void combiner_destroy(combiner_t* c) {
   free(c);
}

#define LOCKED ((combiner_arg_t*)1)
void combiner_execute(combiner_t* c, combiner_arg_t* arg) {
   // c->head can be in 3 states:
   // c->head == 0: no operations in-flight, initial state.
   // c->head == LOCKED: single operation in-flight, no combining opportunities.
   // c->head == pointer to some combiner_arg_t that is subject to combining.
   //            The args are chainded into a lock-free list via 'next' fields.
   // arg->next also can be in 3 states:
   // arg->next == pointer to other arg.
   // arg->next == LOCKED: denotes the last arg in the list.
   // arg->next == 0: the operation is finished.
 
   // The function proceeds in 3 steps:
   // 1. If c->head == 0, exchange it to LOCKED and become the combiner.
   // Otherwise, enqueue own arg into the c->head lock-free list.
   combiner_arg_t* cmp = __atomic_load_n(&c->head, __ATOMIC_ACQUIRE);
   for (;;) {
       combiner_arg_t* xchg = LOCKED;
       if (cmp) {
           // There is already a combiner, enqueue itself.
           xchg = arg;
           arg->next = cmp;
       }
       if (__atomic_compare_exchange_n(&c->head, &cmp, xchg, 1, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE))
           break;
   }
   // 2. If we are not the combiner, wait for arg->next to become 0
   // (which means the operation is finished).
   if (cmp) {
       while (__atomic_load_n(&arg->next, __ATOMIC_ACQUIRE) != 0) {
       }
   // 3. We are the combiner.
   } else {
       // First, execute own operation.
       c->fn(arg);
       // Then, look for combining opportunities.
       for (;;) {
           cmp = __atomic_load_n(&c->head, __ATOMIC_ACQUIRE);
           for (;;) {
               // If there are some operations in the list,
               // grab the list and replace with LOCKED.
               // Otherwise, exchange to 0.
               combiner_arg_t* xchg = 0;
               if (cmp != LOCKED)
                   xchg = LOCKED;
               if (__atomic_compare_exchange_n(&c->head, &cmp, xchg, 1, __ATOMIC_ACQ_REL,
                                                                                                                            __ATOMIC_ACQUIRE))
                   break;
           }
           // No more operations to combine, return.
           if (cmp == LOCKED)
               break;
           arg = cmp;
           // Execute the list of operations.
           while (arg != LOCKED) {
               combiner_arg_t* next = arg->next;
               c->fn(arg);
               // Mark completion.
               __atomic_store_n(&arg->next, 0, __ATOMIC_RELEASE);
               arg = next;
           }
       }
   }
}
