// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"text/template"
)

var Impls = []Impl{
	{"MPMCc_go", Blocking | Nonblocking},
	{"MPMCq_go", Broken | Blocking | Nonblocking},

	{"SPSCr_mc", Broken | Blocking | Batched},
	{"SPSCrs_mc", Broken | Blocking | Batched},
	{"MPSCr_mc", Broken | Blocking | Batched},
	// {"MPSCrs_mc", Blocking | Batched},

	{"SPSCns_dv", Blocking | Nonblocking | Unbounded},
	{"MPSCns_dv", Blocking | Nonblocking | Unbounded},
	{"MPSCnsi_dv", Blocking | Nonblocking | Unbounded},

	{"MPMCqs_dv", Blocking | Nonblocking},
	{"MPMCqsp_dv", Blocking | Nonblocking},
	{"SPMCqs_dv", Blocking | Nonblocking},
	{"SPMCqsp_dv", Blocking | Nonblocking},
	{"SPSCqs_dv", Blocking | Nonblocking},
	{"SPSCqsp_dv", Blocking | Nonblocking},

	{"SPSCrs_one", Blocking},
	{"SPMCrs_one", Blocking},
	{"MPSCrs_one", Blocking},
}

type Flag int

const (
	Broken = Flag(1 << iota)
	Unbounded
	Batched
	Blocking
	Nonblocking
)

type Impl struct {
	Name  string
	Flags Flag
}

func (impl *Impl) Faces() []string {
	faces := []string{}
	suffix := impl.Name[:4]

	if impl.Blocking() {
		faces = append(faces, suffix)
	}
	if impl.Nonblocking() {
		faces = append(faces, "Nonblocking"+suffix)
	}

	return faces
}

func (impl *Impl) Broken() bool      { return impl.Flags&Broken == Broken }
func (impl *Impl) Unbounded() bool   { return impl.Flags&Unbounded == Unbounded }
func (impl *Impl) Batched() bool     { return impl.Flags&Batched == Batched }
func (impl *Impl) Blocking() bool    { return impl.Flags&Blocking == Blocking }
func (impl *Impl) Nonblocking() bool { return impl.Flags&Nonblocking == Nonblocking }

func main() {
	outname := flag.String("out", "", "")
	flag.Parse()

	var b bytes.Buffer
	t := template.Must(template.New("").Parse(T))
	err := t.Execute(&b, Impls)
	check(err)

	dst, err := format.Source(b.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed format: %v\n", err)
		dst = b.Bytes()
	}

	var out io.Writer = os.Stdout
	if *outname != "" {
		f, err := os.Create(*outname)
		check(err)
		defer f.Close()
		out = f
	}

	out.Write(dst)
}

func check(err error) {
	if err != nil {
		fmt.Fprint(os.Stderr, err)
		os.Exit(1)
	}
}

const T = `package queue

// Code generated by all_gen.go; DO NOT EDIT.

//go:generate go run all_gen.go -out all_test.go

import (
	"testing"
	"strconv"
)

var _ = strconv.Itoa

{{ range . }}
{{ $impl := . }}

{{ range .Faces -}}
var _ {{ . }} = (*{{$impl.Name}})(nil)
{{ end }}

func Test{{.Name}}(t *testing.T) {
	{{- if .Broken -}} t.Skip("broken"); {{- end -}}
	{{- if .Batched -}}
	for _, batchSize := range BatchSizes {
		t.Run(strconv.Itoa(batchSize), func(t *testing.T){
			test(t, func(size int) Queue { return New{{.Name}}(batchSize{{if .Unbounded}}{{else}}, size{{end}}) })
		})
	}
	{{- else -}}
	t.Run("0", func(t *testing.T){
		test(t, func(size int) Queue { return New{{.Name}}({{if .Unbounded}}{{else}}size{{end}}) })
	})
	{{- end -}}
}

func Benchmark{{.Name}}(b *testing.B) {
	{{- if .Broken -}} b.Skip("broken"); {{- end -}}
	{{- if .Batched -}}
	for _, batchSize := range BatchSizes {
		b.Run(strconv.Itoa(batchSize), func(b *testing.B){
			bench(b, func(size int) Queue { return New{{.Name}}(batchSize {{if .Unbounded}}{{else}}, size{{end}}) })
		})
	}
	{{- else -}}
	b.Run("0", func(b *testing.B){
		bench(b, func(size int) Queue { return New{{.Name}}({{if .Unbounded}}{{else}}size{{end}}) })
	})
	{{- end -}}
}
{{ end }}
`
