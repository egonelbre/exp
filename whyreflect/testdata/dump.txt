# github.com/egonelbre/exp/whyreflect
_ -> _rt0_amd64_windows
_ -> runtime.unreachableMethod
_ -> go:main.inittasks
runtime.unreachableMethod -> go:string."unreachable method called. linker bug?"
runtime.unreachableMethod -> runtime.throw
runtime.unreachableMethod -> runtime.morestack_noctxt
runtime.unreachableMethod -> gclocals·g2BeySu+wFnoycgXfElmcg==
runtime.unreachableMethod -> go:sehuw.12.AQoCBQoDB1AAAAAA
runtime.throw -> runtime.throw.func1
runtime.throw -> runtime.systemstack
runtime.throw -> runtime.tls_g
runtime.throw -> runtime.fatalthrow
runtime.throw -> gclocals·wgcWObbY2HYnK2SU/U22lA==
runtime.throw -> gclocals·odYzRIjT7IX9pYG9TnNVzw==
runtime.throw -> runtime.send.stkobj
runtime.throw -> fmt.parseArgNumber.arginfo1
runtime.throw -> type:.eq.main.Dep.argliveinfo
runtime.throw -> go:sehuw.12.AQQCBQQDAVAAAAAA
runtime.throw.func1 -> runtime.printlock
runtime.throw.func1 -> go:string."fatal error: "
runtime.throw.func1 -> runtime.printstring
runtime.throw.func1 -> runtime.printnl
runtime.throw.func1 -> runtime.printunlock
runtime.throw.func1 -> runtime.morestack
runtime.throw.func1 -> gclocals·J5F+7Qw7O7ve2QcWC7DpeQ==
runtime.throw.func1 -> gclocals·CnDyI2HjYXFz19SsOj98tw==
runtime.fatalthrow -> runtime.fatalthrow.func1
runtime.fatalthrow -> gclocals·o6Zg9+zmRBFm//1GHy3gfQ==
runtime.fatalthrow -> os.Mkdir.stkobj
runtime.fatalthrow -> fmt.isSpace.arginfo1
runtime.fatalthrow.func1 -> runtime.startpanic_m
runtime.fatalthrow.func1 -> runtime.dopanic_m
runtime.fatalthrow.func1 -> runtime.dieFromException
runtime.fatalthrow.func1 -> runtime.exit
runtime.exit -> runtime.suspendLock
runtime.exit -> runtime.lock2
runtime.exit -> runtime.exiting
runtime.exit -> runtime._ExitProcess
runtime.exit -> runtime.stdcall1
runtime.lock2 -> runtime.semacreate
runtime.lock2 -> runtime.ncpu
runtime.lock2 -> runtime.switchtothread·f
runtime.lock2 -> runtime.procyield
runtime.lock2 -> runtime.semasleep
runtime.lock2 -> go:string."runtime·lock: lock count"
runtime.lock2 -> gclocals·ZzMiPAiVBg7DJ6dh/CjSag==
runtime.lock2 -> gclocals·zs5ZgaphdoenM8+qMgYpxw==
runtime.lock2 -> fmt.(*wrapError).Error.arginfo1
runtime.lock2 -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
runtime.semasleep -> runtime.nanotime1
runtime.semasleep -> runtime._WaitForSingleObject
runtime.semasleep -> runtime.stdcall2
runtime.semasleep -> runtime.semasleep.func1·f
runtime.semasleep -> runtime.semasleep.func3
runtime.semasleep -> runtime.semasleep.func2·f
runtime.semasleep -> runtime._WaitForMultipleObjects
runtime.semasleep -> runtime.stdcall4
runtime.semasleep.func3 -> go:string."runtime: waitforsingleobject unexpected; result="
runtime.semasleep.func3 -> runtime.printuint
runtime.semasleep.func3 -> go:string."runtime.semasleep unexpected"
runtime.semacreate -> runtime._CreateEventA
runtime.semacreate -> runtime.semacreate.func1·f
runtime.semacreate -> runtime.semacreate.func2·f
runtime.semacreate -> runtime._CloseHandle
runtime.stdcall1 -> runtime.stdcall
runtime.stdcall1 -> type:.eq.main.Dep.arginfo1
runtime.stdcall -> runtime.asmstdcallAddr
runtime.stdcall -> runtime.asmcgocall
runtime.stdcall -> gclocals·VtCL4RdUwCqwXEPeyJllRA==
runtime.stdcall2 -> reflect.(*abiSeq).regAssign.arginfo1
runtime.stdcall4 -> runtime.cgoCheckMemmove2.arginfo1
runtime.startpanic_m -> runtime.mheap_
runtime.startpanic_m -> go:string."runtime: panic before malloc heap initialized\n"
runtime.startpanic_m -> go:string."stack trace unavailable\n"
runtime.startpanic_m -> go:string."panic during panic\n"
runtime.startpanic_m -> runtime.panicking
runtime.startpanic_m -> runtime.paniclk
runtime.startpanic_m -> runtime.debug
runtime.startpanic_m -> runtime.schedtrace
runtime.startpanic_m -> runtime.freezetheworld
runtime.dopanic_m -> go:string."[signal "
runtime.dopanic_m -> runtime.printhex
runtime.dopanic_m -> go:string." code="
runtime.dopanic_m -> go:string." addr="
runtime.dopanic_m -> go:string." pc="
runtime.dopanic_m -> go:string."]\n"
runtime.dopanic_m -> runtime.traceback_cache
runtime.dopanic_m -> go:string."\nruntime stack:\n"
runtime.dopanic_m -> runtime.traceback1
runtime.dopanic_m -> runtime.goroutineheader
runtime.dopanic_m -> runtime.didothers
runtime.dopanic_m -> runtime.tracebackothers
runtime.dopanic_m -> runtime.unlock2
runtime.dopanic_m -> runtime.deadlock
runtime.dopanic_m -> fmt.(*fmt).fmtC.argliveinfo
runtime.unlock2 -> runtime.semawakeup
runtime.unlock2 -> go:string."runtime·unlock: lock count"
runtime.semawakeup -> runtime._SetEvent
runtime.semawakeup -> runtime.semawakeup.func1·f
runtime.printlock -> runtime.debuglock
runtime.printnl -> runtime.gcbits.0a00000000000000
runtime.printuint -> runtime.duffzero
runtime.printuint -> runtime.gwrite
runtime.printuint -> runtime.panicSliceB
runtime.printuint -> go:sehuw.12.ARMCBRMDEFAAAAAA
runtime.gwrite -> runtime.recordForPanic
runtime.gwrite -> runtime.memmove
runtime.gwrite -> runtime.write
runtime.gwrite -> runtime.panicSliceAcap
runtime.gwrite -> fmt.Print.arginfo1
runtime.gwrite -> fmt.(*fmt).fmtQ.argliveinfo
runtime.recordForPanic -> runtime.printBacklogIndex
runtime.recordForPanic -> runtime.printBacklog
runtime.printhex -> go:string."0123456789abcdef"
runtime.printhex -> runtime.minhexdigits
runtime.printhex -> runtime.panicIndex
runtime.printstring -> gclocals·91Vv7Jr8iuzVj8waVJz8oQ==
runtime.printstring -> runtime.printstring.stkobj
runtime.freezetheworld -> runtime.freezing
runtime.freezetheworld -> runtime.freezetheworld.func1
runtime.freezetheworld -> runtime.sched
runtime.freezetheworld -> runtime.preemptall
runtime.freezetheworld -> runtime.freezetheworld.func2
runtime.freezetheworld -> runtime.freezetheworld.func3
runtime.freezetheworld.func3 -> runtime.haveHighResTimer
runtime.freezetheworld.func3 -> runtime._SetWaitableTimer
runtime.freezetheworld.func3 -> runtime.stdcall6
runtime.freezetheworld.func3 -> runtime._NtWaitForSingleObject
runtime.freezetheworld.func3 -> runtime.stdcall3
runtime.freezetheworld.func3 -> runtime.usleep2
runtime.stdcall3 -> reflect.(*abiSeq).assignFloatN.arginfo1
runtime.stdcall6 -> runtime.stdcall6.arginfo0
runtime.preemptall -> runtime.allp
runtime.preemptall -> runtime.preemptone
runtime.preemptone -> runtime.preemptM
runtime.preemptM -> runtime._DuplicateHandle
runtime.preemptM -> runtime.stdcall7
runtime.preemptM -> runtime._SuspendThread
runtime.preemptM -> runtime._GetThreadContext
runtime.preemptM -> runtime.isAsyncSafePoint
runtime.preemptM -> runtime.asyncPreempt
runtime.preemptM -> runtime._SetThreadContext
runtime.preemptM -> runtime._ResumeThread
runtime.preemptM -> runtime.getlasterror
runtime.preemptM -> go:string."runtime.preemptM: duplicatehandle failed; errno="
runtime.preemptM -> go:string."runtime.preemptM: duplicatehandle failed"
runtime.preemptM -> go:string."self-preempt"
runtime.preemptM -> gclocals·oWUH65jJRHCNQkcTmSXGew==
runtime.preemptM -> gclocals·pZV5RNoxbpgwcgbA1gtLtA==
runtime.preemptM -> go:sehuw.12.ARYCBRYDE1AAAAAA
runtime.stdcall7 -> runtime.stdcall7.arginfo0
runtime.isAsyncSafePoint -> runtime.asyncPreemptStack
runtime.isAsyncSafePoint -> runtime.findfunc
runtime.isAsyncSafePoint -> runtime.pcdatavalue2
runtime.isAsyncSafePoint -> runtime.newInlineUnwinder
runtime.isAsyncSafePoint -> runtime.(*moduledata).funcName
runtime.isAsyncSafePoint -> go:string."runtime/internal/"
runtime.isAsyncSafePoint -> runtime.memequal
runtime.isAsyncSafePoint -> runtime.(*moduledata).textAddr
runtime.isAsyncSafePoint -> go:string."bad restart PC"
runtime.isAsyncSafePoint -> gclocals·CiD8/blYUp9s5RMDDAVKhw==
runtime.isAsyncSafePoint -> runtime.isAsyncSafePoint.stkobj
runtime.isAsyncSafePoint -> fmt.(*ss).scanBool.argliveinfo
runtime.schedtrace -> runtime.starttime
runtime.schedtrace -> go:string."SCHED "
runtime.schedtrace -> runtime.printint
runtime.schedtrace -> go:string."ms: gomaxprocs="
runtime.schedtrace -> runtime.gomaxprocs
runtime.schedtrace -> go:string." idleprocs="
runtime.schedtrace -> go:string." threads="
runtime.schedtrace -> go:string." spinningthreads="
runtime.schedtrace -> go:string." needspinning="
runtime.schedtrace -> go:string." idlethreads="
runtime.schedtrace -> go:string." runqueue="
runtime.schedtrace -> go:string." gcwaiting="
runtime.schedtrace -> runtime.printbool
runtime.schedtrace -> go:string." nmidlelocked="
runtime.schedtrace -> go:string." stopwait="
runtime.schedtrace -> go:string." sysmonwait="
runtime.schedtrace -> go:string."  P"
runtime.schedtrace -> go:string.": status="
runtime.schedtrace -> go:string." schedtick="
runtime.schedtrace -> go:string." syscalltick="
runtime.schedtrace -> go:string." m="
runtime.schedtrace -> go:string."nil"
runtime.schedtrace -> go:string." runqsize="
runtime.schedtrace -> go:string." gfreecnt="
runtime.schedtrace -> go:string." timerslen="
runtime.schedtrace -> runtime.printsp
runtime.schedtrace -> go:string."["
runtime.schedtrace -> runtime.allm
runtime.schedtrace -> go:string."  M"
runtime.schedtrace -> go:string.": p="
runtime.schedtrace -> go:string." curg="
runtime.schedtrace -> go:string." mallocing="
runtime.schedtrace -> go:string." throwing="
runtime.schedtrace -> go:string." preemptoff="
runtime.schedtrace -> go:string." locks="
runtime.schedtrace -> go:string." dying="
runtime.schedtrace -> go:string." spinning="
runtime.schedtrace -> go:string." blocked="
runtime.schedtrace -> go:string." lockedg="
runtime.schedtrace -> runtime.schedtrace.func1·f
runtime.schedtrace -> runtime.forEachG
runtime.schedtrace -> gclocals·VRdgPw/B1qZRso/lfzPG6g==
runtime.schedtrace -> gclocals·KMo9CgFW/QE4XuR2lrIdXQ==
runtime.schedtrace -> strconv.FormatBool.arginfo1
runtime.printsp -> os..stmp_32
runtime.printbool -> go:string."true"
runtime.printbool -> go:string."false"
runtime.printint -> runtime.gcbits.2d00000000000000
runtime.forEachG -> runtime.allglock
runtime.forEachG -> runtime.allgs
runtime.forEachG -> gclocals·m/6RUmNv6NBhMUL8eleFFA==
runtime.dieFromException -> runtime._RaiseFailFastException
runtime.dieFromException -> gclocals·TjPuuCwdlCpTaRQGRKTrYw==
runtime.dieFromException -> gclocals·6L2eDUEpYeRg9PbHa2vTWA==
runtime.dieFromException -> runtime.dieFromException.stkobj
runtime.(*moduledata).textAddr -> go:string."runtime: textAddr "
runtime.(*moduledata).textAddr -> go:string." out of range "
runtime.(*moduledata).textAddr -> go:string." - "
runtime.(*moduledata).textAddr -> go:string."runtime: text offset out of range"
runtime.(*moduledata).textAddr -> fmt.(*buffer).writeRune.arginfo1
runtime.(*moduledata).funcName -> runtime.findnull
runtime.(*moduledata).funcName -> gclocals·VfBBYR1OZkNEohKBh3RGug==
runtime.(*moduledata).funcName -> syscall.cgocaller.stkobj
runtime.findnull -> internal/bytealg.IndexByteString
runtime.findnull -> gclocals·EaSrzstw4eNlskfTrAV10A==
runtime.findfunc -> runtime.firstmoduledata
runtime.findfunc -> runtime.panicIndexU
runtime.pcdatavalue2 -> runtime.pcvalue
runtime.pcdatavalue2 -> runtime.pcdatavalue2.arginfo1
runtime.pcvalue -> go:string."runtime: no module data for "
runtime.pcvalue -> go:string."no module data"
runtime.pcvalue -> runtime.step
runtime.pcvalue -> go:string."runtime: invalid pc-encoded table f="
runtime.pcvalue -> go:string." targetpc="
runtime.pcvalue -> go:string." tab="
runtime.pcvalue -> runtime.printslice
runtime.pcvalue -> go:string."\tvalue="
runtime.pcvalue -> go:string." until pc="
runtime.pcvalue -> go:string."invalid runtime symbol table"
runtime.pcvalue -> gclocals·+Wnb9I7aL4ivtdCMXAoKLw==
runtime.pcvalue -> gclocals·zCbB3T8n7beWYEDZuNkfOQ==
runtime.pcvalue -> runtime.pcvalue.arginfo1
runtime.pcvalue -> sort.median_func.argliveinfo
runtime.printslice -> go:string."/"
runtime.printslice -> go:string."]"
runtime.printslice -> runtime.bytesHash.stkobj
runtime.step -> gclocals·K/k0bod1MAmVF3/kRdmjOw==
runtime.step -> runtime.step.arginfo1
runtime.newInlineUnwinder -> runtime.pcdatavalue1
runtime.newInlineUnwinder -> gclocals·EUjEX2orfX51cRSjtTSSXA==
runtime.newInlineUnwinder -> gclocals·0QCbHm9/XaedB/vjix7tCQ==
runtime.newInlineUnwinder -> fmt.parsenum.arginfo1
runtime.pcdatavalue1 -> gclocals·yYO/bZGpRzWlVHY50H8OcA==
runtime.write -> runtime.overrideWrite
runtime.write -> runtime.write1
runtime.write -> gclocals·IuErl7MOXaHVn7EZYWzfFA==
runtime.write -> runtime.mapaccess1_fast32.arginfo1
runtime.write1 -> runtime._GetStdHandle
runtime.write1 -> runtime._GetConsoleMode
runtime.write1 -> runtime.writeConsole
runtime.write1 -> runtime._WriteFile
runtime.write1 -> runtime.stdcall5
runtime.write1 -> runtime.panicSliceAlen
runtime.write1 -> fmt.(*fmt).padString.argliveinfo
runtime.writeConsole -> runtime.utf16ConsoleBackLock
runtime.writeConsole -> runtime.decoderune
runtime.writeConsole -> runtime.utf16ConsoleBack
runtime.writeConsole -> runtime.writeConsoleUTF16
runtime.writeConsole -> gclocals·xHaoWvF9dWwWDyl5o/zypw==
runtime.writeConsole -> gclocals·Tal5oezCuD+q6Trdapm8MA==
runtime.writeConsole -> runtime.freeUserArenaChunk.stkobj
runtime.writeConsoleUTF16 -> runtime._WriteConsoleW
runtime.writeConsoleUTF16 -> fmt.(*fmt).pad.arginfo1
runtime.stdcall5 -> runtime.dumpmemprof_callback.arginfo1
runtime.traceback1 -> runtime.iscgo
runtime.traceback1 -> runtime.duffcopy
runtime.traceback1 -> runtime.printCgoTraceback
runtime.traceback1 -> runtime.traceback1.func1
runtime.traceback1 -> runtime.printcreatedby
runtime.traceback1 -> runtime.printAncestorTraceback
runtime.traceback1 -> gclocals·Ba8uy9PSPmbZX2QW1FJ73g==
runtime.traceback1 -> gclocals·FEshSTUqCk0aEJZsNpk7+A==
runtime.traceback1 -> runtime.traceback1.stkobj
runtime.traceback1 -> reflect.(*abiSeq).assignIntN.arginfo1
runtime.traceback1 -> reflect.Value.SetIterKey.argliveinfo
runtime.printcreatedby -> runtime.showframe
runtime.printcreatedby -> runtime.printcreatedby1
runtime.printcreatedby1 -> go:string."created by "
runtime.printcreatedby1 -> runtime.printFuncName
runtime.printcreatedby1 -> go:string." in goroutine "
runtime.printcreatedby1 -> runtime.funcline1
runtime.printcreatedby1 -> runtime.gcbits.0900000000000000
runtime.printcreatedby1 -> go:string.":"
runtime.printcreatedby1 -> go:string." +"
runtime.printcreatedby1 -> reflect.StructTag.Lookup.argliveinfo
runtime.funcline1 -> runtime.gcbits.3f00000000000000
runtime.funcline1 -> runtime.funcfile
runtime.funcline1 -> runtime.funcline1.arginfo1
runtime.funcfile -> fmt.FormatString.arginfo1
runtime.printFuncName -> go:string."panic"
runtime.printFuncName -> runtime.funcNamePiecesForPrint
runtime.printFuncName -> gclocals·FrUZ3KOpNWLWMINDNZ6Y4w==
runtime.funcNamePiecesForPrint -> go:string."[...]"
runtime.traceback1.func1 -> runtime.(*unwinder).initAt
runtime.traceback1.func1 -> runtime.traceback2
runtime.traceback1.func1 -> go:string."..."
runtime.traceback1.func1 -> go:string." frames elided...\n"
runtime.(*unwinder).initAt -> runtime.(*unwinder).resolveInternal
runtime.(*unwinder).initAt -> go:string."runtime: g "
runtime.(*unwinder).initAt -> go:string.": unknown pc "
runtime.(*unwinder).initAt -> runtime.tracebackHexdump
runtime.(*unwinder).initAt -> go:string."unknown pc"
runtime.(*unwinder).initAt -> go:string."cannot trace user goroutine on its own stack"
runtime.(*unwinder).initAt -> gclocals·Q745mLw8CzvAMoTWVbRHJg==
runtime.(*unwinder).initAt -> gclocals·ykHN0vawYuq1dUW4zEe2gA==
runtime.(*unwinder).initAt -> runtime.selectgo.arginfo1
runtime.(*unwinder).initAt -> fmt.(*pp).printValue.argliveinfo
runtime.(*unwinder).resolveInternal -> runtime.(*unwinder).finishInternal
runtime.(*unwinder).resolveInternal -> go:string."traceback: unexpected SPWRITE function "
runtime.(*unwinder).resolveInternal -> go:string."traceback"
runtime.(*unwinder).resolveInternal -> gclocals·bb+LSCCik3x40Cn8eFqL9w==
runtime.(*unwinder).resolveInternal -> gclocals·dWfovk9haRLV9HOdqHCp5w==
runtime.(*unwinder).resolveInternal -> runtime.startm.arginfo1
runtime.(*unwinder).resolveInternal -> runtime.(*unwinder).resolveInternal.argliveinfo
runtime.(*unwinder).finishInternal -> go:string."runtime: g"
runtime.(*unwinder).finishInternal -> go:string.": frame.sp="
runtime.(*unwinder).finishInternal -> go:string." top="
runtime.(*unwinder).finishInternal -> go:string."\tstack=["
runtime.(*unwinder).finishInternal -> go:string."traceback did not unwind completely"
runtime.traceback2 -> runtime.traceback2.func1
runtime.traceback2 -> runtime.(*unwinder).next
runtime.traceback2 -> runtime.(*unwinder).symPC
runtime.traceback2 -> runtime.(*unwinder).cgoCallers
runtime.traceback2 -> runtime.(*inlineUnwinder).next
runtime.traceback2 -> runtime.gcbits.2800000000000000
runtime.traceback2 -> runtime.printArgs
runtime.traceback2 -> go:string.")\n"
runtime.traceback2 -> go:string." fp="
runtime.traceback2 -> go:string." sp="
runtime.traceback2 -> runtime.cgoSymbolizer
runtime.traceback2 -> go:string."non-Go function at pc="
runtime.traceback2 -> runtime.printOneCgoTraceback
runtime.traceback2 -> runtime.callCgoSymbolizer
runtime.traceback2 -> gclocals·U6FBQZghdIyCNilir7jp2Q==
runtime.traceback2 -> gclocals·v57tlbEwQaxJFoxyLdsWWw==
runtime.traceback2 -> runtime.traceback2.stkobj
runtime.traceback2 -> strconv.FormatFloat.arginfo1
runtime.traceback2 -> reflect.mapassign_faststr.argliveinfo
runtime.(*inlineUnwinder).next -> runtime.(*inlineUnwinder).next.arginfo1
runtime.(*unwinder).next -> go:string.": unexpected return pc for "
runtime.(*unwinder).next -> go:string." called from "
runtime.(*unwinder).next -> go:string."unknown caller pc"
runtime.(*unwinder).next -> go:string."runtime: traceback stuck. pc="
runtime.(*unwinder).next -> go:string."traceback stuck"
runtime.(*unwinder).next -> gclocals·Tc/LeluABNzhfUMhkZPKmg==
runtime.(*unwinder).next -> gclocals·ZOtjrHpLPSywUj5LsoWzXw==
runtime.(*unwinder).cgoCallers -> runtime.cgoTraceback
runtime.(*unwinder).cgoCallers -> runtime.cgoContextPCs
runtime.(*unwinder).cgoCallers -> gclocals·LqP3g2EGGEr/6X6Jjn96VQ==
runtime.(*unwinder).cgoCallers -> sort.SliceIsSorted.argliveinfo
runtime.printArgs -> runtime.pcdatavalue
runtime.printArgs -> runtime.printArgs.func1
runtime.printArgs -> runtime.printArgs.func2
runtime.printArgs -> go:string.", "
runtime.printArgs -> go:string."_"
runtime.printArgs -> go:string."{"
runtime.printArgs -> go:string."}"
runtime.printArgs -> gclocals·XR3pl990RuQudxPnqsn0mQ==
runtime.printArgs -> gclocals·ItW38P+2uMO2Mw5Sx6af+A==
runtime.printArgs -> runtime.printArgs.stkobj
runtime.pcdatavalue -> runtime.pcdatavalue.arginfo1
runtime.printArgs.func2 -> runtime.printArgs.func2.arginfo1
runtime.printArgs.func1 -> internal/abi.NewOffset.arginfo1
runtime.printAncestorTraceback -> go:string."[originating from goroutine "
runtime.printAncestorTraceback -> go:string."]:\n"
runtime.printAncestorTraceback -> runtime.showfuncinfo
runtime.printAncestorTraceback -> runtime.printAncestorTracebackFuncInfo
runtime.printAncestorTraceback -> go:string."...additional frames elided...\n"
runtime.printAncestorTraceback -> runtime.printAncestorTraceback.arginfo1
runtime.printAncestorTracebackFuncInfo -> go:string."(...)\n"
runtime.printAncestorTracebackFuncInfo -> gclocals·f/BV3C6eNL3hkuQeKOyOTA==
runtime.printAncestorTracebackFuncInfo -> fmt.State.Flag.arginfo1
runtime.showframe -> gclocals·dfs/88MXouNqNY2126ZUeg==
runtime.showframe -> runtime.showframe.arginfo1
runtime.showfuncinfo -> runtime.showfuncinfo.arginfo1
runtime.showfuncinfo -> sort.order2_func.argliveinfo
runtime.goroutineheader -> runtime.gStatusStrings
runtime.goroutineheader -> go:string."???"
runtime.goroutineheader -> go:string."unknown wait reason"
runtime.goroutineheader -> runtime.waitReasonStrings
runtime.goroutineheader -> go:string."goroutine "
runtime.goroutineheader -> go:string." ["
runtime.goroutineheader -> go:string." (scan)"
runtime.goroutineheader -> go:string." minutes"
runtime.goroutineheader -> go:string.", locked to thread"
runtime.tracebackothers -> runtime.tracebackothers.func1
runtime.tracebackothers -> runtime.forEachGRace
runtime.tracebackothers -> gclocals·FzOviaiNvskOOLPK/yRhOA==
runtime.tracebackothers -> runtime.newproc.stkobj
runtime.forEachGRace -> runtime.allglen
runtime.forEachGRace -> runtime.allgptr
runtime.tracebackothers.func1 -> runtime.isSystemGoroutine
runtime.tracebackothers.func1 -> go:string."\tgoroutine running on other thread; stack unavailable\n"
runtime.tracebackHexdump -> go:string."stack: frame={sp:"
runtime.tracebackHexdump -> go:string.", fp:"
runtime.tracebackHexdump -> go:string."} stack=["
runtime.tracebackHexdump -> runtime.gcbits.2c00000000000000
runtime.tracebackHexdump -> runtime.tracebackHexdump.func1
runtime.tracebackHexdump -> runtime.hexdumpWords
runtime.tracebackHexdump -> gclocals·pjkiW5J2QfpsfPzMt9QzFQ==
runtime.hexdumpWords -> go:string.": "
runtime.hexdumpWords -> go:string."<"
runtime.hexdumpWords -> go:string."+"
runtime.hexdumpWords -> go:string."> "
runtime.hexdumpWords -> gclocals·sj+B3vQUV7APRutK5sO4vA==
runtime.isSystemGoroutine -> runtime.fingStatus
runtime.isSystemGoroutine -> fmt.(*fmt).fmtBoolean.arginfo1
runtime.printCgoTraceback -> runtime.printCgoTraceback.func1·f
runtime.printCgoTraceback -> gclocals·D5ZMXVuQMb80y0tMU+yRLQ==
runtime.printCgoTraceback -> runtime.printCgoTraceback.stkobj
runtime.printOneCgoTraceback -> go:string."non-Go function\n"
runtime.printOneCgoTraceback -> go:string."pc="
runtime.printOneCgoTraceback -> gclocals·bJ9n6rIzqGpU1z9xCWqf2w==
runtime.printOneCgoTraceback -> gclocals·ihFADTfH9LqsUHGB6VCHQQ==
runtime.printOneCgoTraceback -> runtime.printOneCgoTraceback.stkobj
runtime.callCgoSymbolizer -> runtime.asmcgocall·f
runtime.callCgoSymbolizer -> runtime.cgocall·f
runtime.cgoContextPCs -> gclocals·EXTrhv4b3ahawRWAszmcVw==
runtime.cgoContextPCs -> runtime.cgoContextPCs.stkobj
 -> go:info.bool
 -> go:info.runtime/internal/atomic.Uint32
 -> go:info.runtime.mheap
 -> go:info.runtime.stdFunction
 -> go:info.unsafe.Pointer
 -> go:info.uint32
 -> go:info.[1000]uint16
 -> go:info.runtime.mutex
 -> go:info.uintptr
 -> go:info.[512]uint8
 -> go:info.int
 -> go:info.[]*runtime.g
 -> go:info.**runtime.g
 -> go:info.runtime/internal/atomic.Bool
 -> go:info.int64
 -> go:info.struct { runtime.cgocheck int32; runtime.clobberfree int32; runtime.dontfreezetheworld int32; runtime.efence int32; runtime.gccheckmark int32; runtime.gcpacertrace int32; runtime.gcshrinkstackoff int32; runtime.gcstoptheworld int32; runtime.gctrace int32; runtime.invalidptr int32; runtime.madvdontneed int32; runtime.scavtrace int32; runtime.scheddetail int32; runtime.schedtrace int32; runtime.tracebackancestors int32; runtime.asyncpreemptoff int32; runtime.harddecommit int32; runtime.adaptivestackstart int32; runtime.tracefpunwindoff int32; runtime.malloc bool; runtime.allocfreetrace int32; runtime.inittrace int32; runtime.sbrk int32; runtime.panicnil runtime/internal/atomic.Int32 }
runtime.waitReasonStrings -> go:string."GC assist marking"
runtime.waitReasonStrings -> go:string."IO wait"
runtime.waitReasonStrings -> go:string."chan receive (nil chan)"
runtime.waitReasonStrings -> go:string."chan send (nil chan)"
runtime.waitReasonStrings -> go:string."dumping heap"
runtime.waitReasonStrings -> go:string."garbage collection"
runtime.waitReasonStrings -> go:string."garbage collection scan"
runtime.waitReasonStrings -> go:string."panicwait"
runtime.waitReasonStrings -> go:string."select"
runtime.waitReasonStrings -> go:string."select (no cases)"
runtime.waitReasonStrings -> go:string."GC assist wait"
runtime.waitReasonStrings -> go:string."GC sweep wait"
runtime.waitReasonStrings -> go:string."GC scavenge wait"
runtime.waitReasonStrings -> go:string."chan receive"
runtime.waitReasonStrings -> go:string."chan send"
runtime.waitReasonStrings -> go:string."finalizer wait"
runtime.waitReasonStrings -> go:string."force gc (idle)"
runtime.waitReasonStrings -> go:string."semacquire"
runtime.waitReasonStrings -> go:string."sleep"
runtime.waitReasonStrings -> go:string."sync.Cond.Wait"
runtime.waitReasonStrings -> go:string."sync.Mutex.Lock"
runtime.waitReasonStrings -> go:string."sync.RWMutex.RLock"
runtime.waitReasonStrings -> go:string."sync.RWMutex.Lock"
runtime.waitReasonStrings -> go:string."trace reader (blocked)"
runtime.waitReasonStrings -> go:string."wait for GC cycle"
runtime.waitReasonStrings -> go:string."GC worker (idle)"
runtime.waitReasonStrings -> go:string."GC worker (active)"
runtime.waitReasonStrings -> go:string."preempted"
runtime.waitReasonStrings -> go:string."debug call"
runtime.waitReasonStrings -> go:string."GC mark termination"
runtime.waitReasonStrings -> go:string."stopping the world"
 -> go:info.[32]string
 -> go:info.*runtime.m
 -> go:info.int32
 -> go:info.runtime.schedt
 -> go:info.[]*runtime.p
 -> go:info.runtime.moduledata
 -> go:info.func(uintptr, unsafe.Pointer, int32) int32
runtime.gStatusStrings -> go:string."idle"
runtime.gStatusStrings -> go:string."runnable"
runtime.gStatusStrings -> go:string."running"
runtime.gStatusStrings -> go:string."syscall"
runtime.gStatusStrings -> go:string."waiting"
runtime.gStatusStrings -> go:string."dead"
runtime.gStatusStrings -> go:string."copystack"
 -> go:info.[10]string
 -> go:info.*runtime.mutex
 -> go:info.*runtime.g
 -> go:info.runtime.osyield$abstract
 -> go:info.runtime.lock$abstract
 -> go:info.runtime.lockWithRank$abstract
 -> go:info.[]uint8
 -> go:info.[]uint16
 -> go:info.string
 -> go:info.runtime.unlock$abstract
 -> go:info.runtime.unlockWithRank$abstract
 -> go:info.runtime.nanotime$abstract
 -> go:info.runtime.timediv$abstract
 -> go:info.runtime.(*guintptr).set$abstract
 -> go:info.*runtime.context
 -> go:info.[1247]uint8
 -> go:info.runtime/internal/atomic.(*Uint32).Add$abstract
 -> go:info.runtime.gFromSP$abstract
 -> go:info.runtime.(*context).sp$abstract
 -> go:info.runtime.wantAsyncPreempt$abstract
 -> go:info.runtime.readgstatus$abstract
 -> go:info.runtime/internal/atomic.(*Uint32).Load$abstract
 -> go:info.runtime.(*context).ip$abstract
 -> go:info.runtime.(*context).set_sp$abstract
 -> go:info.runtime.(*context).set_ip$abstract
 -> go:info.runtime.throwType
 -> go:info.runtime.crash$abstract
 -> go:info.runtime.traceback$abstract
 -> go:info.runtime.gotraceback$abstract
 -> go:info.runtime.inlineUnwinder
 -> go:info.*uint8
 -> go:info.runtime.canPreemptM$abstract
 -> go:info.runtime.funcInfo.valid$abstract
 -> go:info.runtime.funcdata$abstract
 -> go:info.runtime.(*inlineUnwinder).srcFunc$abstract
 -> go:info.runtime.funcInfo.srcFunc$abstract
 -> go:info.runtime.srcFunc.name$abstract
 -> go:info.runtime.hasPrefix$abstract
 -> go:info.runtime.funcInfo.entry$abstract
 -> go:info.runtime.printunlock$abstract
 -> go:info.runtime.writeErr$abstract
 -> go:info.uint64
 -> go:info.[100]uint8
 -> go:info.runtime.bytes$abstract
 -> go:info.runtime.printpointer$abstract
 -> go:info.func(uintptr) uint8
 -> go:info.[1]uint8
 -> go:info.runtime.funcname$abstract
 -> go:info.func(*runtime.g)
 -> go:info.runtime.atomicAllG$abstract
 -> go:info.runtime.atomicAllGIndex$abstract
 -> go:info.runtime/internal/atomic.(*Bool).Store$abstract
 -> go:info.runtime/internal/atomic.(*Uint8).Store$abstract
 -> go:info.runtime.usleep$abstract
 -> go:info.*runtime.p
 -> go:info.runtime/internal/atomic.(*Int32).Load$abstract
 -> go:info.runtime.mcount$abstract
 -> go:info.runtime/internal/atomic.(*Bool).Load$abstract
 -> go:info.runtime/internal/atomic.(*Uint8).Load$abstract
 -> go:info.runtime.muintptr.ptr$abstract
 -> go:info.runtime.puintptr.ptr$abstract
 -> go:info.*runtime.exceptionrecord
 -> go:info.*runtime.moduledata
 -> go:info.runtime.gostringnocopy$abstract
 -> go:info.runtime.funcInfo
 -> go:info.*runtime.findfuncbucket
 -> go:info.runtime.findmoduledatap$abstract
 -> go:info.runtime.(*moduledata).textOff$abstract
 -> go:info.runtime.add$abstract
 -> go:info.*runtime.pcvalueCache
 -> go:info.*[8]runtime.pcvalueCacheEnt
 -> go:info.runtime.pcvalueCacheKey$abstract
 -> go:info.runtime.fastrandn$abstract
 -> go:info.runtime.fastrand$abstract
 -> go:info.runtime.pcdatastart$abstract
 -> go:info.*uintptr
 -> go:info.*int32
 -> go:info.runtime.readvarint$abstract
 -> go:info.runtime.inlineFrame
 -> go:info.*[1048576]runtime.inlinedCall
 -> go:info.runtime.(*inlineUnwinder).resolveInternal$abstract
 -> go:info.*runtime.inlineUnwinder
 -> go:info.*runtime.unwinder
 -> go:info.runtime.unwindFlags
 -> go:info.runtime.stkframe
 -> go:info.runtime.(*g).guintptr$abstract
 -> go:info.internal/abi.FuncFlag
 -> go:info.runtime.funcspdelta$abstract
 -> go:info.runtime.guintptr.ptr$abstract
 -> go:info.[]uintptr
 -> go:info.*[171]uint8
 -> go:info.uint8
 -> go:info.func(uint8, uint8) bool
 -> go:info.func(uint8, uint8, uint8)
 -> go:info.runtime.printArgs.func3$abstract
 -> go:info.runtime.readUnaligned64$abstract
 -> go:info.runtime.funcline$abstract
 -> go:info.func(bool) int
 -> go:info.runtime.unwinder
 -> go:info.runtime.cgoCallers
 -> go:info.runtime.ancestorInfo
 -> go:info.runtime/internal/atomic.(*Uint32).Store$abstract
 -> go:info.func() (bool, bool)
 -> go:info.[32]uintptr
 -> go:info.internal/abi.FuncID
 -> go:info.runtime.srcFunc
 -> go:info.runtime.cgoSymbolizerArg
 -> go:info.runtime.(*unwinder).valid$abstract
 -> go:info.runtime.inlineFrame.valid$abstract
 -> go:info.runtime.traceback2.func1$abstract
 -> go:info.runtime.(*inlineUnwinder).fileLine$abstract
 -> go:info.*int
 -> go:info.runtime.elideWrapperCalling$abstract
 -> go:info.runtime.isExportedRuntime$abstract
 -> go:info.runtime.waitReason.String$abstract
 -> go:info.runtime.stack
 -> go:info.*runtime.stkframe
 -> go:info.*runtime.cgoCallers
 -> go:info.*runtime.cgoSymbolizerArg
 -> go:info.func(unsafe.Pointer, unsafe.Pointer) int32
 -> go:info.runtime.cgoTracebackArg
os.Mkdir.stkobj -> runtime.gcbits.0200000000000000
runtime.memequal -> memeqbody
memeqbody -> internal/cpu.X86
 -> go:info.struct { internal/cpu._ internal/cpu.CacheLinePad; HasAES bool; HasADX bool; HasAVX bool; HasAVX2 bool; HasBMI1 bool; HasBMI2 bool; HasERMS bool; HasFMA bool; HasOSXSAVE bool; HasPCLMULQDQ bool; HasPOPCNT bool; HasRDTSCP bool; HasSHA bool; HasSSE3 bool; HasSSSE3 bool; HasSSE41 bool; HasSSE42 bool; internal/cpu._ internal/cpu.CacheLinePad }
internal/bytealg.IndexByteString -> indexbytebody
internal/bytealg.IndexByteString -> internal/bytealg.IndexByteString.args_stackmap
internal/bytealg.IndexByteString -> internal/bytealg.IndexByteString.arginfo0
runtime.bytesHash.stkobj -> runtime.gcbits.0100000000000000
runtime.isAsyncSafePoint.stkobj -> runtime.gcbits.0c00000000000000
runtime.newproc.stkobj -> runtime.gcbits.0600000000000000
runtime.traceback1.stkobj -> runtime.gcbits.2200000000000000
runtime.traceback2.stkobj -> runtime.gcbits.1e00000000000000
runtime.cgoContextPCs.stkobj -> runtime.gcbits.0400000000000000
go:info.runtime.readUnaligned64$abstract -> go:info.*[8]uint8
go:info.runtime.(*guintptr).set$abstract -> go:info.*runtime.guintptr
go:info.runtime/internal/atomic.(*Uint32).Load$abstract -> go:info.*runtime/internal/atomic.Uint32
go:info.runtime.puintptr.ptr$abstract -> go:info.runtime.puintptr
go:info.runtime.(*moduledata).textOff$abstract -> go:info.runtime.textsect
go:info.runtime.gostringnocopy$abstract -> go:info.runtime.stringStruct
go:info.runtime.waitReason.String$abstract -> go:info.runtime.waitReason
go:info.runtime/internal/atomic.(*Uint8).Load$abstract -> go:info.*runtime/internal/atomic.Uint8
go:info.runtime/internal/atomic.(*Bool).Load$abstract -> go:info.*runtime/internal/atomic.Bool
go:info.runtime/internal/atomic.(*Int32).Load$abstract -> go:info.*runtime/internal/atomic.Int32
go:info.runtime.guintptr.ptr$abstract -> go:info.runtime.guintptr
go:info.runtime.muintptr.ptr$abstract -> go:info.runtime.muintptr
go:info.runtime.lockWithRank$abstract -> go:info.runtime.lockRank
go:info.runtime.(*inlineUnwinder).srcFunc$abstract -> go:info.*runtime.inlinedCall
go:info.runtime.bytes$abstract -> go:info.*runtime.slice
go:info.runtime.bytes$abstract -> go:info.*runtime.stringStruct
runtime.asmcgocall·f -> runtime.asmcgocall
runtime.cgocall·f -> runtime.cgocall
runtime.cgocall -> runtime.entersyscall
runtime.cgocall -> runtime.exitsyscall
runtime.cgocall -> go:string."cgocall nil"
runtime.cgocall -> gclocals·ROUSt0/vdGh5KGeocNshSw==
 -> go:info.runtime.osPreemptExtEnter$abstract
 -> go:info.runtime.osPreemptExtExit$abstract
runtime.entersyscall -> runtime.reentersyscall
runtime.reentersyscall -> runtime.save
runtime.reentersyscall -> runtime.casgstatus
runtime.reentersyscall -> runtime.reentersyscall.func1
runtime.reentersyscall -> runtime.trace
runtime.reentersyscall -> runtime.traceGoSysCall·f
runtime.reentersyscall -> runtime.entersyscall_sysmon·f
runtime.reentersyscall -> runtime.runSafePointFn·f
runtime.reentersyscall -> runtime.entersyscall_gcwait·f
runtime.reentersyscall -> fmt.(*pp).badVerb.stkobj
runtime.casgstatus -> runtime.casgstatus.func1
runtime.casgstatus -> runtime.casgstatusAlwaysTrack
runtime.casgstatus -> runtime.(*timeHistogram).record
runtime.casgstatus -> go:string."casgstatus: waiting for Gwaiting but is Grunnable"
runtime.casgstatus -> sync.(*poolDequeue).pack.arginfo1
runtime.casgstatus.func1 -> go:string."runtime: casgstatus: oldval="
runtime.casgstatus.func1 -> go:string." newval="
runtime.casgstatus.func1 -> go:string."casgstatus: bad incoming values"
runtime.save -> runtime.badctxt
runtime.save -> go:string."save on system g not allowed"
runtime.badctxt -> go:string."ctxt != 0"
runtime.reentersyscall.func1 -> go:string."entersyscall inconsistent "
runtime.reentersyscall.func1 -> go:string."entersyscall"
 -> go:info.struct { runtime.lock runtime.mutex; runtime.lockOwner *runtime.g; runtime.enabled bool; runtime.shutdown bool; runtime.headerWritten bool; runtime.footerWritten bool; runtime.shutdownSema uint32; runtime.seqStart uint64; runtime.ticksStart int64; runtime.ticksEnd int64; runtime.timeStart int64; runtime.timeEnd int64; runtime.seqGC uint64; runtime.reading runtime.traceBufPtr; runtime.empty runtime.traceBufPtr; runtime.fullHead runtime.traceBufPtr; runtime.fullTail runtime.traceBufPtr; runtime.stackTab runtime.traceStackTable; runtime.cpuLogRead *runtime.profBuf; runtime.cpuLogBuf runtime.traceBufPtr; runtime.reader runtime/internal/atomic.Pointer[runtime.g]; runtime.signalLock runtime/internal/atomic.Uint32; runtime.cpuLogWrite *runtime.profBuf; runtime.stringsLock runtime.mutex; runtime.strings map[string]uint64; runtime.stringSeq uint64; runtime.markWorkerLabels [4]uint64; runtime.bufLock runtime.mutex; runtime.buf runtime.traceBufPtr }
 -> go:info.*runtime.timeHistogram
 -> go:info.uint
 -> go:info.runtime/internal/atomic.(*Uint64).Add$abstract
 -> go:info.runtime/internal/atomic.(*Uint32).CompareAndSwap$abstract
 -> go:info.runtime.waitReason.isMutexWait$abstract
 -> go:info.runtime/internal/atomic.(*Int64).Add$abstract
 -> go:info.runtime.traceEnabled$abstract
 -> go:info.runtime.(*puintptr).set$abstract
runtime.exitsyscall -> runtime.exitsyscallfast
runtime.exitsyscall -> runtime.goroutineProfile
runtime.exitsyscall -> runtime.exitsyscall.func1
runtime.exitsyscall -> runtime.traceGoStart·f
runtime.exitsyscall -> runtime.gosched_m·f
runtime.exitsyscall -> runtime.mcall
runtime.exitsyscall -> runtime.exitsyscall0·f
runtime.exitsyscall -> runtime.cputicks
runtime.exitsyscall -> go:string."exitsyscall: syscall frame is no longer valid"
runtime.exitsyscall -> gclocals·iMHfAR7xykpO5ViIa+y6gQ==
runtime.exitsyscall.func1 -> runtime.tryRecordGoroutineProfileWB
runtime.tryRecordGoroutineProfileWB -> runtime.osyield·f
runtime.tryRecordGoroutineProfileWB -> runtime.tryRecordGoroutineProfile
runtime.tryRecordGoroutineProfileWB -> go:string."no P available, write barriers are forbidden"
runtime.tryRecordGoroutineProfile -> runtime.doRecordGoroutineProfile
runtime.doRecordGoroutineProfile -> runtime.doRecordGoroutineProfile.func1
runtime.doRecordGoroutineProfile -> runtime.writeBarrier
runtime.doRecordGoroutineProfile -> runtime.gcWriteBarrier2
runtime.doRecordGoroutineProfile -> go:string."doRecordGoroutineProfile gp1="
runtime.doRecordGoroutineProfile -> go:string."cannot read stack of running goroutine"
runtime.doRecordGoroutineProfile.func1 -> runtime.saveg
runtime.saveg -> runtime.tracebackPCs
runtime.saveg -> gclocals·8JHXFj/EadDeYa+ijofN/g==
runtime.exitsyscallfast -> runtime.wirep
runtime.exitsyscallfast -> runtime.exitsyscallfast_reacquired
runtime.exitsyscallfast -> runtime.exitsyscallfast.func1
runtime.exitsyscallfast -> runtime.markroot.stkobj
runtime.exitsyscallfast.func1 -> runtime.exitsyscallfast_pidle
runtime.exitsyscallfast.func1 -> runtime.traceGoSysExit
runtime.exitsyscallfast.func1 -> gclocals·DzdMMqVhLeN61kBRBcdZoQ==
runtime.exitsyscallfast_reacquired -> runtime.exitsyscallfast_reacquired.func1
runtime.exitsyscallfast_reacquired.func1 -> runtime.traceGoSysBlock
runtime.exitsyscallfast_pidle -> runtime.pidleget
runtime.exitsyscallfast_pidle -> runtime.notewakeup
runtime.exitsyscallfast_pidle -> runtime.acquirep
runtime.notewakeup -> go:string."notewakeup - double wakeup"
runtime.acquirep -> runtime.(*mcache).prepareForSweep
runtime.acquirep -> runtime.traceEvent
runtime.(*mcache).prepareForSweep -> runtime.(*mcache).releaseAll
runtime.(*mcache).prepareForSweep -> runtime.stackcache_clear
runtime.(*mcache).prepareForSweep -> go:string."bad flushGen "
runtime.(*mcache).prepareForSweep -> go:string." in prepareForSweep; sweepgen "
runtime.(*mcache).prepareForSweep -> go:string."bad flushGen"
runtime.(*mcache).releaseAll -> runtime.emptymspan
runtime.(*mcache).releaseAll -> runtime.memstats
runtime.(*mcache).releaseAll -> runtime.(*consistentHeapStats).acquire
runtime.(*mcache).releaseAll -> runtime.(*consistentHeapStats).release
runtime.(*mcache).releaseAll -> runtime.gcController
runtime.(*mcache).releaseAll -> runtime.(*mcentral).uncacheSpan
runtime.(*mcache).releaseAll -> runtime.(*gcControllerState).update
runtime.(*mcentral).uncacheSpan -> runtime.(*spanSet).push
runtime.(*mcentral).uncacheSpan -> runtime.(*sweepLocked).sweep
runtime.(*mcentral).uncacheSpan -> go:string."uncaching span but s.allocCount == 0"
runtime.(*gcControllerState).update -> runtime.gcBlackenEnabled
runtime.(*gcControllerState).update -> runtime.(*gcControllerState).revise
runtime.(*gcControllerState).revise -> runtime.(*gcControllerState).heapGoalInternal
runtime.(*gcControllerState).revise -> $f64.4059000000000000
runtime.(*gcControllerState).revise -> $f64.3ff0000000000000
runtime.(*gcControllerState).revise -> $f64.3ff199999999999a
runtime.(*gcControllerState).heapGoalInternal -> runtime.(*gcControllerState).memoryLimitHeapGoal
runtime.(*sweepLocked).sweep -> runtime.traceGCSweepSpan
runtime.(*sweepLocked).sweep -> runtime.freeSpecial
runtime.(*sweepLocked).sweep -> runtime.(*mspan).reportZombies
runtime.(*sweepLocked).sweep -> runtime.x86HasPOPCNT
runtime.(*sweepLocked).sweep -> runtime/internal/sys.OnesCount64
runtime.(*sweepLocked).sweep -> runtime.newMarkBits
runtime.(*sweepLocked).sweep -> runtime.(*mspan).refillAllocCache
runtime.(*sweepLocked).sweep -> runtime.(*sweepLocked).sweep.func1
runtime.(*sweepLocked).sweep -> runtime.(*sweepLocked).sweep.func2
runtime.(*sweepLocked).sweep -> runtime.sysUnusedOS
runtime.(*sweepLocked).sweep -> runtime.(*sweepLocked).sweep.func3
runtime.(*sweepLocked).sweep -> go:string."sweep: tried to preserve a user arena span"
runtime.(*sweepLocked).sweep -> go:string."swept cached span"
runtime.(*sweepLocked).sweep -> go:string."mspan.sweep: state="
runtime.(*sweepLocked).sweep -> go:string." sweepgen="
runtime.(*sweepLocked).sweep -> go:string." mheap.sweepgen="
runtime.(*sweepLocked).sweep -> go:string."mspan.sweep: bad span state after sweep"
runtime.(*sweepLocked).sweep -> go:string."runtime: nelems="
runtime.(*sweepLocked).sweep -> go:string." nalloc="
runtime.(*sweepLocked).sweep -> go:string." previous allocCount="
runtime.(*sweepLocked).sweep -> go:string." nfreed="
runtime.(*sweepLocked).sweep -> go:string."sweep increased allocation count"
runtime.(*sweepLocked).sweep -> runtime.tracefree
runtime.(*sweepLocked).sweep -> runtime.panicdivide
runtime.(*sweepLocked).sweep -> go:string."mspan.sweep: bad span state"
runtime.(*sweepLocked).sweep -> go:string."mspan.sweep: m is not locked"
runtime.(*sweepLocked).sweep -> gclocals·H9o4QuyhLpiuyqMbvx/BVw==
runtime.(*sweepLocked).sweep -> gclocals·n/cOsnmkODZHX08zgfnGnw==
runtime.(*sweepLocked).sweep -> runtime.(*sweepLocked).sweep.stkobj
runtime.sysUnusedOS -> runtime._VirtualFree
runtime.sysUnusedOS -> go:string."runtime: VirtualFree of "
runtime.sysUnusedOS -> go:string." bytes failed with errno="
runtime.sysUnusedOS -> go:string."runtime: failed to decommit pages"
runtime.(*sweepLocked).sweep.func3 -> runtime.puintptr.ptr
runtime.(*sweepLocked).sweep.func3 -> runtime.(*mspan).base
runtime.(*sweepLocked).sweep.func3 -> runtime.pageTraceFree
runtime.(*sweepLocked).sweep.func3 -> runtime.lock
runtime.(*sweepLocked).sweep.func3 -> runtime.(*mheap).freeSpanLocked
runtime.(*sweepLocked).sweep.func3 -> runtime.unlock
runtime.(*sweepLocked).sweep.func1 -> runtime.(*mSpanList).remove
runtime.(*sweepLocked).sweep.func1 -> runtime.(*mSpanList).insert
runtime.(*sweepLocked).sweep.func1 -> go:string."user arena span is on the wrong list"
runtime.(*mspan).reportZombies -> go:string."runtime: marked free object in span "
runtime.(*mspan).reportZombies -> runtime.printuintptr
runtime.(*mspan).reportZombies -> go:string.", elemsize="
runtime.(*mspan).reportZombies -> go:string." freeindex="
runtime.(*mspan).reportZombies -> go:string." (bad use of unsafe.Pointer? try -d=checkptr)\n"
runtime.(*mspan).reportZombies -> go:string." alloc"
runtime.(*mspan).reportZombies -> go:string." free "
runtime.(*mspan).reportZombies -> go:string." marked  "
runtime.(*mspan).reportZombies -> go:string." unmarked"
runtime.(*mspan).reportZombies -> go:string." zombie"
runtime.(*mspan).reportZombies -> go:string."found pointer to free object"
runtime.(*mspan).reportZombies -> gclocals·ywzTtdCORaV6scHpzk5qeg==
runtime.(*mspan).reportZombies -> runtime.(*mspan).reportZombies.stkobj
runtime.(*mheap).freeSpanLocked -> runtime.(*sysMemStat).add
runtime.(*mheap).freeSpanLocked -> runtime.(*pageAlloc).free
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - invalid stack free"
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - invalid span state"
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - span "
runtime.(*mheap).freeSpanLocked -> go:string." ptr "
runtime.(*mheap).freeSpanLocked -> go:string." allocCount "
runtime.(*mheap).freeSpanLocked -> go:string." sweepgen "
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - invalid free"
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - invalid free of user arena chunk"
runtime.(*mheap).freeSpanLocked -> fmt.(*pp).fmt0x64.arginfo1
runtime.(*mSpanList).remove -> go:string."runtime: failed mSpanList.remove span.npages="
runtime.(*mSpanList).remove -> go:string." span="
runtime.(*mSpanList).remove -> go:string." prev="
runtime.(*mSpanList).remove -> go:string." span.list="
runtime.(*mSpanList).remove -> go:string." list="
runtime.(*mSpanList).remove -> go:string."mSpanList.remove"
runtime.(*mSpanList).insert -> go:string."runtime: failed mSpanList.insert "
runtime.(*mSpanList).insert -> go:string."mSpanList.insert"
runtime.freeSpecial -> runtime.mProf_Free
runtime.freeSpecial -> runtime.queuefinalizer
runtime.freeSpecial -> go:string."bad special kind"
runtime.queuefinalizer -> runtime.gcphase
runtime.queuefinalizer -> runtime.finlock
runtime.queuefinalizer -> runtime.finq
runtime.queuefinalizer -> runtime.finc
runtime.queuefinalizer -> runtime.persistentalloc
runtime.queuefinalizer -> runtime.allfin
runtime.queuefinalizer -> runtime.finptrmask
runtime.queuefinalizer -> runtime.gcWriteBarrier6
runtime.queuefinalizer -> runtime.finalizer1
runtime.queuefinalizer -> go:string."queuefinalizer during GC"
runtime.queuefinalizer -> gclocals·QbuORTC759gvi2Ssb6xpCQ==
runtime.persistentalloc -> runtime.persistentalloc.func1
runtime.persistentalloc -> runtime.persistentalloc.stkobj
runtime.persistentalloc.func1 -> runtime.persistentalloc1
runtime.persistentalloc1 -> runtime.globalAlloc
runtime.persistentalloc1 -> runtime.sysAlloc
runtime.persistentalloc1 -> runtime.persistentChunks
runtime.persistentalloc1 -> go:string."runtime: cannot allocate memory"
runtime.persistentalloc1 -> go:string."persistentalloc: align is too large"
runtime.persistentalloc1 -> go:string."persistentalloc: align is not a power of 2"
runtime.persistentalloc1 -> go:string."persistentalloc: size == 0"
runtime.persistentalloc1 -> runtime.morestackc
runtime.persistentalloc1 -> gclocals·fxAY0dnWduWeLyULTXgNwA==
runtime.persistentalloc1 -> gclocals·Ys2QX50FBAYNpNX4cIm9lg==
runtime.persistentalloc1 -> sync.(*Cond).Signal.stkobj
runtime.persistentalloc1 -> fmt.(*pp).WriteString.argliveinfo
runtime.sysAlloc -> runtime._VirtualAlloc
runtime.newMarkBits -> runtime.gcBitsArenas
runtime.newMarkBits -> runtime.newArenaMayUnlock
runtime.newMarkBits -> go:string."markBits overflow"
runtime.(*pageAlloc).free -> runtime.(*pageBits).clearRange
runtime.(*pageAlloc).free -> runtime.(*scavengeIndex).free
runtime.(*pageAlloc).free -> runtime.(*pageAlloc).update
runtime.(*scavengeIndex).free -> runtime.(*scavChunkData).free
runtime.(*scavChunkData).free -> go:string."runtime: inUse="
runtime.(*scavChunkData).free -> go:string." npages="
runtime.(*scavChunkData).free -> go:string."allocated pages below zero?"
runtime.(*pageAlloc).update -> runtime.(*pallocBits).summarize
runtime.(*pageAlloc).update -> runtime.memclrNoHeapPointers
runtime.(*pageAlloc).update -> runtime.levelShift
runtime.(*pageAlloc).update -> runtime.levelBits
runtime.(*pageAlloc).update -> runtime.levelLogPages
runtime.(*pageAlloc).update -> runtime.mergeSummaries
runtime.(*pageAlloc).update -> runtime.panicSliceBU
runtime.(*pageAlloc).update -> runtime.panicSliceAcapU
runtime.(*pageAlloc).update -> runtime.(*pageAlloc).update.arginfo1
runtime.(*pageAlloc).update -> runtime.greyobject.argliveinfo
runtime.mergeSummaries -> fmt.getField.arginfo1
runtime.mProf_Free -> runtime.mProfCycle
runtime.mProf_Free -> runtime.(*bucket).mp
runtime.mProf_Free -> runtime.profMemFutureLock
runtime.mProf_Free -> gclocals·ShrCR2lbrdPvyLG+AuFYmA==
runtime.(*bucket).mp -> go:string."bad use of bucket.mp"
runtime.tracefree -> runtime.tracelock
runtime.tracefree -> go:string."tracefree("
runtime.tracefree -> runtime.printpointer
runtime.tracefree -> runtime.tracefree.func1
runtime.tracefree -> gclocals·xLu7nOCLuZ/wbIJfpC7bcw==
runtime.tracefree -> runtime.tracealloc.stkobj
runtime.(*spanSet).push -> runtime.(*atomicHeadTailIndex).incTail
runtime.(*spanSet).push -> internal/cpu.CacheLineSize
runtime.(*spanSet).push -> runtime.spanSetBlockPool
runtime.(*spanSet).push -> runtime.(*spanSetBlockAlloc).alloc
runtime.(*spanSet).push -> gclocals·SLvAPFZ8AkbNhIX9KX7YiQ==
runtime.(*spanSet).push -> gclocals·k+SiwGqpCepLJxkbMgNwhQ==
runtime.(*atomicHeadTailIndex).incTail -> go:string."runtime: head = "
runtime.(*atomicHeadTailIndex).incTail -> go:string.", tail = "
runtime.(*atomicHeadTailIndex).incTail -> go:string."headTailIndex overflow"
runtime.(*sysMemStat).add -> go:string."runtime: val="
runtime.(*sysMemStat).add -> go:string." n="
runtime.(*sysMemStat).add -> go:string."sysMemStat overflow"
runtime.(*consistentHeapStats).acquire -> go:string."runtime: seq="
runtime.(*consistentHeapStats).acquire -> go:string."bad sequence number"
runtime.pageTraceFree -> gclocals·Plqv2ff52JtlYaDd2Rwxbg==
runtime.panicdivide -> go:string."integer divide by zero"
runtime.panicdivide -> runtime.panicCheck2
runtime.panicdivide -> runtime.divideError
runtime.panicdivide -> runtime.gopanic
runtime.gopanic -> type:*runtime.PanicNilError <UsedInIface>
runtime.gopanic -> runtime.zerobase
runtime.gopanic -> runtime.panicnil
runtime.gopanic -> runtime.(*godebugInc).IncNonDefault
runtime.gopanic -> runtime.runningPanicDefers
runtime.gopanic -> runtime.addOneOpenDeferFrame
runtime.gopanic -> runtime.gcWriteBarrier1
runtime.gopanic -> runtime.freedefer
runtime.gopanic -> runtime.runOpenDeferFrame
runtime.gopanic -> runtime.getargp
runtime.gopanic -> runtime.preprintpanics
runtime.gopanic -> runtime.fatalpanic
runtime.gopanic -> runtime.recovery·f
runtime.gopanic -> go:string."recovery failed"
runtime.gopanic -> go:string."bypassed recovery failed"
runtime.gopanic -> go:string."bad defer entry in panic"
runtime.gopanic -> go:string."panic: "
runtime.gopanic -> runtime.printany
runtime.gopanic -> go:string."panic holding locks"
runtime.gopanic -> go:string."preempt off reason: "
runtime.gopanic -> go:string."panic during preemptoff"
runtime.gopanic -> go:string."panic during malloc"
runtime.gopanic -> go:string."panic on system stack"
runtime.gopanic -> gclocals·dat41rfjNRJnmnOJniNcdQ==
runtime.gopanic -> gclocals·ig6n+W1V00WB0EK2wePgtA==
runtime.gopanic -> runtime.Goexit.stkobj
runtime.printany -> type:string <UsedInIface>
runtime.printany -> type:int16
runtime.printany -> type:int8
runtime.printany -> type:uintptr
runtime.printany -> type:uint
runtime.printany -> type:int32
runtime.printany -> type:complex128
runtime.printany -> runtime.printcomplex
runtime.printany -> type:float32
runtime.printany -> runtime.printfloat
runtime.printany -> type:uint64
runtime.printany -> type:float64
runtime.printany -> type:uint8
runtime.printany -> type:int64
runtime.printany -> type:bool
runtime.printany -> type:complex64
runtime.printany -> type:int
runtime.printany -> type:uint16
runtime.printany -> type:uint32
runtime.printany -> runtime.printanycustomtype
runtime.printanycustomtype -> runtime.rtype.string
runtime.printanycustomtype -> runtime.printanycustomtype.jump5
runtime.printanycustomtype -> go:string.")"
runtime.printanycustomtype -> go:string."(\""
runtime.printanycustomtype -> go:string."\")"
runtime.printanycustomtype -> go:string.") "
runtime.printanycustomtype -> gclocals·Igs2C5HwiksxpPLJ0dyi2A==
runtime.printanycustomtype -> gclocals·B72P1YhBbohKkFFbE6vbpQ==
runtime.printanycustomtype -> reflect.TypeOf.stkobj
runtime.freedefer -> runtime.freedeferpanic
runtime.freedefer -> runtime.freedeferfn
runtime.freedefer -> type:runtime._defer
runtime.freedefer -> runtime.wbZero
runtime.freedefer -> type:*runtime._defer
runtime.freedefer -> runtime.growslice
runtime.freedefer -> runtime.gcWriteBarrier4
runtime.freedefer -> gclocals·fr4jaRQKcgXsBcUXSEHEyg==
runtime.freedefer -> gclocals·SVSplcl1PypF9kJBFSGnrw==
runtime.wbZero -> runtime.bulkBarrierPreWrite
runtime.bulkBarrierPreWrite -> runtime.modulesSlice
runtime.bulkBarrierPreWrite -> runtime.heapBitsForAddr
runtime.bulkBarrierPreWrite -> runtime.heapBits.next
runtime.bulkBarrierPreWrite -> runtime.wbBufFlush
runtime.bulkBarrierPreWrite -> runtime.bulkBarrierBitmap
runtime.bulkBarrierPreWrite -> go:string."bulkBarrierPreWrite: unaligned arguments"
runtime.bulkBarrierPreWrite -> gclocals·D1/YcbyNumM1nqYyoY4wEQ==
runtime.bulkBarrierPreWrite -> gclocals·r15SxNwAVsvfnmWz8xzcSQ==
runtime.heapBits.next -> runtime.heapBits.next.arginfo1
runtime.bulkBarrierBitmap -> gclocals·Q/wGlK8YQUDaNOijjAVx7Q==
runtime.bulkBarrierBitmap -> gclocals·t4gzOUwoWgW6+GIrjTfRAg==
runtime.bulkBarrierBitmap -> fmt.(*ss).scanNumber.argliveinfo
runtime.wbBufFlush -> runtime.wbBufFlush.func1·f
runtime.freedeferpanic -> go:string."freedefer with d._panic != nil"
runtime.freedeferfn -> go:string."freedefer with d.fn != nil"
runtime.preprintpanics -> runtime.preprintpanics.func1·f
runtime.preprintpanics -> type:error
runtime.preprintpanics -> runtime.assertE2I2
runtime.preprintpanics -> runtime.convTstring
runtime.preprintpanics -> type:runtime.stringer
runtime.preprintpanics -> runtime.preprintpanics.func1
runtime.preprintpanics -> runtime.deferreturn
runtime.preprintpanics -> gclocals·8cC3q7ETfLVC+gt5Tw4C8g==
runtime.preprintpanics -> runtime.preprintpanics.opendefer
runtime.convTstring -> runtime.zeroVal
runtime.convTstring -> runtime.stringType
runtime.convTstring -> runtime.mallocgc
runtime.assertE2I2 -> runtime.getitab
runtime.assertE2I2 -> gclocals·tVhvz7HlUKBn8J23aTqunQ==
runtime.assertE2I2 -> fmt.(*fmt).padString.arginfo1
runtime.getitab -> runtime.itabTable
runtime.getitab -> runtime.(*itabTableType).find
runtime.getitab -> runtime.itabLock
runtime.getitab -> runtime.(*itab).init
runtime.getitab -> runtime.itabAdd
runtime.getitab -> type:runtime.TypeAssertionError
runtime.getitab -> runtime.newobject
runtime.getitab -> type:*runtime.TypeAssertionError <UsedInIface>
runtime.getitab -> runtime.resolveNameOff
runtime.getitab -> internal/abi.Name.Name
runtime.getitab -> go:string."internal error - misuse of itab"
runtime.getitab -> gclocals·FdT8tniwBnd/DBNK3LnSfQ==
runtime.getitab -> gclocals·sOJycR3oTON9qE9oB9S+Zw==
internal/abi.Name.Name -> runtime.panicunsafestringlen
internal/abi.Name.Name -> runtime.panicunsafestringnilptr
internal/abi.Name.Name -> runtime.panicshift
internal/abi.Name.Name -> reflect.pkgPath.arginfo1
internal/abi.Name.Name -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
 -> go:info.internal/abi.Name
 -> go:info.internal/abi.Name.ReadVarint$abstract
 -> go:info.internal/abi.Name.DataChecked$abstract
 -> go:info.internal/abi.addChecked$abstract
 -> go:info.internal/abi.unsafeStringFor$abstract
runtime.(*itabTableType).find -> gclocals·LlfHo70um+DIUn9rjx/QUA==
runtime.itabAdd -> runtime.(*itabTableType).add-fm
runtime.itabAdd -> runtime.iterate_itabs
runtime.itabAdd -> runtime.atomicwb
runtime.itabAdd -> runtime.(*itabTableType).add
runtime.itabAdd -> go:string."mismatched count during itab table copy"
runtime.itabAdd -> go:string."malloc deadlock"
runtime.itabAdd -> gclocals·/bvt/NUArSy5Ovz9nmw5Kw==
runtime.(*itab).init -> runtime.(*itab).init.jump7
runtime.(*itab).init -> runtime.resolveTypeOff
runtime.(*itab).init -> runtime.pkgPath
runtime.(*itab).init -> runtime.rtype.textOff
runtime.(*itab).init -> runtime.panicSlice3Alen
runtime.(*itab).init -> gclocals·04UG2v/q4E6o5X4slZgg5w==
runtime.(*itab).init -> gclocals·DKFlLQRrOJFyKHHYAWxdng==
runtime.mallocgc -> runtime.inittrace
runtime.mallocgc -> runtime.deductAssistCredit
runtime.mallocgc -> runtime.mcache0
runtime.mallocgc -> runtime.(*mcache).nextFree
runtime.mallocgc -> runtime.size_to_class8
runtime.mallocgc -> runtime.size_to_class128
runtime.mallocgc -> runtime.class_to_size
runtime.mallocgc -> runtime.(*mcache).allocLarge
runtime.mallocgc -> runtime.heapBitsSetType
runtime.mallocgc -> runtime.publicationBarrier
runtime.mallocgc -> runtime.gcmarknewobject
runtime.mallocgc -> runtime.MemProfileRate
runtime.mallocgc -> runtime.profilealloc
runtime.mallocgc -> runtime.memclrNoHeapPointersChunked
runtime.mallocgc -> runtime.tracealloc
runtime.mallocgc -> runtime.gcTrigger.test
runtime.mallocgc -> runtime.gcStart
runtime.mallocgc -> go:string."delayed zeroing on data that may contain pointers"
runtime.mallocgc -> go:string."mallocgc called without a P or outside bootstrapping"
runtime.mallocgc -> go:string."malloc during signal"
runtime.mallocgc -> go:string."mallocgc called with gcphase == _GCmarktermination"
runtime.mallocgc -> gclocals·djiTv9C4bjkQzNH7Df7dOQ==
runtime.mallocgc -> gclocals·35svmEu0f+gRKkP76bJrKw==
runtime.(*mcache).nextFree -> runtime.(*mspan).nextFreeIndex
runtime.(*mcache).nextFree -> runtime.(*mcache).refill
runtime.(*mcache).nextFree -> go:string."s.allocCount= "
runtime.(*mcache).nextFree -> go:string." s.nelems= "
runtime.(*mcache).nextFree -> go:string."s.allocCount > s.nelems"
runtime.(*mcache).nextFree -> go:string."freeIndex is not valid"
runtime.(*mcache).nextFree -> go:string."runtime: s.allocCount= "
runtime.(*mcache).nextFree -> go:string."s.allocCount != s.nelems && freeIndex == s.nelems"
runtime.deductAssistCredit -> runtime.gcAssistAlloc
runtime.deductAssistCredit -> gclocals·5aa34RaZcmo0NkRpBHp2fg==
runtime.memclrNoHeapPointersChunked -> runtime.goschedguarded_m·f
runtime.profilealloc -> runtime.fastexprand
runtime.profilealloc -> runtime.mProf_Malloc
runtime.profilealloc -> go:string."profilealloc called without a P or outside bootstrapping"
runtime.profilealloc -> gclocals·jZtJ1ccH9bAYoe1wqsw9Mw==
runtime.fastexprand -> runtime.fastlog2Table
runtime.fastexprand -> $f64.3eb0000000000000
runtime.fastexprand -> $f64.403a000000000000
runtime.fastexprand -> $f64.bfe62e42fefa39ef
runtime.(*mspan).nextFreeIndex -> go:string."s.freeindex > s.nelems"
runtime.heapBitsSetType -> runtime.writeHeapBits.write
runtime.heapBitsSetType -> runtime.runGCProg
runtime.heapBitsSetType -> runtime.writeHeapBits.pad
runtime.heapBitsSetType -> runtime.writeHeapBits.flush
runtime.heapBitsSetType -> gclocals·yTe0zb6kN8F0C2NwyoBI1A==
runtime.heapBitsSetType -> gclocals·LYCDKuuTrZyMasYTuDPtVQ==
runtime.writeHeapBits.write -> runtime.writeHeapBits.write.arginfo1
runtime.writeHeapBits.pad -> runtime.writeHeapBits.pad.arginfo1
runtime.(*mcache).refill -> runtime.(*mcentral).cacheSpan
runtime.(*mcache).refill -> go:string."span has no free space"
runtime.(*mcache).refill -> go:string."out of memory"
runtime.(*mcache).refill -> go:string."bad sweepgen in refill"
runtime.(*mcache).refill -> go:string."refill of span with free space remaining"
runtime.(*mcache).allocLarge -> runtime.deductSweepCredit
runtime.(*mcache).allocLarge -> runtime.(*mheap).alloc
runtime.(*mcache).allocLarge -> runtime.(*mspan).initHeapBits
runtime.(*mcentral).cacheSpan -> runtime.class_to_allocnpages
runtime.(*mcentral).cacheSpan -> runtime.traceGCSweepStart
runtime.(*mcentral).cacheSpan -> runtime.(*spanSet).pop
runtime.(*mcentral).cacheSpan -> runtime.traceGCSweepDone
runtime.(*mcentral).cacheSpan -> go:string."span has no free objects"
runtime.(*mcentral).cacheSpan -> runtime.sweep
runtime.(*mcentral).cacheSpan -> runtime.(*sweepLocker).tryAcquire
runtime.(*mcentral).cacheSpan -> runtime.(*activeSweep).end
runtime.(*mcentral).cacheSpan -> runtime.(*mcentral).grow
runtime.gcTrigger.test -> runtime.forcegcperiod
runtime.gcTrigger.test -> runtime.work
runtime.gcTrigger.test -> runtime.(*gcControllerState).trigger
runtime.gcTrigger.test -> runtime.gcTrigger.test.arginfo1
runtime.gcStart -> runtime.sweepone
runtime.gcStart -> runtime.semacquire1
runtime.gcStart -> runtime.gcsema
runtime.gcStart -> runtime.worldsema
runtime.gcStart -> runtime.semrelease1
runtime.gcStart -> runtime.gcBgMarkStartWorkers
runtime.gcStart -> runtime.gcResetMarkState·f
runtime.gcStart -> runtime.stopTheWorldWithSema·f
runtime.gcStart -> runtime.gcStart.func1·f
runtime.gcStart -> runtime.clearpools
runtime.gcStart -> runtime.(*gcControllerState).startCycle
runtime.gcStart -> runtime.gcCPULimiter
runtime.gcStart -> runtime.(*gcCPULimiterState).startGCTransition
runtime.gcStart -> runtime.schedEnableUser
runtime.gcStart -> runtime.gcMarkRootPrepare
runtime.gcStart -> runtime.gcMarkTinyAllocs
runtime.gcStart -> runtime.gcStart.func2
runtime.gcStart -> go:string."runtime: p "
runtime.gcStart -> go:string." flushGen "
runtime.gcStart -> go:string." != sweepgen "
runtime.gcStart -> go:string."p mcache not flushed"
runtime.gcStart -> gclocals·Zzj2FaoDzNrZlobEaq+Nzw==
runtime.gcStart.func2 -> runtime.startTheWorldWithSema
runtime.gcStart.func2 -> runtime.(*gcCPULimiterState).finishGCTransition
runtime.gcBgMarkStartWorkers -> runtime.gcBgMarkWorker·f
runtime.gcBgMarkStartWorkers -> runtime.newproc
runtime.gcBgMarkStartWorkers -> runtime.notetsleepg
runtime.gcBgMarkStartWorkers -> runtime.gcBgMarkWorkerCount
runtime.notetsleepg -> runtime.entersyscallblock
runtime.notetsleepg -> runtime.notetsleep_internal
runtime.notetsleepg -> go:string."notetsleepg on g0"
runtime.notetsleep_internal -> runtime.cgo_yield
runtime.notetsleep_internal -> go:string."notetsleep - waitm out of sync"
runtime.notetsleep_internal -> go:string."runtime: unable to acquire - semaphore out of sync"
runtime.notetsleep_internal -> go:string."runtime: unexpected waitm - semaphore out of sync"
runtime.notetsleep_internal -> gclocals·ON0GJsy59DJykMbMbaDfLg==
runtime.notetsleep_internal -> gclocals·o+PfnuBVWMA9paH+BG0A1w==
runtime.notetsleep_internal -> runtime.debugCallWrap.func1.stkobj
runtime.clearpools -> runtime.poolcleanup
runtime.clearpools -> runtime.boringCaches
runtime.(*gcCPULimiterState).startGCTransition -> runtime.(*gcCPULimiterState).updateLocked
runtime.(*gcCPULimiterState).startGCTransition -> go:string."transitioning GC to the same state as before?"
runtime.(*gcCPULimiterState).startGCTransition -> go:string."failed to acquire lock to start a GC transition"
runtime.(*gcCPULimiterState).startGCTransition -> fmt.(*ss).Token.arginfo1
runtime.(*gcCPULimiterState).finishGCTransition -> runtime.(*gcCPULimiterState).accumulate
runtime.(*gcCPULimiterState).finishGCTransition -> runtime.(*gcCPULimiterState).unlock
runtime.(*gcCPULimiterState).finishGCTransition -> go:string."finishGCTransition called without starting one?"
runtime.(*gcCPULimiterState).updateLocked -> $f64.3fd0000000000000
runtime.(*gcCPULimiterState).updateLocked -> runtime.(*limiterEvent).consume
runtime.(*gcCPULimiterState).updateLocked -> go:string."invalid limiter event type found"
runtime.(*gcCPULimiterState).updateLocked -> gclocals·Dgf1f3AVIaLB1FeVKvxDYQ==
runtime.(*gcCPULimiterState).updateLocked -> gclocals·CFG3to7kccxvuTqmYI0PLA==
runtime.(*gcCPULimiterState).unlock -> go:string."double unlock"
runtime.gcAssistAlloc -> $f64.40f0000000000000
runtime.gcAssistAlloc -> runtime.gcAssistAlloc.func1
runtime.gcAssistAlloc -> runtime.gcMarkDone
runtime.gcAssistAlloc -> runtime.gcParkAssist
runtime.gcMarkDone -> runtime.gcMarkDone.func3·f
runtime.gcMarkDone -> runtime.gcMarkDoneFlushed
runtime.gcMarkDone -> runtime.gcMarkDone.func1·f
runtime.gcMarkDone -> go:string."gcing"
runtime.gcMarkDone -> runtime.gcMarkDone.func2
runtime.gcMarkDone -> runtime.gcComputeStartingStackSize
runtime.gcMarkDone -> runtime.gcWakeAllAssists
runtime.gcMarkDone -> runtime.(*gcControllerState).endCycle
runtime.gcMarkDone -> runtime.gcMarkTermination
runtime.gcMarkDone -> gclocals·EaPwxsZ75yY1hHMVZLmk6g==
runtime.gcMarkDone.func2 -> runtime.wbBufFlush1
runtime.gcMarkDone.func2 -> gclocals·k/vI9CsIAsSPBngFxBbT3g==
runtime.gcMarkTermination -> runtime.gcMarkTermination.func1
runtime.gcMarkTermination -> runtime.gcMarkTermination.func2·f
runtime.gcMarkTermination -> runtime.gcControllerCommit·f
runtime.gcMarkTermination -> time.now
runtime.gcMarkTermination -> runtime.scavenge
runtime.gcMarkTermination -> runtime.injectglist
runtime.gcMarkTermination -> runtime.(*scavengeIndex).nextGen
runtime.gcMarkTermination -> runtime.gcMarkTermination.func3·f
runtime.gcMarkTermination -> runtime.mProf_Flush
runtime.gcMarkTermination -> runtime.prepareFreeWorkbufs
runtime.gcMarkTermination -> runtime.freeStackSpans·f
runtime.gcMarkTermination -> runtime.gcMarkTermination.func4·f
runtime.gcMarkTermination -> runtime.runtimeInitTime
runtime.gcMarkTermination -> runtime.slicebytetostring
runtime.gcMarkTermination -> go:string."gc "
runtime.gcMarkTermination -> go:string." @"
runtime.gcMarkTermination -> go:string."s "
runtime.gcMarkTermination -> go:string."%: "
runtime.gcMarkTermination -> runtime.fmtNSAsMS
runtime.gcMarkTermination -> go:string." ms clock, "
runtime.gcMarkTermination -> go:string." ms cpu, "
runtime.gcMarkTermination -> go:string."->"
runtime.gcMarkTermination -> go:string." MB, "
runtime.gcMarkTermination -> go:string." MB goal, "
runtime.gcMarkTermination -> go:string." MB stacks, "
runtime.gcMarkTermination -> go:string." MB globals, "
runtime.gcMarkTermination -> go:string." P"
runtime.gcMarkTermination -> go:string." (forced)"
runtime.gcMarkTermination -> runtime.userArenaState
runtime.gcMarkTermination -> runtime.(*mspan).setUserArenaChunkToFault
runtime.gcMarkTermination -> runtime.(*mheap).enableMetadataHugePages
runtime.gcMarkTermination -> go:string."failed to set sweep barrier"
runtime.gcMarkTermination -> go:string."gc done but gcphase != _GCoff"
runtime.gcMarkTermination -> gclocals·3CgL1OMj4PK20UKKkS8Bfw==
runtime.gcMarkTermination -> gclocals·1CrN+7j9I2cpnpqJCdgTMQ==
runtime.(*mspan).setUserArenaChunkToFault -> runtime.(*mspan).setUserArenaChunkToFault.func1
runtime.(*mspan).setUserArenaChunkToFault -> go:string."span on userArena.faultList has invalid size"
runtime.(*mspan).setUserArenaChunkToFault -> go:string."invalid span in heapArena for user arena"
runtime.(*mheap).enableMetadataHugePages -> runtime.(*pageAlloc).enableChunkHugePages
runtime.gcMarkTermination.func1 -> runtime.gcMark
runtime.gcMark -> runtime.tracegc
runtime.gcMark -> runtime.gcMarkRootCheck
runtime.gcMark -> runtime.(*gcWork).dispose
runtime.gcMark -> runtime.(*wbBuf).reset
runtime.gcMark -> runtime.(*gcControllerState).resetLive
runtime.gcMark -> go:string."runtime: P "
runtime.gcMark -> go:string." flushedWork "
runtime.gcMark -> go:string." wbuf1.n="
runtime.gcMark -> go:string." wbuf2.n="
runtime.gcMark -> go:string."P has cached GC work at end of mark termination"
runtime.gcMark -> go:string." wbuf2=<nil>"
runtime.gcMark -> go:string." wbuf1=<nil>"
runtime.gcMark -> go:string."runtime: full="
runtime.gcMark -> go:string." next="
runtime.gcMark -> go:string." jobs="
runtime.gcMark -> go:string." nDataRoots="
runtime.gcMark -> go:string." nBSSRoots="
runtime.gcMark -> go:string." nSpanRoots="
runtime.gcMark -> go:string." nStackRoots="
runtime.gcMark -> runtime..stmp_107
runtime.gcMark -> go:string."in gcMark expecting to see gcphase as _GCmarktermination"
runtime.gcMark -> gclocals·bIw6KlaoxkdZsd4DPeZETA==
runtime.gcMarkRootCheck -> runtime.gcMarkRootCheck.func1
runtime.gcMarkRootCheck -> go:string." of "
runtime.gcMarkRootCheck -> go:string." markroot jobs done\n"
runtime.gcMarkRootCheck -> go:string."left over markroot jobs"
runtime.gcMarkRootCheck.func1 -> go:string."gp "
runtime.gcMarkRootCheck.func1 -> go:string." goid "
runtime.gcMarkRootCheck.func1 -> go:string." status "
runtime.gcMarkRootCheck.func1 -> go:string." gcscandone "
runtime.gcMarkRootCheck.func1 -> go:string."scan missed a g"
runtime.gcAssistAlloc.func1 -> runtime.gcAssistAlloc1
runtime.gcAssistAlloc1 -> runtime.gcDrainN
runtime.gcAssistAlloc1 -> runtime.(*limiterEvent).stop
runtime.gcAssistAlloc1 -> runtime.(*gcCPULimiterState).update
runtime.gcAssistAlloc1 -> go:string."runtime: work.nwait= "
runtime.gcAssistAlloc1 -> go:string." work.nproc= "
runtime.gcAssistAlloc1 -> go:string."work.nwait > work.nproc"
runtime.gcAssistAlloc1 -> go:string."runtime: work.nwait = "
runtime.gcAssistAlloc1 -> go:string."nwait > work.nprocs"
runtime.(*gcCPULimiterState).update -> go:string."update during transition"
runtime.(*limiterEvent).stop -> go:string."limiterEvent.stop: invalid limiter event type found"
runtime.(*limiterEvent).stop -> go:string."runtime: want="
runtime.(*limiterEvent).stop -> go:string." got="
runtime.(*limiterEvent).stop -> go:string."limiterEvent.stop: found wrong event in p's limiter event slot"
runtime.gcParkAssist -> runtime.parkunlock_c·f
runtime.gcParkAssist -> runtime.gopark
runtime.gcDrainN -> runtime.(*gcWork).balance
runtime.gcDrainN -> runtime.(*gcWork).tryGet
runtime.gcDrainN -> runtime.markroot
runtime.gcDrainN -> runtime.scanobject
runtime.gcDrainN -> go:string."gcDrainN phase incorrect"
runtime.markroot -> runtime.markrootSpans
runtime.markroot -> runtime.markroot.func1
runtime.markroot -> runtime.markrootFreeGStacks·f
runtime.markroot -> runtime.gcFlushBgCredit
runtime.markroot -> go:string."runtime: markroot index "
runtime.markroot -> go:string." not in stack roots range ["
runtime.markroot -> go:string."markroot: bad index"
runtime.markroot -> runtime.scanblock
runtime.markroot -> runtime.markrootBlock
runtime.markroot -> gclocals·hzjE3pRPxdo3Z5Q7iXq5KA==
runtime.markroot -> gclocals·20IAxi6Ve9TOiwRgy9ovWg==
runtime.markroot -> runtime.markroot.arginfo1
runtime.markroot.func1 -> runtime.suspendG
runtime.markroot.func1 -> runtime.scanstack
runtime.markroot.func1 -> runtime.resumeG
runtime.markroot.func1 -> go:string."g already scanned"
runtime.markroot.func1 -> gclocals·nXdSMUDjLs4WFNDqN/QgEQ==
runtime.markrootBlock -> gclocals·mqHoWZvKAXuwHrMHlI6RAw==
runtime.markrootSpans -> runtime.useCheckmark
runtime.markrootSpans -> runtime.oneptrmask
runtime.markrootSpans -> go:string."sweep "
runtime.markrootSpans -> go:string."gc: unswept span"
runtime.markrootSpans -> go:string."s.state = "
runtime.markrootSpans -> go:string."non in-use span found with specials bit set"
runtime.markrootSpans -> gclocals·0Xx9cqNn7i98TMy5xdHpTg==
runtime.gcFlushBgCredit -> runtime.ready
runtime.scanstack -> runtime.shrinkstack
runtime.scanstack -> go:string."runtime: gp="
runtime.scanstack -> go:string.", goid="
runtime.scanstack -> go:string.", gp->atomicstatus="
runtime.scanstack -> go:string."mark - bad status"
runtime.scanstack -> runtime.scanframeworker
runtime.scanstack -> runtime.(*stackScanState).putPtr
runtime.scanstack -> runtime.binarySearchTree
runtime.scanstack -> runtime.(*stackScanState).getPtr
runtime.scanstack -> runtime.putempty
runtime.scanstack -> go:string."remaining pointer buffers"
runtime.scanstack -> runtime.materializeGCProg
runtime.scanstack -> runtime.scanConservative
runtime.scanstack -> runtime.(*mheap).freeManual
runtime.scanstack -> go:string."can't scan our own stack"
runtime.scanstack -> go:string."scanstack: goroutine not stopped"
runtime.scanstack -> go:string."runtime:scanstack: gp="
runtime.scanstack -> go:string."scanstack - bad status"
runtime.scanstack -> gclocals·pbCous7nhhnDDRJWOdIDZg==
runtime.scanstack -> gclocals·dC6cqGwRmVNuIvavyh8xew==
runtime.materializeGCProg -> runtime.(*mheap).allocManual
runtime.scanframeworker -> runtime.(*stkframe).getStackMap
runtime.scanframeworker -> runtime.(*stkframe).argBytes
runtime.scanframeworker -> runtime.(*stackScanState).addObject
runtime.scanframeworker -> gclocals·sFnfaMTueBYv/9kpbspCtw==
runtime.scanframeworker -> gclocals·tOJLXbOPIuGh0vwKlFeoKg==
runtime.scanblock -> runtime.findObject
runtime.scanblock -> runtime.greyobject
runtime.scanblock -> gclocals·Uc6mAJka080ixXvqhn/0LQ==
runtime.scanblock -> runtime.scanblock.argliveinfo
runtime.findObject -> runtime.badPointer
runtime.badPointer -> go:string."runtime: pointer "
runtime.badPointer -> go:string." to unallocated span"
runtime.badPointer -> go:string." span.base()="
runtime.badPointer -> go:string." span.limit="
runtime.badPointer -> go:string." span.state="
runtime.badPointer -> go:string."found bad pointer in Go heap (incorrect use of unsafe or cgo?)"
runtime.badPointer -> go:string."runtime: found in object at *("
runtime.badPointer -> go:string."object"
runtime.badPointer -> runtime.gcDumpObject
runtime.badPointer -> go:string." to unused region of span"
runtime.scanobject -> runtime.(*gcWork).put
runtime.scanobject -> go:string."scanobject of a noscan object"
runtime.scanobject -> go:string."scanobject n == 0"
runtime.scanConservative -> runtime.spanOfHeap
runtime.scanConservative -> go:string."misaligned mask"
runtime.greyobject -> runtime.setCheckmark
runtime.greyobject -> go:string."runtime: marking free object "
runtime.greyobject -> go:string." found at *("
runtime.greyobject -> go:string."base"
runtime.greyobject -> go:string."obj"
runtime.greyobject -> go:string."marking free object"
runtime.greyobject -> go:string."greyobject: obj not pointer-aligned"
runtime.setCheckmark -> go:string."runtime: checkmarks found unexpected unmarked object obj="
runtime.setCheckmark -> go:string."runtime: found obj at *("
runtime.setCheckmark -> go:string."checkmark found unmarked object"
runtime.setCheckmark -> runtime.setCheckmark.arginfo1
runtime.gcDumpObject -> go:string."="
runtime.gcDumpObject -> go:string." s.base()="
runtime.gcDumpObject -> go:string." s.limit="
runtime.gcDumpObject -> go:string." s.spanclass="
runtime.gcDumpObject -> go:string." s.elemsize="
runtime.gcDumpObject -> go:string." s.state="
runtime.gcDumpObject -> runtime.mSpanStateNames
runtime.gcDumpObject -> go:string."unknown("
runtime.gcDumpObject -> go:string." s=nil\n"
runtime.gcDumpObject -> go:string." ...\n"
runtime.gcDumpObject -> go:string." *("
runtime.gcDumpObject -> go:string.") = "
runtime.gcDumpObject -> go:string." <=="
runtime.gcmarknewobject -> go:string."gcmarknewobject called while doing checkmark"
runtime.gcMarkTinyAllocs -> gclocals·9BzPawcR5gdcmAdFP/oo1A==
runtime.(*gcControllerState).startCycle -> $f64.3fe0000000000000
runtime.(*gcControllerState).startCycle -> $f64.bfd3333333333333
runtime.(*gcControllerState).startCycle -> $f64.3fd3333333333333
runtime.(*gcControllerState).startCycle -> runtime.(*gcControllerState).setMaxIdleMarkWorkers
runtime.(*gcControllerState).startCycle -> go:string."pacer: assist ratio="
runtime.(*gcControllerState).startCycle -> go:string." (scan "
runtime.(*gcControllerState).startCycle -> go:string." MB in "
runtime.(*gcControllerState).startCycle -> go:string." MB) workers="
runtime.(*gcControllerState).startCycle -> runtime.(*gcControllerState).startCycle.arginfo1
runtime.(*gcControllerState).endCycle -> go:string."pacer: "
runtime.(*gcControllerState).endCycle -> go:string."% CPU ("
runtime.(*gcControllerState).endCycle -> go:string." exp.) for "
runtime.(*gcControllerState).endCycle -> go:string." B work ("
runtime.(*gcControllerState).endCycle -> go:string." B exp.) "
runtime.(*gcControllerState).endCycle -> go:string."in "
runtime.(*gcControllerState).endCycle -> go:string." B -> "
runtime.(*gcControllerState).endCycle -> go:string." B (∆goal "
runtime.(*gcControllerState).endCycle -> go:string.", cons/mark "
runtime.(*gcControllerState).endCycle -> runtime.(*mheap).sysAlloc.arginfo1
runtime.(*gcControllerState).trigger -> go:string."trigger="
runtime.(*gcControllerState).trigger -> go:string." heapGoal="
runtime.(*gcControllerState).trigger -> go:string."minTrigger="
runtime.(*gcControllerState).trigger -> go:string." maxTrigger="
runtime.(*gcControllerState).trigger -> go:string."produced a trigger greater than the heap goal"
runtime.(*gcControllerState).setMaxIdleMarkWorkers -> go:string."n="
runtime.(*gcControllerState).setMaxIdleMarkWorkers -> go:string." max="
runtime.(*gcControllerState).setMaxIdleMarkWorkers -> go:string."negative idle mark workers"
runtime.(*scavengeIndex).nextGen -> runtime.minOffAddr
runtime.(*stackScanState).putPtr -> runtime.getempty
runtime.(*stackScanState).putPtr -> go:string."address not a stack address"
runtime.(*stackScanState).getPtr -> gclocals·wTWjeoDn9+lGHgupXRaYHg==
runtime.(*stackScanState).getPtr -> runtime.setenv_c.stkobj
runtime.(*stackScanState).addObject -> go:string."objects added out of order or overlapping"
runtime.(*stackScanState).addObject -> gclocals·iilYh2zWk/RieCMyRG2Y4w==
runtime.(*activeSweep).end -> go:string."pacer: sweep done at heap size "
runtime.(*activeSweep).end -> go:string."MB; allocated "
runtime.(*activeSweep).end -> go:string."MB during sweep; swept "
runtime.(*activeSweep).end -> go:string." pages at "
runtime.(*activeSweep).end -> go:string." pages/byte\n"
runtime.(*activeSweep).end -> go:string."mismatched begin/end of activeSweep"
runtime.(*activeSweep).end -> go:string."sweeper left outstanding across sweep generations"
runtime.(*activeSweep).end -> runtime.(*activeSweep).end.arginfo1
runtime.(*sweepLocker).tryAcquire -> go:string."use of invalid sweepLocker"
runtime.sweepone -> runtime.(*mheap).nextSpanForSweep
runtime.sweepone -> runtime.sweepone.func1·f
runtime.sweepone -> runtime.scavenger
runtime.sweepone -> go:string."runtime: bad span s.state="
runtime.sweepone -> go:string." s.sweepgen="
runtime.sweepone -> go:string."non in-use span in unswept list"
runtime.(*gcWork).put -> runtime.putfull
runtime.(*gcWork).put -> runtime.(*gcWork).init
runtime.(*gcWork).put -> runtime.(*gcControllerState).enlistWorker
runtime.(*gcWork).init -> runtime.trygetfull
runtime.(*gcWork).balance -> runtime.handoff
runtime.getempty -> runtime.getempty.func1
runtime.getempty -> runtime.lfnodeValidate
runtime.getempty -> runtime.(*workbuf).checkempty
runtime.lfnodeValidate -> go:string."runtime: bad lfnode address "
runtime.lfnodeValidate -> go:string."bad lfnode address"
runtime.lfnodeValidate -> go:string."lfstack node allocated from the heap"
runtime.(*workbuf).checkempty -> go:string."workbuf is not empty"
runtime.putempty -> runtime.(*lfstack).push
runtime.(*lfstack).push -> go:string."runtime: lfstack.push invalid packing: node="
runtime.(*lfstack).push -> go:string." cnt="
runtime.(*lfstack).push -> go:string." packed="
runtime.(*lfstack).push -> go:string." -> node="
runtime.(*lfstack).push -> go:string."lfstack.push"
runtime.(*lfstack).push -> gclocals·XuwES5/hudXo+IvuobmkCQ==
runtime.(*lfstack).push -> gclocals·KPvG3XfAPUbWf5fguWSJfg==
runtime.putfull -> runtime.(*workbuf).checknonempty
runtime.(*workbuf).checknonempty -> go:string."workbuf is empty"
runtime.prepareFreeWorkbufs -> go:string."cannot free workbufs when work.full != 0"
runtime.(*mheap).alloc -> runtime.(*mheap).alloc.func1
runtime.(*mheap).alloc -> runtime.(*mheap).alloc.stkobj
runtime.(*mheap).alloc.func1 -> runtime.(*mheap).reclaim
runtime.(*mheap).alloc.func1 -> runtime.(*mheap).allocSpan
runtime.(*mheap).reclaim -> runtime.(*mheap).reclaimChunk
runtime.(*mheap).reclaim -> gclocals·2sk7fod/r4Un2Ul5+9OEqg==
runtime.(*mheap).reclaimChunk -> gclocals·ziQaagcY0HZce2pjE6AckA==
runtime.(*mheap).reclaimChunk -> gclocals·gTR7/E6GSE2LT9YNQJUtLw==
runtime.(*mheap).reclaimChunk -> runtime.(*mheap).reclaimChunk.arginfo1
runtime.(*mheap).reclaimChunk -> runtime.(*mheap).reclaimChunk.argliveinfo
runtime.(*mheap).allocManual -> go:string."manual span allocation called with non-manually-managed type"
runtime.(*mheap).allocSpan -> runtime.(*pageAlloc).allocToCache
runtime.(*mheap).allocSpan -> runtime.(*pageCache).alloc
runtime.(*mheap).allocSpan -> runtime.(*pageAlloc).alloc
runtime.(*mheap).allocSpan -> runtime.(*mheap).grow
runtime.(*mheap).allocSpan -> runtime.(*mheap).allocMSpanLocked
runtime.(*mheap).allocSpan -> runtime.(*mheap).allocSpan.func1·f
runtime.(*mheap).allocSpan -> runtime.(*pageAlloc).scavenge
runtime.(*mheap).allocSpan -> runtime.(*mheap).initSpan
runtime.(*mheap).allocSpan -> runtime.sysUsedOS
runtime.(*mheap).allocSpan -> go:string."grew heap, but no adequate free space found"
runtime.(*mheap).allocSpan -> runtime.(*mheap).allocSpan.arginfo1
runtime.sysUsedOS -> go:string."runtime: VirtualAlloc of "
runtime.sysUsedOS -> go:string."runtime: failed to commit pages"
runtime.(*pageAlloc).scavenge -> runtime.(*scavengeIndex).find
runtime.(*pageAlloc).scavenge -> runtime.(*pageAlloc).scavenge.func1
runtime.(*pageAlloc).scavenge -> gclocals·cRnfy3ll8DXPG7zGjyjjXw==
runtime.(*pageAlloc).scavenge -> runtime.(*pageAlloc).scavenge.stkobj
runtime.(*pageAlloc).scavenge.func1 -> runtime.(*pageAlloc).scavengeOne
runtime.(*pageAlloc).scavengeOne -> runtime.physPageSize
runtime.(*pageAlloc).scavengeOne -> runtime.(*pallocData).findScavengeCandidate
runtime.(*pageAlloc).scavengeOne -> runtime.(*pallocData).allocRange
runtime.(*pageAlloc).scavengeOne -> runtime.(*scavengeIndex).setNoHugePage
runtime.(*pageAlloc).scavengeOne -> runtime.(*pageBits).setRange
runtime.(*pageAlloc).scavengeOne -> runtime.(*scavengeIndex).setEmpty
runtime.(*pageAlloc).scavengeOne -> errors.As.argliveinfo
runtime.(*pallocData).findScavengeCandidate -> runtime.fillAligned
runtime.(*pallocData).findScavengeCandidate -> runtime.physHugePageSize
runtime.(*pallocData).findScavengeCandidate -> go:string."runtime: min = "
runtime.(*pallocData).findScavengeCandidate -> go:string."min too large"
runtime.(*pallocData).findScavengeCandidate -> go:string."min must be a non-zero power of 2"
runtime.(*pallocData).findScavengeCandidate -> runtime.(*pallocData).findScavengeCandidate.argliveinfo
runtime.fillAligned -> go:string."bad m value"
runtime.(*mheap).allocMSpanLocked -> runtime.(*fixalloc).alloc
runtime.(*fixalloc).alloc -> go:string."runtime: use of FixAlloc_Alloc before FixAlloc_Init\n"
runtime.(*fixalloc).alloc -> go:string."runtime: internal error"
runtime.(*fixalloc).alloc -> gclocals·dGrMWTWIngKGfVYjHi0adA==
runtime.(*mheap).initSpan -> runtime.(*mheap).allocNeedsZero
runtime.(*mheap).initSpan -> runtime.class_to_divmagic
runtime.(*mheap).initSpan -> runtime.(*mheap).setSpans
runtime.(*mheap).initSpan -> runtime.(*mheap).initSpan.arginfo1
runtime.(*mheap).initSpan -> runtime.(*mheap).initSpan.argliveinfo
runtime.(*mheap).allocNeedsZero -> go:string."potentially overlapping in-use allocations detected"
runtime.(*mheap).grow -> runtime.(*mheap).sysAlloc
runtime.(*mheap).grow -> runtime.(*pageAlloc).grow
runtime.(*mheap).grow -> go:string."runtime: out of memory: cannot allocate "
runtime.(*mheap).grow -> go:string."-byte block ("
runtime.(*mheap).grow -> go:string." in use)\n"
runtime.(*mheap).grow -> gclocals·TDjMiWQCDH1TdVG+c1Z0oQ==
runtime.(*mheap).sysAlloc -> runtime.(*linearAlloc).alloc
runtime.(*mheap).sysAlloc -> go:string."out of memory allocating allArenas"
runtime.(*mheap).sysAlloc -> go:string."out of memory allocating heap arena metadata"
runtime.(*mheap).sysAlloc -> go:string."arena already initialized"
runtime.(*mheap).sysAlloc -> go:string."out of memory allocating heap arena map"
runtime.(*mheap).sysAlloc -> runtime.sysReserveOS
runtime.(*mheap).sysAlloc -> runtime.sysFreeOS
runtime.(*mheap).sysAlloc -> runtime.sysReserveAligned
runtime.(*mheap).sysAlloc -> go:string."region exceeds uintptr range"
runtime.(*mheap).sysAlloc -> go:string."base outside usable address space"
runtime.(*mheap).sysAlloc -> go:string."end outside usable address space"
runtime.(*mheap).sysAlloc -> go:string."misrounded allocation in sysAlloc"
runtime.(*mheap).sysAlloc -> go:string."runtime: memory allocated by OS ["
runtime.(*mheap).sysAlloc -> go:string.") not in usable address space: "
runtime.(*mheap).sysAlloc -> go:string."memory reservation exceeds address space limit"
runtime.(*mheap).sysAlloc -> gclocals·5uneB28vLQ7rHgAFUtUkfQ==
runtime.(*mheap).sysAlloc -> gclocals·leyjSuGjV5hlL849E6nNvQ==
runtime.(*mheap).sysAlloc -> fmt.(*pp).printArg.argliveinfo
runtime.sysReserveAligned -> go:string."failed to allocate aligned heap memory; too many retries"
runtime.(*linearAlloc).alloc -> gclocals·YHpwtXfdZGvGg0cxKddLDA==
runtime.sysFreeOS -> go:string."runtime: failed to release pages"
runtime.(*pageAlloc).grow -> runtime.(*pageAlloc).sysGrow
runtime.(*pageAlloc).grow -> runtime.(*scavengeIndex).grow
runtime.(*pageAlloc).grow -> runtime.makeAddrRange
runtime.(*pageAlloc).grow -> runtime.(*addrRanges).add
runtime.(*pageAlloc).grow -> go:string."pageAlloc: out of memory"
runtime.(*scavengeIndex).grow -> runtime.(*scavengeIndex).sysGrow
runtime.(*scavengeIndex).grow -> gclocals·cNGUyZq94N9QFR70tEjj5A==
runtime.(*pageAlloc).enableChunkHugePages -> runtime.(*addrRanges).cloneInto
runtime.(*pageAlloc).enableChunkHugePages -> runtime.(*pageAlloc).enableChunkHugePages.stkobj
runtime.(*pageAlloc).alloc -> runtime.(*pallocBits).find
runtime.(*pageAlloc).alloc -> runtime.(*pageAlloc).find
runtime.(*pageAlloc).alloc -> runtime.maxOffAddr
runtime.(*pageAlloc).alloc -> runtime.(*pageAlloc).allocRange
runtime.(*pageAlloc).alloc -> go:string."runtime: max = "
runtime.(*pageAlloc).alloc -> go:string.", npages = "
runtime.(*pageAlloc).alloc -> go:string."runtime: searchIdx = "
runtime.(*pageAlloc).alloc -> go:string.", p.searchAddr = "
runtime.(*pageAlloc).alloc -> go:string."bad summary data"
runtime.(*pageAlloc).allocRange -> runtime.(*pageBits).popcntRange
runtime.(*pageAlloc).allocRange -> runtime.(*scavengeIndex).alloc
runtime.(*scavengeIndex).alloc -> runtime.(*scavChunkData).alloc
runtime.(*scavChunkData).alloc -> go:string."too many pages allocated in chunk?"
runtime.(*pageAlloc).find -> runtime.(*pageAlloc).find.func1
runtime.(*pageAlloc).find -> runtime.(*pageAlloc).findMappedAddr
runtime.(*pageAlloc).find -> go:string."runtime: summary["
runtime.(*pageAlloc).find -> go:string."]["
runtime.(*pageAlloc).find -> go:string."] = ("
runtime.(*pageAlloc).find -> go:string."runtime: npages = "
runtime.(*pageAlloc).find -> go:string."] = "
runtime.(*pageAlloc).find -> go:string."runtime: level = "
runtime.(*pageAlloc).find -> go:string.", j0 = "
runtime.(*pageAlloc).find -> go:string."runtime: p.searchAddr = "
runtime.(*pageAlloc).find -> go:string.", i = "
runtime.(*pageAlloc).find -> go:string."runtime: levelShift[level] = "
runtime.(*pageAlloc).find -> go:string.", levelBits[level] = "
runtime.(*pageAlloc).find -> gclocals·SXYRnj4PMMrm4I3Ahd1obw==
runtime.(*pageAlloc).find -> gclocals·FVF61mTB08tE/3lH0rPdHA==
runtime.(*pageAlloc).findMappedAddr -> runtime.(*addrRanges).findAddrGreaterEqual
runtime.(*pageAlloc).findMappedAddr -> os.(*fileWithoutReadFrom).ReadFrom.arginfo1
runtime.(*pageAlloc).find.func1 -> go:string."runtime: addr = "
runtime.(*pageAlloc).find.func1 -> go:string.", size = "
runtime.(*pageAlloc).find.func1 -> go:string."runtime: base = "
runtime.(*pageAlloc).find.func1 -> go:string.", bound = "
runtime.(*pageAlloc).find.func1 -> go:string."range partially overlaps"
runtime.(*pageAlloc).find.func1 -> os.fileWithoutReadFrom.ReadDir.arginfo1
runtime.(*pageAlloc).sysGrow -> runtime.(*pageAlloc).sysGrow.func2
runtime.(*pageAlloc).sysGrow -> runtime.(*pageAlloc).sysGrow.func3
runtime.(*pageAlloc).sysGrow -> runtime.(*pageAlloc).sysGrow.func1·f
runtime.(*pageAlloc).sysGrow -> runtime.(*addrRanges).findSucc
runtime.(*pageAlloc).sysGrow -> runtime.addrRange.subtract
runtime.(*pageAlloc).sysGrow -> go:string.", limit = "
runtime.(*pageAlloc).sysGrow -> go:string."sysGrow bounds not aligned to pallocChunkBytes"
runtime.(*pageAlloc).sysGrow -> gclocals·Ozyvqems24eck6eTpaZguQ==
runtime.(*pageAlloc).sysGrow -> runtime.(*pageAlloc).sysGrow.stkobj
runtime.(*pageAlloc).sysGrow.func3 -> runtime.(*pageAlloc).sysGrow.func3.arginfo1
runtime.(*scavengeIndex).sysGrow -> gclocals·ta3yUSCjq9IiQv+nm4wH3Q==
runtime.(*scavengeIndex).sysGrow -> gclocals·dD8ieaNP3Dos4erGtpY3kg==
runtime.(*scavengeIndex).sysGrow -> fmt.(*fmt).pad.argliveinfo
runtime.(*pageCache).alloc -> runtime.(*pageCache).allocN
runtime.(*pallocBits).find -> runtime.(*pallocBits).findSmallN
runtime.(*pallocBits).find -> runtime.(*pallocBits).findLargeN
runtime.mProf_Flush -> runtime.profMemActiveLock
runtime.mProf_Flush -> runtime.mProf_FlushLocked
runtime.mProf_FlushLocked -> runtime.mbuckets
runtime.mProf_Malloc -> runtime.callers
runtime.mProf_Malloc -> runtime.stkbucket
runtime.mProf_Malloc -> runtime.mProf_Malloc.func1
runtime.mProf_Malloc -> gclocals·RsxhRHA9BNTAZWuXCLrHUg==
runtime.stkbucket -> runtime.buckhash
runtime.stkbucket -> runtime.profInsertLock
runtime.stkbucket -> runtime.newBucket
runtime.stkbucket -> runtime.xbuckets
runtime.stkbucket -> runtime.bbuckets
runtime.stkbucket -> runtime.panicSlice3AlenU
runtime.stkbucket -> gclocals·OQcVLeG8nYNq7FQTnM4UAA==
runtime.stkbucket -> gclocals·26sz/awC7/Gp1WQw1bVsmw==
runtime.stkbucket -> runtime.stkbucket.arginfo1
runtime.stkbucket -> runtime.stkbucket.argliveinfo
runtime.newBucket -> go:string."invalid profile bucket type"
runtime.mProf_Malloc.func1 -> runtime.setprofilebucket
runtime.setprofilebucket -> runtime.addspecial
runtime.setprofilebucket -> go:string."setprofilebucket: profile already set"
runtime.setprofilebucket -> gclocals·o7ffi0tXs0SCrmoCBi7VPA==
runtime.addspecial -> runtime.(*mspan).ensureSwept
runtime.addspecial -> go:string."addspecial on invalid pointer"
runtime.addspecial -> gclocals·Tumw6UTxFRAq+KySimItaw==
runtime.addspecial -> gclocals·K2pSgSaXga60LVrAMfE8sw==
runtime.(*mspan).ensureSwept -> go:string."mspan.ensureSwept: m is not locked"
runtime.tracealloc -> go:string."tracealloc("
runtime.tracealloc -> runtime.tracealloc.func1
runtime.tracealloc -> gclocals·ABSVQLpZmCLdDFxsxzFBHQ==
runtime.tracealloc -> gclocals·uqvLTvd89xuxMguT6Vb4Aw==
runtime.tracegc -> go:string."tracegc()\n"
runtime.tracegc -> go:string."end tracegc\n"
runtime.makeAddrRange -> go:string."addr range base and limit are not in the same memory segment"
runtime.addrRange.subtract -> go:string."bad prune"
runtime.addrRange.subtract -> runtime.addrRange.subtract.arginfo1
runtime.(*addrRanges).add -> go:string."runtime: range = {"
runtime.(*addrRanges).add -> go:string."}\n"
runtime.(*addrRanges).add -> go:string."attempted to add zero-sized address range"
runtime.wbBufFlush1 -> runtime.shade
runtime.wbBufFlush1 -> runtime.(*gcWork).putBatch
runtime.wbBufFlush1 -> runtime.panicSliceAlenU
runtime.(*gcWork).putBatch -> gclocals·3t8WlE+CEPpgnWbvvNfnSA==
runtime.panicshift -> go:string."negative shift amount"
runtime.panicshift -> runtime.panicCheck1
runtime.panicshift -> runtime.shiftError
runtime.deferreturn -> go:string."unfinished open-coded defers in deferreturn"
runtime.deferreturn -> gclocals·o+xX3J0XafUF+XW9wD3VHQ==
runtime.addOneOpenDeferFrame -> runtime.addOneOpenDeferFrame.func1
runtime.addOneOpenDeferFrame -> runtime.addOneOpenDeferFrame.stkobj
runtime.addOneOpenDeferFrame.func1 -> runtime.newdefer
runtime.addOneOpenDeferFrame.func1 -> go:string."missing deferreturn"
runtime.addOneOpenDeferFrame.func1 -> go:string."duplicated defer entry"
runtime.addOneOpenDeferFrame.func1 -> gclocals·hrmRJvTj61aDdBHG1FTMtg==
runtime.newdefer -> runtime.gcWriteBarrier3
runtime.newdefer -> gclocals·35bp/sFrHnJ9ulRANvTjmA==
runtime.runOpenDeferFrame -> runtime.deferCallSave
runtime.runOpenDeferFrame -> runtime..stmp_113
runtime.fatalpanic -> runtime.fatalpanic.func1
runtime.fatalpanic -> runtime.fatalpanic.func2·f
runtime.fatalpanic -> runtime.fatalpanic.stkobj
runtime.fatalpanic.func1 -> runtime.printpanics
runtime.printpanics -> go:string." [recovered]"
runtime.suspendG -> runtime.castogscanstatus
runtime.suspendG -> runtime.casfrom_Gscanstatus
runtime.suspendG -> runtime.casGFromPreempted
runtime.suspendG -> go:string."runtime:   gp: gp="
runtime.suspendG -> go:string."runtime: getg:  g="
runtime.suspendG -> go:string.",  g->atomicstatus="
runtime.suspendG -> go:string."invalid g status"
runtime.suspendG -> go:string."suspendG from non-preemptible goroutine"
runtime.suspendG -> gclocals·26tm24YiQpYrbX0K6CC8qg==
runtime.resumeG -> go:string."unexpected g status"
runtime.resumeG -> gclocals·MZn1ahbT84zU5OkLNIFByA==
runtime.resumeG -> runtime.resumeG.arginfo1
runtime.printfloat -> go:string."-Inf"
runtime.printfloat -> go:string."+Inf"
runtime.printfloat -> $f64.8000000000000000
runtime.printfloat -> go:string."NaN"
runtime.printfloat -> $f64.4024000000000000
runtime.printfloat -> $f64.4014000000000000
runtime.printcomplex -> go:string."i)"
runtime.gopark -> runtime.park_m·f
runtime.gopark -> go:string."gopark: bad g status"
runtime.gopark -> strconv.formatDecimal.arginfo1
runtime.ready -> runtime.traceGoUnpark
runtime.ready -> runtime.runqput
runtime.ready -> runtime.wakep
runtime.ready -> go:string."bad g->status in ready"
runtime.ready -> gclocals·PFvtDxD7T05R0PbTdRTSQw==
runtime.ready -> gclocals·9zh4hUW9aHuUYXjJqoJzsQ==
runtime.casfrom_Gscanstatus -> go:string."runtime: casfrom_Gscanstatus failed gp="
runtime.casfrom_Gscanstatus -> go:string.", oldval="
runtime.casfrom_Gscanstatus -> go:string.", newval="
runtime.casfrom_Gscanstatus -> go:string."casfrom_Gscanstatus: gp->status is not in scan state"
runtime.casfrom_Gscanstatus -> go:string."runtime: casfrom_Gscanstatus bad oldval gp="
runtime.casfrom_Gscanstatus -> go:string."casfrom_Gscanstatus:top gp->status is not in scan state"
runtime.casfrom_Gscanstatus -> gclocals·o3Kun4xYxg5C876ga0QjuQ==
runtime.casfrom_Gscanstatus -> gclocals·wo6LIq2LDYvKcS2rgmm9cw==
runtime.castogscanstatus -> go:string."runtime: castogscanstatus oldval="
runtime.castogscanstatus -> go:string."castogscanstatus"
runtime.casGFromPreempted -> go:string."bad g transition"
runtime.startTheWorldWithSema -> runtime.netpollInited
runtime.startTheWorldWithSema -> runtime.netpoll
runtime.startTheWorldWithSema -> runtime.newprocs
runtime.startTheWorldWithSema -> runtime.procresize
runtime.startTheWorldWithSema -> runtime.newm
runtime.startTheWorldWithSema -> go:string."startTheWorld: inconsistent mp->nextp"
runtime.startTheWorldWithSema -> gclocals·VJInGZf2yN7VaIUL6FqluA==
runtime.netpoll -> runtime.iocphandle
runtime.netpoll -> runtime._GetQueuedCompletionStatusEx
runtime.netpoll -> go:string."runtime: GetQueuedCompletionStatusEx failed (errno= "
runtime.netpoll -> go:string." )\n"
runtime.netpoll -> go:string."runtime: netpoll failed"
runtime.netpoll -> runtime._WSAGetOverlappedResult
runtime.netpoll -> runtime.handlecompletion
runtime.netpoll -> runtime.netpollWakeSig
runtime.netpoll -> runtime.netpollBreak
runtime.netpoll -> gclocals·cnsm7VERm6G/NuevW3ECcA==
runtime.netpoll -> runtime.netpoll.stkobj
runtime.netpollBreak -> runtime._PostQueuedCompletionStatus
runtime.netpollBreak -> go:string."runtime: netpoll: PostQueuedCompletionStatus failed (errno= "
runtime.netpollBreak -> go:string."runtime: netpoll: PostQueuedCompletionStatus failed"
runtime.handlecompletion -> runtime.netpollready
runtime.handlecompletion -> go:string."runtime: GetQueuedCompletionStatusEx returned invalid mode= "
runtime.handlecompletion -> runtime.handlecompletion.arginfo1
runtime.newm -> runtime.allocm
runtime.newm -> runtime.newmHandoff
runtime.newm -> runtime.newm1
runtime.newm -> go:string."on a locked thread with no template thread"
runtime.newm -> gclocals·XQmNTo7A3JgGZKKHmaAdRA==
runtime.newm -> gclocals·ESr+dlj+ZUXO8X1Jig2pHQ==
runtime.allocm -> runtime.allocmLock
runtime.allocm -> runtime.(*rwmutex).rlock
runtime.allocm -> type:runtime.m
runtime.allocm -> runtime.mcommoninit
runtime.allocm -> runtime.malg
runtime.allocm -> runtime.releasep
runtime.allocm -> runtime.(*rwmutex).runlock
runtime.allocm -> runtime.allocm.func1
runtime.allocm -> gclocals·fFU7F4GXAurXI/8qEz6+Xg==
runtime.allocm -> gclocals·whfWZcTVDs61Ow6IV2QLxg==
runtime.allocm -> runtime.allocm.stkobj
runtime.mcommoninit -> runtime.mReserveID
runtime.mcommoninit -> runtime.fastrandseed
runtime.mcommoninit -> runtime.memhash64
runtime.mcommoninit -> type:runtime.cgoCallers
runtime.mReserveID -> runtime.checkmcount
runtime.mReserveID -> go:string."runtime: thread ID overflow"
runtime.checkmcount -> runtime.extraMInUse
runtime.checkmcount -> runtime.extraMLength
runtime.checkmcount -> go:string."runtime: program exceeds "
runtime.checkmcount -> go:string."-thread limit\n"
runtime.checkmcount -> go:string."thread exhaustion"
runtime.allocm.func1 -> runtime.stackfree
runtime.newm1 -> _cgo_thread_start
runtime.newm1 -> runtime.mstart
runtime.newm1 -> runtime.execLock
runtime.newm1 -> runtime.newosproc
runtime.newm1 -> go:string."_cgo_thread_start missing"
runtime.newm1 -> gclocals·QIar5BTRQNkEj7+oSgoIIg==
runtime.newm1 -> runtime.cgoCheckPtrWrite.stkobj
runtime.newosproc -> runtime._CreateThread
runtime.newosproc -> runtime.tstart_stdcall
runtime.newosproc -> go:string."runtime: failed to create new OS thread (have "
runtime.newosproc -> go:string." already; errno="
runtime.newosproc -> go:string."runtime.newosproc"
runtime.wakep -> runtime.pidlegetSpinning
runtime.wakep -> runtime.startm
runtime.wakep -> go:string."wakep: negative nmspinning"
runtime.startm -> runtime.mspinning·f
runtime.startm -> go:string."startm: p has runnable gs"
runtime.startm -> go:string."startm: m has p"
runtime.startm -> go:string."startm: m is spinning"
runtime.startm -> go:string."startm: P required for spinning=true"
runtime.startm -> gclocals·HEg+FDnKwiYICL8XBafhmw==
runtime.startm -> gclocals·dyqlTevkiJxXUXj+YwAGwA==
runtime.injectglist -> runtime.injectglist.func1·f
runtime.injectglist -> runtime.runqputbatch
runtime.injectglist -> gclocals·Th+s6nWAjs5SwKSrs0h2tg==
runtime.injectglist -> gclocals·VmK5OMFfX2/ramTMZmfjSg==
runtime.entersyscallblock -> runtime.entersyscallblock.func1
runtime.entersyscallblock -> runtime.entersyscallblock.func2
runtime.entersyscallblock -> runtime.entersyscallblock_handoff·f
runtime.entersyscallblock -> gclocals·UinhH5qS/cyML0st+leC3Q==
runtime.entersyscallblock -> runtime.entersyscallblock.stkobj
runtime.entersyscallblock.func2 -> go:string."entersyscallblock inconsistent "
runtime.entersyscallblock.func2 -> go:string."entersyscallblock"
runtime.malg -> type:runtime.g
runtime.malg -> runtime.malg.func1
runtime.malg.func1 -> runtime.stackalloc
runtime.newproc -> runtime.newproc.func1
runtime.newproc.func1 -> runtime.newproc1
runtime.newproc.func1 -> runtime.mainStarted
runtime.newproc1 -> go:string."go of nil func value"
runtime.newproc1 -> runtime.fatal
runtime.newproc1 -> runtime.gfget
runtime.newproc1 -> runtime.allgadd
runtime.newproc1 -> runtime.goexit
runtime.newproc1 -> runtime.gostartcallfn
runtime.newproc1 -> runtime.saveAncestors
runtime.newproc1 -> runtime.traceGoCreate
runtime.newproc1 -> go:string."newproc1: new g is not Gdead"
runtime.newproc1 -> go:string."newproc1: newg missing stack"
runtime.newproc1 -> gclocals·9Nx0uLB/jivkhRqwyy4SaQ==
runtime.newproc1 -> gclocals·KhYBXR514SvYdHS0N8hvuA==
runtime.fatal -> runtime.fatal.func1
runtime.allgadd -> type:*runtime.g
runtime.allgadd -> go:string."allgadd: bad status Gidle"
runtime.saveAncestors -> type:runtime.ancestorInfo
runtime.saveAncestors -> runtime.makeslice
runtime.saveAncestors -> runtime.typedslicecopy
runtime.saveAncestors -> runtime.gcallers
runtime.saveAncestors -> runtime.wbMove
runtime.saveAncestors -> type:[]runtime.ancestorInfo
runtime.saveAncestors -> gclocals·d85mNdGXvkEF+KsuAoM2Ng==
runtime.typedslicecopy -> gclocals·3X/bFQuX8p7oQPV40Ehnog==
runtime.typedslicecopy -> io.TeeReader.argliveinfo
runtime.gfget -> runtime.startingStackSize
runtime.gfget -> runtime.gfget.func1
runtime.gfget -> runtime.gfget.func2
runtime.procresize -> runtime.allpLock
runtime.procresize -> type:*runtime.p
runtime.procresize -> runtime.idlepMask
runtime.procresize -> runtime.timerpMask
runtime.procresize -> runtime.makeslicecopy
runtime.procresize -> type:runtime.p
runtime.procresize -> runtime.(*p).init
runtime.procresize -> runtime.traceProcStop
runtime.procresize -> runtime.traceGoStart
runtime.procresize -> runtime.(*p).destroy
runtime.procresize -> runtime.pidleput
runtime.procresize -> runtime.stealOrder
runtime.procresize -> runtime.(*gcCPULimiterState).resetCapacity
runtime.procresize -> go:string."procresize: invalid arg"
runtime.procresize -> gclocals·omONYAREoiufEVPHwKunwg==
runtime.(*gcCPULimiterState).resetCapacity -> go:string."failed to acquire lock to reset capacity"
runtime.(*p).init -> runtime.allocmcache
runtime.(*p).init -> go:string."missing mcache?"
runtime.allocmcache -> runtime.allocmcache.func1
runtime.(*p).destroy -> runtime.moveTimers
runtime.(*p).destroy -> runtime.memclrHasPointers
runtime.(*p).destroy -> runtime.(*p).destroy.func1
runtime.(*p).destroy -> runtime.(*p).destroy.func2
runtime.(*p).destroy -> runtime.gfpurge
runtime.(*p).destroy -> runtime.traceProcFree
runtime.(*p).destroy -> gclocals·NxH6OjKY5C2N4z1wxKNFLQ==
runtime.(*p).destroy -> gclocals·oZXz5ZgjtIQYR7IxjsoPdw==
runtime.(*p).destroy.func2 -> runtime.(*fixalloc).free
runtime.(*p).destroy.func1 -> runtime.(*pageCache).flush
runtime.wirep -> go:string."wirep: p->m="
runtime.wirep -> go:string.") p->status="
runtime.wirep -> go:string."wirep: invalid p state"
runtime.wirep -> go:string."wirep: already in go"
runtime.releasep -> go:string."releasep: m="
runtime.releasep -> go:string." m->p="
runtime.releasep -> go:string." p->m="
runtime.releasep -> go:string." p->status="
runtime.releasep -> go:string."releasep: invalid p state"
runtime.releasep -> go:string."releasep: invalid arg"
runtime.releasep -> gclocals·7fJlGj4ULSwoXiB2UIuDcg==
runtime.pidleput -> runtime.updateTimerPMask
runtime.pidleput -> go:string."must be able to track idle limiter event"
runtime.pidleput -> go:string."pidleput: P has non-empty run queue"
runtime.runqput -> runtime.runqputslow
runtime.runqputslow -> go:string."runqputslow: queue is not full"
runtime.runqputslow -> gclocals·QiD9DzPOHMceHi/jRx2KVw==
runtime.(*godebugInc).IncNonDefault -> runtime.godebugNewIncNonDefault
runtime.(*godebugInc).IncNonDefault -> type:func()
runtime.(*godebugInc).IncNonDefault -> runtime/internal/atomic.storePointer
runtime.(*godebugInc).IncNonDefault -> gclocals·Xts7OcECZRhSRBtANua2LQ==
runtime.(*godebugInc).IncNonDefault -> gclocals·5nuQxcrE+jGk86EA6ZGt9w==
runtime.(*rwmutex).rlock -> runtime.(*rwmutex).rlock.func1
runtime.(*rwmutex).rlock -> gclocals·AzW08EQV0LVfnDEAZer1Nw==
runtime.(*rwmutex).rlock.func1 -> runtime.notesleep
runtime.(*rwmutex).rlock.func1 -> gclocals·9ZqeuZegeWmbonLi7TPPLg==
runtime.notesleep -> go:string."notesleep - waitm out of sync"
runtime.notesleep -> go:string."notesleep not on g0"
runtime.notesleep -> gclocals·PLsaI/y2btsTjCgVjJ9ipw==
runtime.(*rwmutex).runlock -> go:string."runlock of unlocked rwmutex"
runtime.semacquire1 -> runtime.acquireSudog
runtime.semacquire1 -> runtime.semtable
runtime.semacquire1 -> runtime.blockprofilerate
runtime.semacquire1 -> runtime.mutexprofilerate
runtime.semacquire1 -> runtime.(*semaRoot).queue
runtime.semacquire1 -> runtime.blockevent
runtime.semacquire1 -> runtime.releaseSudog
runtime.semacquire1 -> go:string."semacquire not on the G stack"
runtime.semacquire1 -> gclocals·9ua+7HN8WO65akhINUP2QQ==
runtime.semacquire1 -> runtime.semacquire1.arginfo1
runtime.blockevent -> runtime.saveblockevent
runtime.saveblockevent -> runtime.(*bucket).bp
runtime.saveblockevent -> runtime.profBlockLock
runtime.(*bucket).bp -> go:string."bad use of bucket.bp"
runtime.acquireSudog -> go:string."acquireSudog: found s.elem != nil in cache"
runtime.acquireSudog -> type:*runtime.sudog
runtime.acquireSudog -> type:runtime.sudog
runtime.releaseSudog -> go:string."runtime: releaseSudog with non-nil gp.param"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil c"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil waitlink"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil prev"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil next"
runtime.releaseSudog -> go:string."runtime: sudog with non-false isSelect"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil elem"
runtime.semrelease1 -> runtime.(*semaRoot).dequeue
runtime.semrelease1 -> sync.event
runtime.semrelease1 -> runtime.readyWithTime
runtime.semrelease1 -> runtime.goyield_m·f
runtime.semrelease1 -> go:string."corrupted semaphore ticket"
runtime.semrelease1 -> gclocals·We1Is8spiQl0y09naytfeA==
runtime.semrelease1 -> gclocals·FRh+8fclNpKxuIb39yRs8A==
runtime.readyWithTime -> runtime.readyWithTime.func1
runtime.(*semaRoot).queue -> runtime.(*semaRoot).rotateLeft
runtime.(*semaRoot).queue -> runtime.(*semaRoot).rotateRight
runtime.(*semaRoot).queue -> runtime..stmp_123
runtime.(*semaRoot).queue -> gclocals·JNsYcqno00MdaZVFMLCVuA==
runtime.(*semaRoot).queue -> gclocals·b0WJAbYnhc5MFtZfpURKcA==
runtime.(*semaRoot).dequeue -> gclocals·NcVqcHrtYQqWV05KWf2NLg==
runtime.(*semaRoot).rotateLeft -> go:string."semaRoot rotateLeft"
runtime.(*semaRoot).rotateRight -> go:string."semaRoot rotateRight"
runtime.makeslicecopy -> runtime.bulkBarrierPreWriteSrcOnly
runtime.makeslicecopy -> type:runtime.errorString <UsedInIface>
runtime.makeslicecopy -> runtime..stmp_124
runtime.makeslicecopy -> gclocals·QNaJDSLA4oNHbT17F8cEDQ==
runtime.makeslicecopy -> gclocals·/fP+OwaUL92DyfUCmSXx5A==
runtime.bulkBarrierPreWriteSrcOnly -> gclocals·sQxO+jiYy+d9ldxoWSePwQ==
runtime.makeslice -> runtime..stmp_125
runtime.growslice -> runtime..stmp_131
runtime.growslice -> gclocals·x0e4vJQ+iNudJezgY+68nw==
runtime.stackcache_clear -> runtime.stackpool
runtime.stackcache_clear -> runtime.stackpoolfree
runtime.stackpoolfree -> go:string."freeing stack not in a stack span"
runtime.stackalloc -> go:string."out of memory (stackalloc)"
runtime.stackalloc -> runtime.stackLarge
runtime.stackalloc -> runtime.stackpoolalloc
runtime.stackalloc -> runtime.stackcacherefill
runtime.stackalloc -> go:string."stack size not a power of 2"
runtime.stackalloc -> go:string."stackalloc not on scheduler stack"
runtime.stackpoolalloc -> go:string."span has no free stacks"
runtime.stackpoolalloc -> go:string."bad manualFreeList"
runtime.stackpoolalloc -> go:string."bad allocCount"
runtime.stackfree -> go:string."bad span state"
runtime.stackfree -> runtime.stackcacherelease
runtime.stackfree -> go:string."stack not a power of 2"
runtime.stackfree -> gclocals·lf0jAOJ5icNqMXtP6rxGWQ==
runtime.gostartcallfn -> runtime.nilfunc
runtime.shrinkstack -> runtime.copystack
runtime.shrinkstack -> go:string."shrinking stack in libcall"
runtime.shrinkstack -> go:string."shrinkstack at bad time"
runtime.shrinkstack -> go:string."bad status in shrinkstack"
runtime.shrinkstack -> go:string."missing stack in shrinkstack"
runtime.copystack -> runtime.stackPoisonCopy
runtime.copystack -> runtime.adjustctxt
runtime.copystack -> runtime.adjustdefers
runtime.copystack -> runtime.adjustframe
runtime.copystack -> go:string."racy sudog adjustment due to parking on channel"
runtime.copystack -> runtime.syncadjustsudogs
runtime.copystack -> go:string."nil stackbase"
runtime.copystack -> go:string."stack growth not allowed in system call"
runtime.adjustframe -> runtime.adjustpointers
runtime.adjustframe -> gclocals·ObPjcMslu98jFXwAfdYgvA==
runtime.adjustframe -> gclocals·ARpGhnJQ7aEia/Su2mQG7g==
runtime.adjustframe -> fmt.(*ss).scanOne.stkobj
runtime.adjustpointers -> go:string."runtime: bad pointer in frame "
runtime.adjustpointers -> go:string." at "
runtime.adjustpointers -> go:string."invalid pointer found on stack"
runtime.adjustpointers -> gclocals·9EVKLAhwamfOfu3Afcap+Q==
runtime.adjustpointers -> reflect.arrayAt.arginfo1
runtime.syncadjustsudogs -> gclocals·oQfeCBBjjns7RmEq2+gD9w==
runtime.syncadjustsudogs -> gclocals·9gc6MeB1oh3mlml/1PtZvg==
runtime.gcComputeStartingStackSize -> runtime.maxstacksize
runtime.(*stkframe).argBytes -> runtime.(*stkframe).argMapInternal
runtime.(*stkframe).argMapInternal -> go:string."reflect.methodValueCall"
runtime.(*stkframe).argMapInternal -> go:string."reflect.makeFuncStub"
runtime.(*stkframe).argMapInternal -> go:string."runtime: confused by "
runtime.(*stkframe).argMapInternal -> go:string."reflect mismatch"
runtime.(*stkframe).argMapInternal -> go:string.": no frame (sp="
runtime.(*stkframe).argMapInternal -> go:string.") at entry+"
runtime.(*stkframe).argMapInternal -> gclocals·sxadaCarlslkZj8nUpv5BA==
runtime.(*stkframe).argMapInternal -> gclocals·v3msp5omBota385OaqV/yA==
runtime.(*stkframe).getStackMap -> runtime.methodValueCallFrameObjs
runtime.(*stkframe).getStackMap -> runtime.panicunsafeslicelen
runtime.(*stkframe).getStackMap -> go:string."runtime: pcdata is "
runtime.(*stkframe).getStackMap -> go:string." and "
runtime.(*stkframe).getStackMap -> go:string." args stack map entries for "
runtime.(*stkframe).getStackMap -> go:string." (targetpc="
runtime.(*stkframe).getStackMap -> go:string."bad symbol table"
runtime.(*stkframe).getStackMap -> go:string."runtime: frame "
runtime.(*stkframe).getStackMap -> go:string." untyped args "
runtime.(*stkframe).getStackMap -> go:string."missing stackmap"
runtime.(*stkframe).getStackMap -> go:string." locals stack map entries for "
runtime.(*stkframe).getStackMap -> go:string." untyped locals "
runtime.(*stkframe).getStackMap -> gclocals·vAIk0ZOUfJtv29Tq744+Hw==
runtime.(*stkframe).getStackMap -> gclocals·qROKjnXGanMysg8Sjs79mg==
runtime.slicebytetostring -> runtime.staticuint64s
runtime.moveTimers -> runtime.doaddtimer
runtime.moveTimers -> runtime.badTimer
runtime.moveTimers -> runtime.moveTimers.jump13
runtime.moveTimers -> gclocals·z1fTi5Q9ktmU9zsaMld+eg==
runtime.doaddtimer -> runtime.netpollGenericInit
runtime.doaddtimer -> type:*runtime.timer
runtime.doaddtimer -> runtime.siftupTimer
runtime.doaddtimer -> go:string."doaddtimer: P already set in timer"
runtime.netpollGenericInit -> runtime.netpollInitLock
runtime.netpollGenericInit -> runtime.netpollinit
runtime.netpollinit -> runtime._CreateIoCompletionPort
runtime.netpollinit -> go:string."runtime: CreateIoCompletionPort failed (errno= "
runtime.netpollinit -> go:string."runtime: netpollinit failed"
runtime.badTimer -> go:string."timer data corruption"
runtime.traceEvent -> runtime.traceAcquireBuffer
runtime.traceEvent -> runtime.traceEventLocked
runtime.traceEvent -> runtime.traceReleaseBuffer
runtime.traceEvent -> gclocals·2rO4LZpmpr1MJj9igFBNjA==
runtime.traceEvent -> runtime.traceEvent.arginfo1
runtime.traceEvent -> runtime.traceEvent.argliveinfo
runtime.traceEventLocked -> runtime.traceEventLocked.func1
runtime.traceEventLocked -> runtime.traceStackID
runtime.traceEventLocked -> go:string."invalid length of trace event"
runtime.traceEventLocked -> gclocals·NP1eieNJD084sYJYovpFEQ==
runtime.traceEventLocked -> gclocals·nWXxDa+AaT4nsak3b0/xfA==
runtime.traceEventLocked -> runtime.traceEventLocked.arginfo1
runtime.traceEventLocked -> runtime.traceEventLocked.argliveinfo
runtime.traceEventLocked.func1 -> runtime.traceFlush
runtime.traceStackID -> runtime.getcallerfp
runtime.traceStackID -> runtime.(*traceStackTable).put
runtime.traceStackID -> gclocals·dHp8Husql0+svUGjZaZFhw==
runtime.traceStackID -> io.(*SectionReader).ReadAt.arginfo1
runtime.traceStackID -> runtime.traceStackID.argliveinfo
runtime.traceFlush -> go:string."trace: out of memory"
runtime.(*traceStackTable).put -> runtime.memhash
runtime.(*traceStackTable).put -> runtime.(*traceStackTable).put.func1
runtime.(*traceStackTable).put -> gclocals·Lu+EX+h9LPt8+JinBu038g==
runtime.(*traceStackTable).put -> runtime.(*traceStackTable).put.stkobj
runtime.(*traceStackTable).put.func1 -> runtime.(*traceAlloc).alloc
runtime.(*traceStackTable).put.func1 -> gclocals·o43V1OS2BlET6GHzhTz/Tg==
runtime.(*traceAlloc).alloc -> go:string."trace: alloc too large"
runtime.traceGCSweepStart -> go:string."double traceGCSweepStart"
runtime.traceGCSweepDone -> go:string."missing traceGCSweepStart"
runtime.traceGoCreate -> runtime.startPCforTrace
runtime.traceGoCreate -> type:[2]uintptr
runtime.tracebackPCs -> gclocals·aqkXS/ODcKJVRe+HEh3DlQ==
runtime.tracebackPCs -> runtime.(*cpuProfile).add.arginfo1
runtime.tracebackPCs -> runtime.(*cpuProfile).add.argliveinfo
runtime.callers -> runtime.callers.func1
runtime.callers -> gclocals·SoG6d3SEFU105ym5LEtOUA==
runtime.callers -> runtime.callers.stkobj
runtime.gcallers -> gclocals·bBhGshdVnp54a1lncqXuMQ==
runtime.gcallers -> fmt.Fscan.argliveinfo
runtime.resolveNameOff -> runtime.reflectOffs
runtime.resolveNameOff -> type:map[int32]unsafe.Pointer
runtime.resolveNameOff -> runtime.mapaccess2_fast32
runtime.resolveNameOff -> go:string."runtime: nameOff "
runtime.resolveNameOff -> go:string." base "
runtime.resolveNameOff -> go:string." not in ranges:\n"
runtime.resolveNameOff -> go:string."\ttypes "
runtime.resolveNameOff -> go:string." etypes "
runtime.resolveNameOff -> go:string."runtime: name offset base pointer out of range"
runtime.resolveNameOff -> go:string."runtime: name offset out of range"
runtime.mapaccess2_fast32 -> go:string."concurrent map read and map write"
runtime.mapaccess2_fast32 -> runtime.mapaccess1_fast32.argliveinfo
runtime.resolveTypeOff -> type:map[internal/abi.TypeOff]*internal/abi.Type
runtime.resolveTypeOff -> runtime.mapaccess1_fast32
runtime.resolveTypeOff -> go:string."runtime: typeOff "
runtime.resolveTypeOff -> go:string."runtime: type offset base pointer out of range"
runtime.resolveTypeOff -> go:string."runtime: type offset out of range"
runtime.rtype.textOff -> go:string."runtime: textOff "
runtime.rtype.textOff -> go:string."runtime: text offset base pointer out of range"
runtime.rtype.textOff -> os.fileWithoutReadFrom.Chmod.arginfo1
runtime.panicunsafestringlen -> runtime..stmp_150
runtime.panicunsafestringnilptr -> runtime..stmp_151
runtime.panicunsafeslicelen -> runtime.panicunsafeslicelen1
runtime.panicunsafeslicelen1 -> go:string."unsafe.Slice: len out of range"
runtime.panicunsafeslicelen1 -> runtime..stmp_163
runtime.preprintpanics.func1 -> runtime.gorecover
runtime.preprintpanics.func1 -> go:string."panic while printing panic value"
runtime.preprintpanics.func1 -> runtime.concatstring3
runtime.preprintpanics.func1 -> go:string.": type "
runtime.concatstring3 -> runtime.concatstrings
runtime.concatstring3 -> gclocals·iV5eOcg9C3V98k9xZsw9lA==
runtime.concatstring3 -> runtime.concatstring3.stkobj
runtime.concatstring3 -> sync.(*Map).CompareAndSwap.arginfo1
runtime.concatstrings -> runtime.rawstringtmp
runtime.concatstrings -> go:string."string concatenation too long"
runtime.concatstrings -> gclocals·FLuj5vxpzjAkyiXpJQcesg==
type:string <UsedInIface> -> runtime.strequal·f
type:string <UsedInIface> -> type:.namedata.*string-
type:string <UsedInIface> -> type:*string <UsedInIface>
type:*string <UsedInIface> -> runtime.memequal64·f
type:error -> runtime.interequal·f
type:error -> type:.namedata.*error-
type:error -> type:*error
type:error -> type:.namedata.Error.
type:error -> type:func() string
type:runtime.errorString <UsedInIface> -> type:.namedata.*runtime.errorString-
type:runtime.errorString <UsedInIface> -> type:*runtime.errorString <UsedInIface>
type:runtime.errorString <UsedInIface> -> type:.importpath.runtime.
type:runtime.errorString <UsedInIface> -> type:func() string <UsedInIface>
type:runtime.errorString <UsedInIface> -> type:.namedata.RuntimeError.
type:runtime.errorString <UsedInIface> -> type:func() <UsedInIface>
 -> go:info.struct { runtime.lock runtime.mutex; runtime.reuse []runtime.liveUserArenaChunk; runtime.fault []runtime.liveUserArenaChunk }
runtime.cgo_yield -> _cgo_yield
 -> go:info.*unsafe.Pointer
 -> go:info.[33]float64
runtime.itabTable -> runtime.itabTableInit
 -> go:info.*runtime.itabTableType
 -> go:info.runtime.itabTableType
 -> go:info.*internal/abi.Type
 -> go:info.[256]uint64
 -> go:info.struct { runtime.mutex; runtime.persistentAlloc }
 -> go:info.*runtime.notInHeap
 -> go:info.[1024]uint8
 -> go:info.runtime.mspan
 -> go:info.*runtime.finblock
 -> go:info.[64]uint8
 -> go:info.[5]uint8
 -> go:info.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.alignme uint64 }
 -> go:info.runtime.workType
 -> go:info.func()
 -> go:info.[]unsafe.Pointer
 -> go:info.runtime.gcCPULimiterState
 -> go:info.runtime.gcControllerState
 -> go:info.struct { runtime.gcPercentGoal runtime/internal/atomic.Uint64; runtime.memoryLimitGoal runtime/internal/atomic.Uint64; runtime.assistTime runtime/internal/atomic.Int64; runtime.backgroundTime runtime/internal/atomic.Int64 }
 -> go:info.runtime.scavengerState
 -> go:info.runtime.sweepdata
runtime.mSpanStateNames -> runtime..stmp_53
 -> go:info.[]string
 -> go:info.struct { runtime.lock runtime.mutex; runtime.free *runtime.gcBitsArena; runtime.next *runtime.gcBitsArena; runtime.current *runtime.gcBitsArena; runtime.previous *runtime.gcBitsArena }
 -> go:info.[5]uint
 -> go:info.[3]runtime.mutex
 -> go:info.runtime/internal/atomic.UnsafePointer
 -> go:info.runtime.mProfCycleHolder
 -> go:info.struct { runtime.sema uint32; runtime.active bool; runtime.offset runtime/internal/atomic.Int64; runtime.records []runtime.StackRecord; runtime.labels []unsafe.Pointer }
 -> go:info.runtime.offAddr
 -> go:info.runtime.spanSetBlockAlloc
 -> go:info.runtime.mstats
runtime.shiftError -> go:itab.runtime.errorString,error
runtime.shiftError -> runtime..stmp_55
 -> go:info.error
runtime.divideError -> runtime..stmp_56
runtime.panicnil -> runtime..stmp_60
 -> go:info.*runtime.godebugInc
 -> go:info.*runtime.mcache
 -> go:info.runtime.rwmutex
 -> go:info.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }
 -> go:info.runtime.randomOrder
 -> go:info.runtime.tracestat
 -> go:info.runtime/internal/atomic.Pointer[func(string) func()]
 -> go:info.runtime.pMask
 -> go:info.runtime.semTable
 -> go:info.[68]uint16
 -> go:info.[68]uint8
 -> go:info.[68]uint32
 -> go:info.[129]uint8
 -> go:info.[249]uint8
 -> go:info.[2]struct { runtime.item runtime.stackpoolItem; runtime._ [40]uint8 }
 -> go:info.struct { runtime.lock runtime.mutex; runtime.free [35]runtime.mSpanList }
 -> go:info.[1]runtime.stackObjectRecord
 -> go:info.*[]*runtime.moduledata
 -> go:info.struct { runtime.lock runtime.mutex; runtime.next int32; runtime.m map[int32]unsafe.Pointer; runtime.minv map[unsafe.Pointer]int32 }
runtime..stmp_53 -> go:string."mSpanDead"
runtime..stmp_53 -> go:string."mSpanInUse"
runtime..stmp_53 -> go:string."mSpanManual"
runtime..stmp_60 -> go:string."panicnil"
type:bool -> runtime.memequal8·f
type:bool -> main..stmp_0
type:bool -> type:.namedata.*bool-
type:bool -> type:*bool
type:complex128 -> runtime.c128equal·f
type:complex128 -> type:.namedata.*complex128-
type:complex128 -> type:*complex128
type:complex64 -> runtime.c64equal·f
type:complex64 -> type:.namedata.*complex64-
type:complex64 -> type:*complex64
type:float32 -> runtime.f32equal·f
type:float32 -> type:.namedata.*float32-
type:float32 -> type:*float32
type:float64 -> runtime.f64equal·f
type:float64 -> type:.namedata.*float64-
type:float64 -> type:*float64
type:int -> type:.namedata.*int-
type:int -> type:*int
type:int16 -> runtime.memequal16·f
type:int16 -> type:.namedata.*int16-
type:int16 -> type:*int16
type:int32 -> runtime.memequal32·f
type:int32 -> type:.namedata.*int32-
type:int32 -> type:*int32
type:int64 -> type:.namedata.*int64-
type:int64 -> type:*int64
type:int8 -> type:.namedata.*int8-
type:int8 -> type:*int8
type:uintptr -> type:.namedata.*uintptr-
type:uintptr -> type:*uintptr
type:uint32 -> type:.namedata.*uint32-
type:uint32 -> type:*uint32
type:uint8 -> type:.namedata.*uint8-
type:uint8 -> type:*uint8
type:uint -> type:.namedata.*uint-
type:uint -> type:*uint
type:uint64 -> type:.namedata.*uint64-
type:uint64 -> type:*uint64
type:*runtime.PanicNilError <UsedInIface> -> type:.namedata.*runtime.PanicNilError.
type:*runtime.PanicNilError <UsedInIface> -> type:runtime.PanicNilError <UsedInIface>
type:runtime.PanicNilError <UsedInIface> -> type:.eqfunc.runtime.PanicNilError
type:runtime.PanicNilError <UsedInIface> -> type:.namedata._-
type:runtime.PanicNilError <UsedInIface> -> type:[0]*runtime.PanicNilError <UsedInIface>
type:*runtime.TypeAssertionError <UsedInIface> -> type:.namedata.*runtime.TypeAssertionError.
type:*runtime.TypeAssertionError <UsedInIface> -> type:runtime.TypeAssertionError <UsedInIface>
type:runtime.TypeAssertionError <UsedInIface> -> type:.eqfunc.runtime.TypeAssertionError
type:runtime.TypeAssertionError <UsedInIface> -> runtime.gcbits.0f00000000000000
type:runtime.TypeAssertionError <UsedInIface> -> type:.namedata._interface-
type:runtime.TypeAssertionError <UsedInIface> -> type:*internal/abi.Type <UsedInIface>
type:runtime.TypeAssertionError <UsedInIface> -> type:.namedata.concrete-
type:runtime.TypeAssertionError <UsedInIface> -> type:.namedata.asserted-
type:runtime.TypeAssertionError <UsedInIface> -> type:.namedata.missingMethod-
type:*internal/abi.Type <UsedInIface> -> type:.namedata.*abi.Type.
type:*internal/abi.Type <UsedInIface> -> type:internal/abi.Type <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> type:.importpath.internal/abi.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Align.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.ArrayType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.ChanDir.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Common.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Elem.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.ExportedMethods.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.FieldAlign.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.FuncType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.GcSlice.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.HasName.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.IfaceIndir.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.InterfaceType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.IsDirectIface.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Key.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Kind.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Len.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.MapType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.NumMethod.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Pointers.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Size.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.StructType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Uncommon.
type:internal/abi.Type <UsedInIface> -> runtime.gcbits.1800000000000000
type:internal/abi.Type <UsedInIface> -> type:.namedata.Size_.
type:internal/abi.Type <UsedInIface> -> type:uintptr <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.PtrBytes.
type:internal/abi.Type <UsedInIface> -> type:.namedata.Hash.
type:internal/abi.Type <UsedInIface> -> type:uint32 <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.TFlag.
type:internal/abi.Type <UsedInIface> -> type:internal/abi.TFlag <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.Align_.
type:internal/abi.Type <UsedInIface> -> type:uint8 <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.FieldAlign_.
type:internal/abi.Type <UsedInIface> -> type:.namedata.Kind_.
type:internal/abi.Type <UsedInIface> -> type:.namedata.Equal.
type:internal/abi.Type <UsedInIface> -> type:func(unsafe.Pointer, unsafe.Pointer) bool <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.GCData.
type:internal/abi.Type <UsedInIface> -> type:*uint8 <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.Str.
type:internal/abi.Type <UsedInIface> -> type:internal/abi.NameOff <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.PtrToThis.
type:internal/abi.Type <UsedInIface> -> type:internal/abi.TypeOff <UsedInIface>
type:internal/abi.TFlag <UsedInIface> -> type:.namedata.*abi.TFlag.
type:internal/abi.TFlag <UsedInIface> -> type:*internal/abi.TFlag <UsedInIface>
type:internal/abi.NameOff <UsedInIface> -> type:.namedata.*abi.NameOff.
type:internal/abi.NameOff <UsedInIface> -> type:*internal/abi.NameOff <UsedInIface>
type:internal/abi.TypeOff <UsedInIface> -> type:.namedata.*abi.TypeOff.
type:internal/abi.TypeOff <UsedInIface> -> type:*internal/abi.TypeOff <UsedInIface>
type:uintptr <UsedInIface> -> type:*uintptr <UsedInIface>
type:uint32 <UsedInIface> -> type:*uint32 <UsedInIface>
type:*runtime._defer -> type:.namedata.*runtime._defer-
type:runtime._defer -> runtime.gcbits.7800000000000000
type:runtime._defer -> type:.namedata.started-
type:runtime._defer -> type:.namedata.heap-
type:runtime._defer -> type:.namedata.openDefer-
type:runtime._defer -> type:.namedata.sp-
type:runtime._defer -> type:.namedata.pc-
type:runtime._defer -> type:.namedata.fn-
type:runtime._defer -> type:.namedata._panic-
type:runtime._defer -> type:*runtime._panic
type:runtime._defer -> type:.namedata.link-
type:runtime._defer -> type:.namedata.fd-
type:runtime._defer -> type:unsafe.Pointer <UsedInIface>
type:runtime._defer -> type:.namedata.varp-
type:runtime._defer -> type:.namedata.framepc-
type:unsafe.Pointer <UsedInIface> -> type:.namedata.*unsafe.Pointer.
type:unsafe.Pointer <UsedInIface> -> type:*unsafe.Pointer <UsedInIface>
type:unsafe.Pointer <UsedInIface> -> type:.importpath.unsafe.
type:*runtime._panic -> type:.namedata.*runtime._panic-
type:*runtime._panic -> type:runtime._panic
type:runtime._panic -> type:.eqfunc.runtime._panic
type:runtime._panic -> type:.namedata.argp-
type:runtime._panic -> type:.namedata.arg-
type:runtime._panic -> type:interface {}
type:runtime._panic -> type:.namedata.recovered-
type:runtime._panic -> type:.namedata.aborted-
type:runtime._panic -> type:.namedata.goexit-
type:uint16 -> type:.namedata.*uint16-
type:uint16 -> type:*uint16
type:runtime.ancestorInfo -> type:.namedata.*runtime.ancestorInfo-
type:runtime.ancestorInfo -> type:*runtime.ancestorInfo
type:runtime.ancestorInfo -> type:.namedata.pcs-
type:runtime.ancestorInfo -> type:[]uintptr
type:runtime.ancestorInfo -> type:.namedata.goid-
type:runtime.ancestorInfo -> type:.namedata.gopc-
type:runtime.cgoCallers -> type:.eqfunc256
type:runtime.cgoCallers -> type:.namedata.*runtime.cgoCallers-
type:runtime.cgoCallers -> type:*runtime.cgoCallers
type:runtime.sudog -> type:.eqfunc.runtime.sudog
type:runtime.sudog -> runtime.gcbits.8f07000000000000
type:runtime.sudog -> type:.namedata.*runtime.sudog-
type:runtime.sudog -> type:.namedata.g-
type:runtime.sudog -> type:.namedata.next-
type:runtime.sudog -> type:.namedata.prev-
type:runtime.sudog -> type:.namedata.elem-
type:runtime.sudog -> type:.namedata.acquiretime-
type:runtime.sudog -> type:.namedata.releasetime-
type:runtime.sudog -> type:.namedata.ticket-
type:runtime.sudog -> type:.namedata.isSelect-
type:runtime.sudog -> type:.namedata.success-
type:runtime.sudog -> type:.namedata.parent-
type:runtime.sudog -> type:.namedata.waitlink-
type:runtime.sudog -> type:.namedata.waittail-
type:runtime.sudog -> type:.namedata.c-
type:runtime.sudog -> type:*runtime.hchan
type:*runtime.hchan -> type:.namedata.*runtime.hchan-
type:*runtime.hchan -> type:runtime.hchan
type:*runtime.hchan -> type:.namedata.raceaddr-
type:*runtime.hchan -> type:.namedata.sortkey-
type:runtime.hchan -> type:.eqfunc.runtime.hchan
type:runtime.hchan -> runtime.gcbits.9407000000000000
type:runtime.hchan -> type:.namedata.qcount-
type:runtime.hchan -> type:.namedata.dataqsiz-
type:runtime.hchan -> type:.namedata.buf-
type:runtime.hchan -> type:.namedata.elemsize-
type:runtime.hchan -> type:.namedata.closed-
type:runtime.hchan -> type:.namedata.elemtype-
type:runtime.hchan -> type:.namedata.sendx-
type:runtime.hchan -> type:.namedata.recvx-
type:runtime.hchan -> type:.namedata.recvq-
type:runtime.hchan -> type:runtime.waitq
type:runtime.hchan -> type:.namedata.sendq-
type:runtime.hchan -> type:.namedata.lock-
type:runtime.hchan -> type:runtime.mutex
type:runtime.mutex -> type:.namedata.*runtime.mutex-
type:runtime.mutex -> type:*runtime.mutex
type:runtime.mutex -> type:.namedata.lockRankStruct-.embedded
type:runtime.mutex -> type:runtime.lockRankStruct
type:runtime.mutex -> type:.namedata.key-
type:runtime.lockRankStruct -> runtime.memequal0·f
type:runtime.lockRankStruct -> type:.namedata.*runtime.lockRankStruct-
type:runtime.lockRankStruct -> type:*runtime.lockRankStruct
type:runtime.waitq -> runtime.memequal128·f
type:runtime.waitq -> runtime.gcbits.0300000000000000
type:runtime.waitq -> type:.namedata.*runtime.waitq-
type:runtime.waitq -> type:*runtime.waitq
type:runtime.waitq -> type:.namedata.first-
type:runtime.waitq -> type:.namedata.last-
type:*runtime.waitq -> type:.namedata.dequeue-
type:*runtime.waitq -> type:.namedata.dequeueSudoG-
type:*runtime.waitq -> type:.namedata.enqueue-
type:*runtime.timer -> type:.namedata.*runtime.timer-
type:*runtime.timer -> type:runtime.timer
type:runtime.timer -> type:.namedata.pp-
type:runtime.timer -> type:runtime.puintptr
type:runtime.timer -> type:.namedata.when-
type:runtime.timer -> type:.namedata.period-
type:runtime.timer -> type:.namedata.f-
type:runtime.timer -> type:func(interface {}, uintptr)
type:runtime.timer -> type:.namedata.seq-
type:runtime.timer -> type:.namedata.nextwhen-
type:runtime.timer -> type:.namedata.status-
type:runtime.timer -> type:runtime/internal/atomic.Uint32
type:runtime.p -> runtime.gcbits.0020ffffffff000000000000000000000000000000000000000000000000000000000000000040feffffffffffffffffffffffffffffff0100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000
type:runtime.p -> type:.namedata.*runtime.p-
type:runtime.p -> type:.namedata.id-
type:runtime.p -> type:.namedata.schedtick-
type:runtime.p -> type:.namedata.syscalltick-
type:runtime.p -> type:.namedata.sysmontick-
type:runtime.p -> type:runtime.sysmontick
type:runtime.p -> type:.namedata.m-
type:runtime.p -> type:runtime.muintptr
type:runtime.p -> type:.namedata.mcache-
type:runtime.p -> type:*runtime.mcache
type:runtime.p -> type:.namedata.pcache-
type:runtime.p -> type:runtime.pageCache
type:runtime.p -> type:.namedata.raceprocctx-
type:runtime.p -> type:.namedata.deferpool-
type:runtime.p -> type:[]*runtime._defer
type:runtime.p -> type:.namedata.deferpoolbuf-
type:runtime.p -> type:[32]*runtime._defer
type:runtime.p -> type:.namedata.goidcache-
type:runtime.p -> type:.namedata.goidcacheend-
type:runtime.p -> type:.namedata.runqhead-
type:runtime.p -> type:.namedata.runqtail-
type:runtime.p -> type:.namedata.runq-
type:runtime.p -> type:[256]runtime.guintptr
type:runtime.p -> type:.namedata.runnext-
type:runtime.p -> type:runtime.guintptr
type:runtime.p -> type:.namedata.gFree-
type:runtime.p -> type:struct { runtime.gList; runtime.n int32 }
type:runtime.p -> type:.namedata.sudogcache-
type:runtime.p -> type:[]*runtime.sudog
type:runtime.p -> type:.namedata.sudogbuf-
type:runtime.p -> type:[128]*runtime.sudog
type:runtime.p -> type:.namedata.mspancache-
type:runtime.p -> type:struct { runtime.len int; runtime.buf [128]*runtime.mspan }
type:runtime.p -> type:.namedata.trace-
type:runtime.p -> type:runtime.pTraceState
type:runtime.p -> type:.namedata.palloc-
type:runtime.p -> type:runtime.persistentAlloc
type:runtime.p -> type:.namedata.timer0When-
type:runtime.p -> type:runtime/internal/atomic.Int64
type:runtime.p -> type:.namedata.timerModifiedEarliest-
type:runtime.p -> type:.namedata.gcAssistTime-
type:runtime.p -> type:.namedata.gcFractionalMarkTime-
type:runtime.p -> type:.namedata.limiterEvent-
type:runtime.p -> type:runtime.limiterEvent
type:runtime.p -> type:.namedata.gcMarkWorkerMode-
type:runtime.p -> type:runtime.gcMarkWorkerMode
type:runtime.p -> type:.namedata.gcMarkWorkerStartTime-
type:runtime.p -> type:.namedata.gcw-
type:runtime.p -> type:runtime.gcWork
type:runtime.p -> type:.namedata.wbBuf-
type:runtime.p -> type:runtime.wbBuf
type:runtime.p -> type:.namedata.runSafePointFn-
type:runtime.p -> type:.namedata.statsSeq-
type:runtime.p -> type:.namedata.timersLock-
type:runtime.p -> type:.namedata.timers-
type:runtime.p -> type:[]*runtime.timer
type:runtime.p -> type:.namedata.numTimers-
type:runtime.p -> type:.namedata.deletedTimers-
type:runtime.p -> type:.namedata.timerRaceCtx-
type:runtime.p -> type:.namedata.maxStackScanDelta-
type:runtime.p -> type:.namedata.scannedStackSize-
type:runtime.p -> type:.namedata.scannedStacks-
type:runtime.p -> type:.namedata.preempt-
type:runtime.p -> type:.namedata.pageTraceBuf-
type:runtime.p -> type:runtime.pageTraceBuf
type:runtime.sysmontick -> type:.eqfunc.runtime.sysmontick
type:runtime.sysmontick -> type:.namedata.*runtime.sysmontick-
type:runtime.sysmontick -> type:*runtime.sysmontick
type:runtime.sysmontick -> type:.namedata.schedwhen-
type:runtime.sysmontick -> type:.namedata.syscallwhen-
type:runtime.muintptr -> type:.namedata.*runtime.muintptr-
type:runtime.muintptr -> type:*runtime.muintptr
type:runtime.muintptr -> type:.namedata.ptr-
type:*runtime.muintptr -> type:.namedata.set-
type:*runtime.mcache -> type:.namedata.*runtime.mcache-
type:*runtime.mcache -> type:runtime.mcache
type:*runtime.mcache -> type:.namedata.allocLarge-
type:*runtime.mcache -> type:.namedata.nextFree-
type:*runtime.mcache -> type:.namedata.prepareForSweep-
type:*runtime.mcache -> type:.namedata.refill-
type:*runtime.mcache -> type:.namedata.releaseAll-
type:runtime.mcache -> type:.eqfunc.runtime.mcache
type:runtime.mcache -> type:runtime/internal/sys.NotInHeap
type:runtime.mcache -> type:.namedata.nextSample-
type:runtime.mcache -> type:.namedata.scanAlloc-
type:runtime.mcache -> type:.namedata.tiny-
type:runtime.mcache -> type:.namedata.tinyoffset-
type:runtime.mcache -> type:.namedata.tinyAllocs-
type:runtime.mcache -> type:.namedata.alloc-
type:runtime.mcache -> type:[136]*runtime.mspan
type:runtime.mcache -> type:.namedata.stackcache-
type:runtime.mcache -> type:[2]runtime.stackfreelist
type:runtime.mcache -> type:.namedata.flushGen-
type:runtime.pageCache -> type:.eqfunc24
type:runtime.pageCache -> type:.namedata.*runtime.pageCache-
type:runtime.pageCache -> type:*runtime.pageCache
type:runtime.pageCache -> type:.namedata.base-
type:runtime.pageCache -> type:.namedata.cache-
type:runtime.pageCache -> type:.namedata.scav-
type:*runtime.pageCache -> type:.namedata.allocN-
type:*runtime.pageCache -> type:.namedata.empty-
type:*runtime.pageCache -> type:.namedata.flush-
type:runtime.pTraceState -> type:.eqfunc.runtime.pTraceState
type:runtime.pTraceState -> type:.namedata.*runtime.pTraceState-
type:runtime.pTraceState -> type:*runtime.pTraceState
type:runtime.pTraceState -> type:runtime.traceBufPtr
type:runtime.pTraceState -> type:.namedata.inSweep-
type:runtime.pTraceState -> type:.namedata.swept-
type:runtime.pTraceState -> type:.namedata.reclaimed-
type:runtime.traceBufPtr -> type:.namedata.*runtime.traceBufPtr-
type:runtime.traceBufPtr -> type:*runtime.traceBufPtr
type:runtime.persistentAlloc -> type:.namedata.*runtime.persistentAlloc-
type:runtime.persistentAlloc -> type:*runtime.persistentAlloc
type:runtime.persistentAlloc -> type:*runtime.notInHeap
type:runtime.persistentAlloc -> type:.namedata.off-
type:*runtime.notInHeap -> type:.namedata.*runtime.notInHeap-
type:*runtime.notInHeap -> type:runtime.notInHeap
type:*runtime.notInHeap -> type:.namedata.add-
type:runtime.notInHeap -> type:.eqfunc.runtime.notInHeap
type:runtime.limiterEvent -> type:.eqfunc.runtime.limiterEvent
type:runtime.limiterEvent -> type:.namedata.*runtime.limiterEvent-
type:runtime.limiterEvent -> type:*runtime.limiterEvent
type:runtime.limiterEvent -> type:.namedata.stamp-
type:runtime.limiterEvent -> type:runtime/internal/atomic.Uint64
type:*runtime.limiterEvent -> type:.namedata.consume-
type:*runtime.limiterEvent -> type:.namedata.start-
type:*runtime.limiterEvent -> type:.namedata.stop-
type:runtime.gcMarkWorkerMode -> type:.namedata.*runtime.gcMarkWorkerMode-
type:runtime.gcMarkWorkerMode -> type:*runtime.gcMarkWorkerMode
type:runtime.gcWork -> type:.eqfunc.runtime.gcWork
type:runtime.gcWork -> type:.namedata.*runtime.gcWork-
type:runtime.gcWork -> type:*runtime.gcWork
type:runtime.gcWork -> type:.namedata.wbuf1-
type:runtime.gcWork -> type:*runtime.workbuf
type:runtime.gcWork -> type:.namedata.wbuf2-
type:runtime.gcWork -> type:.namedata.bytesMarked-
type:runtime.gcWork -> type:.namedata.heapScanWork-
type:runtime.gcWork -> type:.namedata.flushedWork-
type:*runtime.workbuf -> type:.namedata.*runtime.workbuf-
type:*runtime.workbuf -> type:runtime.workbuf
type:*runtime.workbuf -> type:.namedata.checkempty-
type:*runtime.workbuf -> type:.namedata.checknonempty-
type:runtime.workbuf -> type:.eqfunc.runtime.workbuf
type:runtime.workbuf -> type:.namedata.workbufhdr-.embedded
type:runtime.workbuf -> type:runtime.workbufhdr
type:runtime.workbuf -> type:.namedata.obj-
type:runtime.workbuf -> type:[253]uintptr
type:runtime.workbufhdr -> type:.namedata.*runtime.workbufhdr-
type:runtime.workbufhdr -> type:*runtime.workbufhdr
type:runtime.workbufhdr -> type:.namedata.node-
type:runtime.workbufhdr -> type:runtime.lfnode
type:runtime.workbufhdr -> type:.namedata.nobj-
type:runtime.lfnode -> type:.namedata.*runtime.lfnode-
type:runtime.lfnode -> type:*runtime.lfnode
type:runtime.lfnode -> type:.namedata.pushcnt-
type:*runtime.gcWork -> type:.namedata.balance-
type:*runtime.gcWork -> type:.namedata.dispose-
type:*runtime.gcWork -> type:.namedata.init-
type:*runtime.gcWork -> type:.namedata.put-
type:*runtime.gcWork -> type:.namedata.putBatch-
type:*runtime.gcWork -> type:.namedata.putFast-
type:*runtime.gcWork -> type:.namedata.tryGet-
type:*runtime.gcWork -> type:.namedata.tryGetFast-
type:runtime.wbBuf -> type:.eqfunc4112
type:runtime.wbBuf -> type:.namedata.*runtime.wbBuf-
type:runtime.wbBuf -> type:*runtime.wbBuf
type:runtime.wbBuf -> type:.namedata.end-
type:runtime.wbBuf -> type:[512]uintptr
type:*runtime.wbBuf -> type:.namedata.discard-
type:*runtime.wbBuf -> type:.namedata.get1-
type:*runtime.wbBuf -> type:.namedata.get2-
type:*runtime.wbBuf -> type:.namedata.reset-
type:runtime.pageTraceBuf -> type:.namedata.*runtime.pageTraceBuf-
type:runtime.pageTraceBuf -> type:*runtime.pageTraceBuf
type:*runtime.p -> type:.namedata.destroy-
type:runtime.puintptr -> type:.namedata.*runtime.puintptr-
type:runtime.puintptr -> type:*runtime.puintptr
type:runtime.m -> runtime.gcbits.11040602140000000046000000000000
type:runtime.m -> type:.namedata.*runtime.m-
type:runtime.m -> type:*runtime.m <UsedInIface>
type:runtime.m -> type:.namedata.g0-
type:runtime.m -> type:.namedata.morebuf-
type:runtime.m -> type:runtime.gobuf
type:runtime.m -> type:.namedata.divmod-
type:runtime.m -> type:.namedata.procid-
type:runtime.m -> type:.namedata.gsignal-
type:runtime.m -> type:.namedata.goSigStack-
type:runtime.m -> type:runtime.gsignalStack
type:runtime.m -> type:.namedata.sigmask-
type:runtime.m -> type:runtime.sigset
type:runtime.m -> type:.namedata.tls-
type:runtime.m -> type:[6]uintptr
type:runtime.m -> type:.namedata.mstartfn-
type:runtime.m -> type:.namedata.curg-
type:runtime.m -> type:.namedata.caughtsig-
type:runtime.m -> type:.namedata.p-
type:runtime.m -> type:.namedata.nextp-
type:runtime.m -> type:.namedata.oldp-
type:runtime.m -> type:.namedata.mallocing-
type:runtime.m -> type:.namedata.throwing-
type:runtime.m -> type:runtime.throwType
type:runtime.m -> type:.namedata.preemptoff-
type:runtime.m -> type:.namedata.locks-
type:runtime.m -> type:.namedata.dying-
type:runtime.m -> type:.namedata.profilehz-
type:runtime.m -> type:.namedata.spinning-
type:runtime.m -> type:.namedata.blocked-
type:runtime.m -> type:.namedata.newSigstack-
type:runtime.m -> type:.namedata.printlock-
type:runtime.m -> type:.namedata.incgo-
type:runtime.m -> type:.namedata.isextra-
type:runtime.m -> type:.namedata.isExtraInC-
type:runtime.m -> type:.namedata.freeWait-
type:runtime.m -> type:.namedata.fastrand-
type:runtime.m -> type:.namedata.needextram-
type:runtime.m -> type:.namedata.traceback-
type:runtime.m -> type:.namedata.ncgocall-
type:runtime.m -> type:.namedata.ncgo-
type:runtime.m -> type:.namedata.cgoCallersUse-
type:runtime.m -> type:.namedata.cgoCallers-
type:runtime.m -> type:.namedata.park-
type:runtime.m -> type:runtime.note
type:runtime.m -> type:.namedata.alllink-
type:runtime.m -> type:.namedata.schedlink-
type:runtime.m -> type:.namedata.lockedg-
type:runtime.m -> type:.namedata.createstack-
type:runtime.m -> type:[32]uintptr
type:runtime.m -> type:.namedata.lockedExt-
type:runtime.m -> type:.namedata.lockedInt-
type:runtime.m -> type:.namedata.nextwaitm-
type:runtime.m -> type:.namedata.waitunlockf-
type:runtime.m -> type:func(*runtime.g, unsafe.Pointer) bool
type:runtime.m -> type:.namedata.waitlock-
type:runtime.m -> type:.namedata.waittraceev-
type:runtime.m -> type:.namedata.waittraceskip-
type:runtime.m -> type:.namedata.freelink-
type:runtime.m -> type:runtime.mTraceState
type:runtime.m -> type:.namedata.libcall-
type:runtime.m -> type:runtime.libcall
type:runtime.m -> type:.namedata.libcallpc-
type:runtime.m -> type:.namedata.libcallsp-
type:runtime.m -> type:.namedata.libcallg-
type:runtime.m -> type:.importpath.syscall.
type:runtime.m -> type:.namedata.vdsoSP-
type:runtime.m -> type:.namedata.vdsoPC-
type:runtime.m -> type:.namedata.preemptGen-
type:runtime.m -> type:.namedata.signalPending-
type:runtime.m -> type:.namedata.dlogPerM-.embedded
type:runtime.m -> type:runtime.dlogPerM
type:runtime.m -> type:.namedata.mOS-.embedded
type:runtime.m -> type:runtime.mOS
type:runtime.m -> type:.namedata.locksHeldLen-
type:runtime.m -> type:.namedata.locksHeld-
type:runtime.m -> type:[10]runtime.heldLockInfo
type:runtime.gobuf -> type:.eqfunc56
type:runtime.gobuf -> runtime.gcbits.0800000000000000
type:runtime.gobuf -> type:.namedata.*runtime.gobuf-
type:runtime.gobuf -> type:*runtime.gobuf
type:runtime.gobuf -> type:.namedata.ctxt-
type:runtime.gobuf -> type:.namedata.ret-
type:runtime.gobuf -> type:.namedata.lr-
type:runtime.gobuf -> type:.namedata.bp-
type:runtime.gsignalStack -> type:.namedata.*runtime.gsignalStack-
type:runtime.gsignalStack -> type:*runtime.gsignalStack
type:runtime.sigset -> type:.namedata.*runtime.sigset-
type:runtime.sigset -> type:*runtime.sigset
type:runtime.throwType -> type:.namedata.*runtime.throwType-
type:runtime.throwType -> type:*runtime.throwType
type:runtime.note -> type:.namedata.*runtime.note-
type:runtime.note -> type:*runtime.note
type:runtime.mTraceState -> type:.namedata.*runtime.mTraceState-
type:runtime.mTraceState -> type:*runtime.mTraceState
type:runtime.mTraceState -> type:.namedata.startingTrace-
type:runtime.libcall -> type:.eqfunc48
type:runtime.libcall -> type:.namedata.*runtime.libcall-
type:runtime.libcall -> type:*runtime.libcall
type:runtime.libcall -> type:.namedata.n-
type:runtime.libcall -> type:.namedata.args-
type:runtime.libcall -> type:.namedata.r1-
type:runtime.libcall -> type:.namedata.r2-
type:runtime.libcall -> type:.namedata.err-
type:runtime.dlogPerM -> type:.namedata.*runtime.dlogPerM-
type:runtime.dlogPerM -> type:*runtime.dlogPerM
type:runtime.mOS -> type:.eqfunc.runtime.mOS
type:runtime.mOS -> type:.namedata.*runtime.mOS-
type:runtime.mOS -> type:*runtime.mOS
type:runtime.mOS -> type:.namedata.threadLock-
type:runtime.mOS -> type:.namedata.thread-
type:runtime.mOS -> type:.namedata.waitsema-
type:runtime.mOS -> type:.namedata.resumesema-
type:runtime.mOS -> type:.namedata.highResTimer-
type:runtime.mOS -> type:.namedata.preemptExtLock-
type:*runtime.m <UsedInIface> -> type:runtime.m <UsedInIface>
type:*runtime.m <UsedInIface> -> type:.namedata.becomeSpinning-
type:*runtime.m <UsedInIface> -> type:.namedata.hasCgoOnStack-
type:runtime.m <UsedInIface> -> type:*runtime.g <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.gobuf <UsedInIface>
type:runtime.m <UsedInIface> -> type:uint64 <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.gsignalStack <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.sigset <UsedInIface>
type:runtime.m <UsedInIface> -> type:[6]uintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.guintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.puintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:int64 <UsedInIface>
type:runtime.m <UsedInIface> -> type:int32 <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.throwType <UsedInIface>
type:runtime.m <UsedInIface> -> type:bool <UsedInIface>
type:runtime.m <UsedInIface> -> type:int8 <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime/internal/atomic.Uint32 <UsedInIface>
type:runtime.m <UsedInIface> -> type:*runtime.cgoCallers <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.note <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.muintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:[32]uintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:func(*runtime.g, unsafe.Pointer) bool <UsedInIface>
type:runtime.m <UsedInIface> -> type:int <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.mTraceState <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.libcall <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.dlogPerM <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.mOS <UsedInIface>
type:runtime.m <UsedInIface> -> type:[10]runtime.heldLockInfo <UsedInIface>
type:bool <UsedInIface> -> type:*bool <UsedInIface>
type:int <UsedInIface> -> type:*int <UsedInIface>
type:int32 <UsedInIface> -> type:*int32 <UsedInIface>
type:int64 <UsedInIface> -> type:*int64 <UsedInIface>
type:int8 <UsedInIface> -> type:*int8 <UsedInIface>
type:uint64 <UsedInIface> -> type:*uint64 <UsedInIface>
type:*runtime.cgoCallers <UsedInIface> -> type:runtime.cgoCallers <UsedInIface>
type:runtime.cgoCallers <UsedInIface> -> type:[]uintptr <UsedInIface>
type:runtime.gobuf <UsedInIface> -> type:*runtime.gobuf <UsedInIface>
type:runtime.gsignalStack <UsedInIface> -> type:*runtime.gsignalStack <UsedInIface>
type:runtime.sigset <UsedInIface> -> type:*runtime.sigset <UsedInIface>
type:runtime.muintptr <UsedInIface> -> type:*runtime.muintptr <UsedInIface>
type:runtime.puintptr <UsedInIface> -> type:*runtime.puintptr <UsedInIface>
type:runtime.throwType <UsedInIface> -> type:*runtime.throwType <UsedInIface>
type:runtime.note <UsedInIface> -> type:*runtime.note <UsedInIface>
type:runtime.mTraceState <UsedInIface> -> type:*runtime.mTraceState <UsedInIface>
type:runtime.libcall <UsedInIface> -> type:*runtime.libcall <UsedInIface>
type:runtime.dlogPerM <UsedInIface> -> type:*runtime.dlogPerM <UsedInIface>
type:runtime.mOS <UsedInIface> -> type:*runtime.mOS <UsedInIface>
type:runtime.mOS <UsedInIface> -> type:runtime.mutex <UsedInIface>
type:runtime.mutex <UsedInIface> -> type:*runtime.mutex <UsedInIface>
type:runtime.mutex <UsedInIface> -> type:runtime.lockRankStruct <UsedInIface>
type:runtime.lockRankStruct <UsedInIface> -> type:*runtime.lockRankStruct <UsedInIface>
type:runtime.g -> runtime.gcbits.7004021090190000
type:runtime.g -> type:.namedata.*runtime.g-
type:runtime.g -> type:.namedata.stack-
type:runtime.g -> type:runtime.stack
type:runtime.g -> type:.namedata.stackguard0-
type:runtime.g -> type:.namedata.stackguard1-
type:runtime.g -> type:.namedata._defer-
type:runtime.g -> type:.namedata.sched-
type:runtime.g -> type:.namedata.syscallsp-
type:runtime.g -> type:.namedata.syscallpc-
type:runtime.g -> type:.namedata.stktopsp-
type:runtime.g -> type:.namedata.param-
type:runtime.g -> type:.namedata.atomicstatus-
type:runtime.g -> type:.namedata.stackLock-
type:runtime.g -> type:.namedata.waitsince-
type:runtime.g -> type:.namedata.waitreason-
type:runtime.g -> type:runtime.waitReason
type:runtime.g -> type:.namedata.preemptStop-
type:runtime.g -> type:.namedata.preemptShrink-
type:runtime.g -> type:.namedata.asyncSafePoint-
type:runtime.g -> type:.namedata.paniconfault-
type:runtime.g -> type:.namedata.gcscandone-
type:runtime.g -> type:.namedata.throwsplit-
type:runtime.g -> type:.namedata.activeStackChans-
type:runtime.g -> type:.namedata.parkingOnChan-
type:runtime.g -> type:runtime/internal/atomic.Bool
type:runtime.g -> type:.namedata.raceignore-
type:runtime.g -> type:.namedata.tracking-
type:runtime.g -> type:.namedata.trackingSeq-
type:runtime.g -> type:.namedata.trackingStamp-
type:runtime.g -> type:.namedata.runnableTime-
type:runtime.g -> type:.namedata.lockedm-
type:runtime.g -> type:.namedata.sig-
type:runtime.g -> type:.namedata.writebuf-
type:runtime.g -> type:[]uint8
type:runtime.g -> type:.namedata.sigcode0-
type:runtime.g -> type:.namedata.sigcode1-
type:runtime.g -> type:.namedata.sigpc-
type:runtime.g -> type:.namedata.parentGoid-
type:runtime.g -> type:.namedata.ancestors-
type:runtime.g -> type:*[]runtime.ancestorInfo
type:runtime.g -> type:.namedata.startpc-
type:runtime.g -> type:.namedata.racectx-
type:runtime.g -> type:.namedata.waiting-
type:runtime.g -> type:.namedata.cgoCtxt-
type:runtime.g -> type:.namedata.labels-
type:runtime.g -> type:.namedata.timer-
type:runtime.g -> type:.namedata.selectDone-
type:runtime.g -> type:.namedata.goroutineProfiled-
type:runtime.g -> type:runtime.goroutineProfileStateHolder
type:runtime.g -> type:runtime.gTraceState
type:runtime.g -> type:.namedata.gcAssistBytes-
type:runtime.stack -> type:.namedata.*runtime.stack-
type:runtime.stack -> type:*runtime.stack
type:runtime.stack -> type:.namedata.lo-
type:runtime.stack -> type:.namedata.hi-
type:runtime.waitReason -> type:.namedata.*runtime.waitReason-
type:runtime.waitReason -> type:*runtime.waitReason
type:runtime.waitReason -> type:.namedata.String.
type:runtime.waitReason -> type:.namedata.isMutexWait-
type:runtime.goroutineProfileStateHolder -> type:.namedata.*runtime.goroutineProfileStateHolder-
type:runtime.goroutineProfileStateHolder -> type:*runtime.goroutineProfileStateHolder
type:runtime.goroutineProfileStateHolder -> type:.importpath.runtime/internal/atomic.
type:runtime.goroutineProfileStateHolder -> type:.namedata.noCopy-
type:runtime.goroutineProfileStateHolder -> type:runtime/internal/atomic.noCopy
type:runtime.goroutineProfileStateHolder -> type:.namedata.value-
type:*runtime.goroutineProfileStateHolder -> type:.namedata.CompareAndSwap.
type:*runtime.goroutineProfileStateHolder -> type:.namedata.Load.
type:*runtime.goroutineProfileStateHolder -> type:.namedata.Store.
type:runtime.gTraceState -> type:.eqfunc.runtime.gTraceState
type:runtime.gTraceState -> type:.namedata.*runtime.gTraceState-
type:runtime.gTraceState -> type:*runtime.gTraceState
type:runtime.gTraceState -> type:.namedata.sysExitTicks-
type:runtime.gTraceState -> type:.namedata.tracedSyscallEnter-
type:runtime.gTraceState -> type:.namedata.lastP-
type:*runtime.g <UsedInIface> -> type:runtime.g <UsedInIface>
type:*runtime.g <UsedInIface> -> type:.namedata.guintptr-
type:runtime.g <UsedInIface> -> type:runtime.stack <UsedInIface>
type:runtime.g <UsedInIface> -> type:*runtime._panic <UsedInIface>
type:runtime.g <UsedInIface> -> type:*runtime._defer <UsedInIface>
type:runtime.g <UsedInIface> -> type:runtime.waitReason <UsedInIface>
type:runtime.g <UsedInIface> -> type:runtime/internal/atomic.Bool <UsedInIface>
type:runtime.g <UsedInIface> -> type:[]uint8 <UsedInIface>
type:runtime.g <UsedInIface> -> type:*[]runtime.ancestorInfo <UsedInIface>
type:runtime.g <UsedInIface> -> type:*runtime.sudog <UsedInIface>
type:runtime.g <UsedInIface> -> type:*runtime.timer <UsedInIface>
type:runtime.g <UsedInIface> -> type:runtime.goroutineProfileStateHolder <UsedInIface>
type:runtime.g <UsedInIface> -> type:runtime.gTraceState <UsedInIface>
type:*runtime._panic <UsedInIface> -> type:runtime._panic <UsedInIface>
type:runtime._panic <UsedInIface> -> type:interface {} <UsedInIface>
type:*runtime._defer <UsedInIface> -> type:runtime._defer <UsedInIface>
type:runtime.stack <UsedInIface> -> type:*runtime.stack <UsedInIface>
type:*runtime.sudog <UsedInIface> -> type:runtime.sudog <UsedInIface>
type:runtime.sudog <UsedInIface> -> type:*runtime.hchan <UsedInIface>
type:*runtime.hchan <UsedInIface> -> type:runtime.hchan <UsedInIface>
type:runtime.hchan <UsedInIface> -> type:uint <UsedInIface>
type:runtime.hchan <UsedInIface> -> type:uint16 <UsedInIface>
type:runtime.hchan <UsedInIface> -> type:runtime.waitq <UsedInIface>
type:uint <UsedInIface> -> type:*uint <UsedInIface>
type:uint16 <UsedInIface> -> type:*uint16 <UsedInIface>
type:runtime.waitq <UsedInIface> -> type:*runtime.waitq <UsedInIface>
type:*runtime.timer <UsedInIface> -> type:runtime.timer <UsedInIface>
type:runtime.timer <UsedInIface> -> type:func(interface {}, uintptr) <UsedInIface>
type:runtime.waitReason <UsedInIface> -> type:*runtime.waitReason <UsedInIface>
type:runtime.goroutineProfileStateHolder <UsedInIface> -> type:*runtime.goroutineProfileStateHolder <UsedInIface>
type:runtime.goroutineProfileStateHolder <UsedInIface> -> type:runtime/internal/atomic.noCopy <UsedInIface>
type:runtime.gTraceState <UsedInIface> -> type:*runtime.gTraceState <UsedInIface>
type:runtime.guintptr <UsedInIface> -> type:.namedata.*runtime.guintptr-
type:runtime.guintptr <UsedInIface> -> type:*runtime.guintptr <UsedInIface>
type:*runtime.guintptr <UsedInIface> -> type:.namedata.cas-
type:runtime.stringer -> type:.namedata.*runtime.stringer-
type:runtime.stringer -> type:*runtime.stringer
 -> go:info.*runtime.mspan
 -> go:info.*runtime.heapStatsDelta
 -> go:info.runtime.makeSpanClass$abstract
 -> go:info.runtime.bool2int$abstract
 -> go:info.runtime.(*mspan).base$abstract
 -> go:info.runtime.sysFault$abstract
 -> go:info.runtime.sysFaultOS$abstract
 -> go:info.*[2]uintptr
 -> go:info.runtime.(*wbBuf).get2$abstract
 -> go:info.interface {}
 -> go:info.float32
 -> go:info.float64
 -> go:info.complex64
 -> go:info.complex128
 -> go:info.*internal/abi.InterfaceType
 -> go:info.*runtime.itab
 -> go:info.runtime.rtype.nameOff$abstract
 -> go:info.**runtime.itab
 -> go:info.runtime.itabHashFunc$abstract
 -> go:info.runtime.atomicstorep$abstract
 -> go:info.*internal/abi.UncommonType
 -> go:info.[]internal/abi.Method
 -> go:info.runtime.rtype
 -> go:info.internal/abi.(*Type).Uncommon$abstract
 -> go:info.internal/abi.(*Type).Kind$abstract
 -> go:info.runtime.rtype.typeOff$abstract
 -> go:info.internal/abi.Name.IsExported$abstract
 -> go:info.runtime.eface
 -> go:info.runtime.iface
 -> go:info.func(*runtime.itab)
 -> go:info.*runtime.lfstack
 -> go:info.*runtime.lfnode
 -> go:info.runtime.lfstackPack$abstract
 -> go:info.runtime.taggedPointerPack$abstract
 -> go:info.runtime.lfstackUnpack$abstract
 -> go:info.runtime.taggedPointer.pointer$abstract
 -> go:info.*runtime.note
 -> go:info.*runtime.mheap
 -> go:info.**runtime.arenaHint
 -> go:info.*runtime.arenaHint
 -> go:info.runtime.arenaIdx
 -> go:info.*[1048576]*runtime.heapArena
 -> go:info.*runtime.heapArena
 -> go:info.[]runtime.arenaIdx
 -> go:info.runtime.alignUp$abstract
 -> go:info.runtime.(*fixalloc).free$abstract
 -> go:info.runtime.arenaIndex$abstract
 -> go:info.runtime.arenaIdx.l1$abstract
 -> go:info.runtime.sysAllocOS$abstract
 -> go:info.runtime.sysHugePage$abstract
 -> go:info.runtime.arenaIdx.l2$abstract
 -> go:info.runtime.sysReserve$abstract
 -> go:info.runtime.spanClass
 -> go:info.runtime.gclinkptr
 -> go:info.runtime.gcTrigger
 -> go:info.runtime.acquirem$abstract
 -> go:info.runtime.getMCache$abstract
 -> go:info.runtime.releasem$abstract
 -> go:info.runtime.nextFreeFast$abstract
 -> go:info.runtime.divRoundUp$abstract
 -> go:info.runtime.goschedguarded$abstract
 -> go:info.runtime.newobject$abstract
 -> go:info.runtime.nextSample$abstract
 -> go:info.runtime.fastlog2$abstract
 -> go:info.runtime.float64bits$abstract
 -> go:info.*runtime.sysMemStat
 -> go:info.**runtime.notInHeap
 -> go:info.*runtime.persistentAlloc
 -> go:info.runtime.(*notInHeap).add$abstract
 -> go:info.*runtime.linearAlloc
 -> go:info.runtime.sysMap$abstract
 -> go:info.runtime.sysUsed$abstract
 -> go:info.*internal/abi.MapType
 -> go:info.*runtime.hmap
 -> go:info.*runtime.bmap
 -> go:info.runtime.bucketMask$abstract
 -> go:info.runtime.bucketShift$abstract
 -> go:info.runtime.(*hmap).sameSizeGrow$abstract
 -> go:info.runtime.evacuated$abstract
 -> go:info.runtime.(*bmap).overflow$abstract
 -> go:info.runtime.(*bmap).keys$abstract
 -> go:info.runtime.(*gcBits).bytep$abstract
 -> go:info.runtime.mSpanState
 -> go:info.runtime.(*mSpanStateBox).get$abstract
 -> go:info.runtime.spanOf$abstract
 -> go:info.runtime.(*mspan).objIndex$abstract
 -> go:info.runtime.(*mspan).divideByElemSize$abstract
 -> go:info.runtime.heapBits
 -> go:info.*[1]uintptr
 -> go:info.runtime.activeModules$abstract
 -> go:info.runtime.(*wbBuf).get1$abstract
 -> go:info.runtime.addb$abstract
 -> go:info.runtime.writeHeapBits
 -> go:info.runtime.spanClass.noscan$abstract
 -> go:info.runtime.writeHeapBitsForAddr$abstract
 -> go:info.runtime.readUintptr$abstract
 -> go:info.runtime.add1$abstract
 -> go:info.runtime.subtract1$abstract
 -> go:info.runtime.subtractb$abstract
 -> go:info.**runtime.mcache
 -> go:info.runtime.spanClass.sizeclass$abstract
 -> go:info.runtime.(*mcentral).fullSwept$abstract
 -> go:info.*runtime.mcentral
 -> go:info.runtime.sweepLocker
 -> go:info.runtime.sweepLocked
 -> go:info.runtime.(*mcentral).partialSwept$abstract
 -> go:info.runtime.(*activeSweep).begin$abstract
 -> go:info.runtime.(*mcentral).partialUnswept$abstract
 -> go:info.runtime.(*mcentral).fullUnswept$abstract
 -> go:info.runtime.markBits
 -> go:info.runtime.markBits.isMarked$abstract
 -> go:info.*runtime.funcval
 -> go:info.*internal/abi.PtrType
 -> go:info.runtime/internal/atomic.(*Uint32).Or$abstract
 -> go:info.*runtime.fixalloc
 -> go:info.runtime/internal/atomic.(*Uint64).Load$abstract
 -> go:info.runtime.gcMode
 -> go:info.runtime.semacquire$abstract
 -> go:info.runtime.traceGCStart$abstract
 -> go:info.runtime.semrelease$abstract
 -> go:info.runtime.traceGCSTWStart$abstract
 -> go:info.runtime.setGCPhase$abstract
 -> go:info.runtime.gcBgMarkPrepare$abstract
 -> go:info.runtime.Gosched$abstract
 -> go:info.*int64
 -> go:info.runtime.gcMarkWorkAvailable$abstract
 -> go:info.runtime.(*lfstack).empty$abstract
 -> go:info.*bool
 -> go:info.runtime.(*gcWork).empty$abstract
 -> go:info.[]runtime.liveUserArenaChunk
 -> go:info.[24]uint8
 -> go:info.runtime.casGToWaiting$abstract
 -> go:info.runtime.traceGCDone$abstract
 -> go:info.runtime.(*sysMemStat).load$abstract
 -> go:info.runtime/internal/atomic.(*Int64).Load$abstract
 -> go:info.runtime/internal/atomic.(*Int64).Store$abstract
 -> go:info.runtime.mProf_NextCycle$abstract
 -> go:info.runtime.(*mProfCycleHolder).increment$abstract
 -> go:info.runtime.itoaDiv$abstract
 -> go:info.runtime.(*gcControllerState).heapGoal$abstract
 -> go:info.runtime.noteclear$abstract
 -> go:info.*runtime.gcWork
 -> go:info.*runtime.sudog
 -> go:info.*runtime._defer
 -> go:info.*runtime.gcCPULimiterState
 -> go:info.runtime.(*gcCPULimiterState).tryLock$abstract
 -> go:info.runtime.limiterEventType
 -> go:info.*runtime.limiterEvent
 -> go:info.runtime.limiterEventStamp
 -> go:info.runtime.limiterEventStamp.typ$abstract
 -> go:info.runtime.limiterEventStamp.duration$abstract
 -> go:info.runtime.makeLimiterEventStamp$abstract
 -> go:info.runtime/internal/atomic.(*Uint64).CompareAndSwap$abstract
 -> go:info.runtime.(*gcCPULimiterState).addIdleTime$abstract
 -> go:info.runtime.(*gcCPULimiterState).addAssistTime$abstract
 -> go:info.runtime.gcMarkRootPrepare.func1$abstract
 -> go:info.runtime.allGsSnapshot$abstract
 -> go:info.*runtime/internal/atomic.Int64
 -> go:info.**runtime.moduledata
 -> go:info.*runtime.special
 -> go:info.*runtime.specialfinalizer
 -> go:info.runtime.(*gcCPULimiterState).limiting$abstract
 -> go:info.runtime/internal/atomic.(*Float64).Load$abstract
 -> go:info.runtime.traceGCMarkAssistStart$abstract
 -> go:info.runtime.traceGCMarkAssistDone$abstract
 -> go:info.runtime.(*limiterEvent).start$abstract
 -> go:info.runtime/internal/atomic.(*Uint64).Store$abstract
 -> go:info.runtime.gList
 -> go:info.runtime.(*gQueue).popList$abstract
 -> go:info.runtime.(*gQueue).pushBack$abstract
 -> go:info.runtime.goparkunlock$abstract
 -> go:info.runtime.(*gQueue).empty$abstract
 -> go:info.runtime.(*gQueue).pop$abstract
 -> go:info.runtime.stackScanState
 -> go:info.*runtime.stackObject
 -> go:info.*runtime.stackObjectRecord
 -> go:info.runtime.isShrinkStackSafe$abstract
 -> go:info.runtime.(*unwinder).init$abstract
 -> go:info.runtime.(*stackScanState).buildIndex$abstract
 -> go:info.runtime.(*stackScanState).findObject$abstract
 -> go:info.runtime.(*stackObject).setRecord$abstract
 -> go:info.runtime.(*stackObjectRecord).gcdata$abstract
 -> go:info.runtime.(*stackObjectRecord).useGCProg$abstract
 -> go:info.runtime.(*stackObjectRecord).ptrdata$abstract
 -> go:info.runtime.dematerializeGCProg$abstract
 -> go:info.*runtime.stackScanState
 -> go:info.[]runtime.stackObjectRecord
 -> go:info.runtime.(*gcWork).tryGetFast$abstract
 -> go:info.runtime.spanOfUnchecked$abstract
 -> go:info.runtime.heapBits.nextFast$abstract
 -> go:info.runtime.(*gcWork).putFast$abstract
 -> go:info.runtime.(*mspan).isFree$abstract
 -> go:info.runtime.(*gcBits).bitp$abstract
 -> go:info.runtime.(*mspan).markBitsForIndex$abstract
 -> go:info.runtime.markBits.setMarked$abstract
 -> go:info.runtime.pageIndexOf$abstract
 -> go:info.*runtime.gcControllerState
 -> go:info.runtime/internal/atomic.(*Float64).Store$abstract
 -> go:info.runtime.traceHeapAlloc$abstract
 -> go:info.*runtime.pageAlloc
 -> go:info.func() bool
 -> go:info.runtime.chunkIdx
 -> go:info.runtime.pallocSum.max$abstract
 -> go:info.runtime.(*pageAlloc).chunkOf$abstract
 -> go:info.runtime.chunkIdx.l1$abstract
 -> go:info.runtime.chunkIdx.l2$abstract
 -> go:info.runtime.chunkBase$abstract
 -> go:info.runtime.sysUnused$abstract
 -> go:info.runtime.offAddr.lessThan$abstract
 -> go:info.runtime.(*pallocBits).free$abstract
 -> go:info.runtime.fillAligned.func1$abstract
 -> go:info.*runtime.pallocData
 -> go:info.runtime/internal/sys.LeadingZeros64$abstract
 -> go:info.runtime.alignDown$abstract
 -> go:info.*runtime.scavengeIndex
 -> go:info.runtime.chunkIndex$abstract
 -> go:info.runtime/internal/atomic.(*Uintptr).Store$abstract
 -> go:info.*runtime.atomicOffAddr
 -> go:info.runtime.(*atomicOffAddr).Load$abstract
 -> go:info.runtime/internal/atomic.(*Uintptr).Load$abstract
 -> go:info.runtime.chunkPageIndex$abstract
 -> go:info.runtime.(*atomicOffAddr).StoreUnmark$abstract
 -> go:info.runtime/internal/atomic.(*Int64).CompareAndSwap$abstract
 -> go:info.runtime.(*atomicScavChunkData).load$abstract
 -> go:info.runtime.unpackScavChunkData$abstract
 -> go:info.runtime.scavChunkData.shouldScavenge$abstract
 -> go:info.runtime.(*scavChunkFlags).isEmpty$abstract
 -> go:info.runtime.(*atomicOffAddr).StoreMin$abstract
 -> go:info.runtime.(*atomicOffAddr).Clear$abstract
 -> go:info.runtime.scavChunkData
 -> go:info.runtime.(*scavChunkFlags).isHugePage$abstract
 -> go:info.runtime.(*scavChunkFlags).setHugePage$abstract
 -> go:info.runtime.(*atomicScavChunkData).store$abstract
 -> go:info.runtime.scavChunkData.pack$abstract
 -> go:info.runtime.(*atomicOffAddr).StoreMarked$abstract
 -> go:info.runtime.(*scavChunkFlags).setEmpty$abstract
 -> go:info.runtime.(*scavChunkFlags).setNoHugePage$abstract
 -> go:info.*runtime.scavChunkData
 -> go:info.runtime.(*scavChunkFlags).setNonEmpty$abstract
 -> go:info.**runtime.stackWorkBuf
 -> go:info.*runtime.stackWorkBuf
 -> go:info.*runtime.stackObjectBuf
 -> go:info.runtime.sweepClass
 -> go:info.runtime.(*sweepClass).load$abstract
 -> go:info.runtime.sweepClass.split$abstract
 -> go:info.runtime.(*sweepClass).update$abstract
 -> go:info.*runtime.activeSweep
 -> go:info.*runtime.sweepLocker
 -> go:info.runtime/internal/atomic.(*Uintptr).Add$abstract
 -> go:info.runtime.(*activeSweep).markDrained$abstract
 -> go:info.runtime.(*scavengerState).ready$abstract
 -> go:info.*runtime.sweepLocked
 -> go:info.uint16
 -> go:info.runtime.specialsIter
 -> go:info.runtime.(*specialsIter).valid$abstract
 -> go:info.runtime.(*specialsIter).next$abstract
 -> go:info.runtime.(*specialsIter).unlinkAndNext$abstract
 -> go:info.runtime.markBits.setMarkedNonAtomic$abstract
 -> go:info.runtime.spanHasNoSpecials$abstract
 -> go:info.runtime.(*mspan).markBitsForBase$abstract
 -> go:info.runtime.(*mspan).allocBitsForIndex$abstract
 -> go:info.runtime.(*mspan).countAlloc$abstract
 -> go:info.runtime.(*mSpanStateBox).set$abstract
 -> go:info.runtime.(*mheap).freeSpan$abstract
 -> go:info.runtime.(*markBits).advance$abstract
 -> go:info.runtime.clobberfree$abstract
 -> go:info.*runtime.workbuf
 -> go:info.runtime.(*lfstack).pop$abstract
 -> go:info.**runtime.mspan
 -> go:info.runtime.(*mSpanList).takeAll$abstract
 -> go:info.runtime.(*mSpanList).isEmpty$abstract
 -> go:info.runtime/internal/atomic.(*Uintptr).CompareAndSwap$abstract
 -> go:info.runtime.isSweepDone$abstract
 -> go:info.runtime.(*activeSweep).isDone$abstract
 -> go:info.runtime.spanAllocType
 -> go:info.runtime.spanAllocType.manual$abstract
 -> go:info.*runtime.pageCache
 -> go:info.runtime.(*pageCache).empty$abstract
 -> go:info.runtime.(*mheap).tryAllocMSpan$abstract
 -> go:info.runtime.heapRetained$abstract
 -> go:info.runtime.(*mspan).init$abstract
 -> go:info.runtime.newAllocBits$abstract
 -> go:info.runtime.(*mheap).freeMSpanLocked$abstract
 -> go:info.*runtime.mSpanList
 -> go:info.**runtime.special
 -> go:info.runtime.spanHasSpecials$abstract
 -> go:info.*runtime.bucket
 -> go:info.*runtime.specialprofile
 -> go:info.*runtime.specialReachable
 -> go:info.*runtime.gcBits
 -> go:info.*runtime.gcBitsArena
 -> go:info.runtime.(*gcBitsArena).tryAlloc$abstract
 -> go:info.runtime.addrRanges
 -> go:info.runtime.pallocSum
 -> go:info.[]runtime.pallocSum
 -> go:info.runtime.addrsToSummaryRange$abstract
 -> go:info.runtime.(*pallocData).allocAll$abstract
 -> go:info.runtime.(*pageBits).clearAll$abstract
 -> go:info.runtime.(*pallocBits).allocAll$abstract
 -> go:info.runtime.(*pageBits).setAll$abstract
 -> go:info.func(runtime.offAddr, uintptr)
 -> go:info.struct { runtime.base runtime.offAddr; runtime.bound runtime.offAddr }
 -> go:info.runtime.offAddrToLevelIndex$abstract
 -> go:info.runtime.pallocSum.start$abstract
 -> go:info.runtime.pallocSum.end$abstract
 -> go:info.runtime.levelIndexToOffAddr$abstract
 -> go:info.runtime.offAddr.add$abstract
 -> go:info.*struct { runtime.base runtime.offAddr; runtime.bound runtime.offAddr }
 -> go:info.runtime.offAddr.lessEqual$abstract
 -> go:info.runtime.(*pallocBits).free1$abstract
 -> go:info.runtime.(*pageBits).clear$abstract
 -> go:info.runtime.(*pallocBits).freeAll$abstract
 -> go:info.runtime.pallocSum.unpack$abstract
 -> go:info.runtime.packPallocSum$abstract
 -> go:info.func(int, runtime.addrRange) (int, int)
 -> go:info.func(int, int, int) runtime.addrRange
 -> go:info.func(int, runtime.addrRange) runtime.addrRange
 -> go:info.runtime.addrRange
 -> go:info.runtime.(*pageAlloc).sysGrow.func2$abstract
 -> go:info.runtime.addrRange.size$abstract
 -> go:info.runtime.offAddr.diff$abstract
 -> go:info.runtime.findBitRange64$abstract
 -> go:info.runtime.pageCache
 -> go:info.runtime.(*pallocBits).pages64$abstract
 -> go:info.runtime.(*pageBits).block64$abstract
 -> go:info.runtime.(*pallocBits).allocPages64$abstract
 -> go:info.runtime.(*pageBits).setBlock64$abstract
 -> go:info.runtime.(*pageBits).clearBlock64$abstract
 -> go:info.*runtime.pageBits
 -> go:info.runtime.(*pageBits).set$abstract
 -> go:info.*runtime.pallocBits
 -> go:info.runtime.(*pallocBits).find1$abstract
 -> go:info.runtime.(*pallocBits).allocRange$abstract
 -> go:info.runtime.bucketType
 -> go:info.*runtime.memRecord
 -> go:info.*runtime.blockRecord
 -> go:info.*runtime.buckhashArray
 -> go:info.*runtime/internal/atomic.UnsafePointer
 -> go:info.runtime/internal/atomic.(*UnsafePointer).Load$abstract
 -> go:info.runtime/internal/atomic.(*UnsafePointer).StoreNoWB$abstract
 -> go:info.runtime.(*bucket).stk$abstract
 -> go:info.runtime.eqslice$abstract
 -> go:info.runtime.(*mProfCycleHolder).setFlushed$abstract
 -> go:info.runtime.(*memRecordCycle).add$abstract
 -> go:info.runtime.(*mProfCycleHolder).read$abstract
 -> go:info.runtime.blocksampled$abstract
 -> go:info.runtime.goroutineProfileState
 -> go:info.runtime.(*goroutineProfileStateHolder).Load$abstract
 -> go:info.runtime.(*goroutineProfileStateHolder).CompareAndSwap$abstract
 -> go:info.runtime.(*goroutineProfileStateHolder).Store$abstract
 -> go:info.*runtime.StackRecord
 -> go:info.*runtime.addrRanges
 -> go:info.runtime.addrRange.contains$abstract
 -> go:info.runtime.offAddr.equal$abstract
 -> go:info.*runtime.spanSet
 -> go:info.*runtime.spanSetBlock
 -> go:info.runtime.spanSetSpinePointer
 -> go:info.runtime.(*atomicSpanSetSpinePointer).Load$abstract
 -> go:info.runtime.(*atomicSpanSetSpinePointer).StoreNoWB$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]).StoreNoWB$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]).Load$abstract
 -> go:info.runtime.(*atomicMSpanPointer).StoreNoWB$abstract
 -> go:info.runtime.headTailIndex
 -> go:info.runtime.(*atomicHeadTailIndex).load$abstract
 -> go:info.runtime.headTailIndex.split$abstract
 -> go:info.runtime.headTailIndex.head$abstract
 -> go:info.runtime.(*atomicHeadTailIndex).cas$abstract
 -> go:info.runtime.makeHeadTailIndex$abstract
 -> go:info.runtime.(*atomicMSpanPointer).Load$abstract
 -> go:info.runtime.(*spanSetBlockAlloc).free$abstract
 -> go:info.*runtime.spanSetBlockAlloc
 -> go:info.*runtime.atomicHeadTailIndex
 -> go:info.*runtime.consistentHeapStats
 -> go:info.*runtime.wbBuf
 -> go:info.runtime.(*wbBuf).discard$abstract
 -> go:info.*runtime.gList
 -> go:info.*runtime.pollDesc
 -> go:info.runtime.netpollunblock$abstract
 -> go:info.runtime.(*gList).push$abstract
 -> go:info.*runtime.net_op
 -> go:info.[64]runtime.overlappedEntry
 -> go:info.runtime.pageTraceFree$abstract
 -> go:info.*runtime._panic
 -> go:info.runtime.stringer
 -> go:info.runtime.readvarintUnsafe$abstract
 -> go:info.runtime._panic
 -> go:info.runtime.suspendGState
 -> go:info.runtime.dumpgstatus$abstract
 -> go:info.[14]uint8
 -> go:info.func(*runtime.g, unsafe.Pointer) bool
 -> go:info.runtime.int64Hash$abstract
 -> go:info.runtime.netpollinited$abstract
 -> go:info.runtime.traceGCSTWDone$abstract
 -> go:info.**runtime.m
 -> go:info.runtime.(*muintptr).set$abstract
 -> go:info.runtime.cgothreadstart
 -> go:info.runtime.mget$abstract
 -> go:info.runtime.runqempty$abstract
 -> go:info.runtime/internal/atomic.(*Int32).CompareAndSwap$abstract
 -> go:info.runtime/internal/atomic.(*Int32).Add$abstract
 -> go:info.func(int)
 -> go:info.runtime.gQueue
 -> go:info.runtime.(*gList).empty$abstract
 -> go:info.runtime.globrunqputbatch$abstract
 -> go:info.runtime.(*gQueue).pushBackAll$abstract
 -> go:info.runtime.schedEnabled$abstract
 -> go:info.runtime.round2$abstract
 -> go:info.runtime.(*gcControllerState).addScannableStack$abstract
 -> go:info.*[]runtime.ancestorInfo
 -> go:info.[]runtime.ancestorInfo
 -> go:info.[50]uintptr
 -> go:info.runtime.(*gList).pop$abstract
 -> go:info.runtime.(*gQueue).push$abstract
 -> go:info.runtime.(*gList).pushAll$abstract
 -> go:info.runtime.pMask.set$abstract
 -> go:info.runtime.pMask.clear$abstract
 -> go:info.runtime.globrunqputhead$abstract
 -> go:info.runtime.freemcache$abstract
 -> go:info.[]uint32
 -> go:info.runtime.traceGomaxprocs$abstract
 -> go:info.runtime.traceGoSched$abstract
 -> go:info.runtime.(*randomOrder).reset$abstract
 -> go:info.runtime.gcd$abstract
 -> go:info.runtime.traceProcStart$abstract
 -> go:info.runtime.(*guintptr).cas$abstract
 -> go:info.[129]*runtime.g
 -> go:info.*runtime.gQueue
 -> go:info.*func()
 -> go:info.*func(string) func()
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.func()]).Load$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string) func()]).Load$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.func()]).Store$abstract
 -> go:info.runtime/internal/atomic.(*UnsafePointer).Store$abstract
 -> go:info.*runtime.rwmutex
 -> go:info.runtime.goready$abstract
 -> go:info.*uint32
 -> go:info.runtime.semaProfileFlags
 -> go:info.*runtime.semaRoot
 -> go:info.runtime.cansemacquire$abstract
 -> go:info.runtime.(*semTable).rootFor$abstract
 -> go:info.runtime.goyield$abstract
 -> go:info.**runtime.sudog
 -> go:info.runtime.panicmakeslicelen$abstract
 -> go:info.runtime.panicmakeslicecap$abstract
 -> go:info.runtime.slice
 -> go:info.runtime.roundupsize$abstract
 -> go:info.runtime.isPowerOfTwo$abstract
 -> go:info.runtime.gclinkptr.ptr$abstract
 -> go:info.runtime.stacklog2$abstract
 -> go:info.*runtime.bitvector
 -> go:info.*runtime.adjustinfo
 -> go:info.runtime.bitvector
 -> go:info.runtime.adjustpointer$abstract
 -> go:info.*runtime.hchan
 -> go:info.runtime.adjustsudogs$abstract
 -> go:info.runtime.adjustinfo
 -> go:info.runtime.fillstack$abstract
 -> go:info.runtime.findsghi$abstract
 -> go:info.runtime.adjustpanics$abstract
 -> go:info.*runtime.gobuf
 -> go:info.runtime.gostartcall$abstract
 -> go:info.*runtime.reflectMethodValue
 -> go:info.*runtime.stackmap
 -> go:info.runtime.stackmapdata$abstract
 -> go:info.*runtime.tmpBuf
 -> go:info.runtime.stringDataOnStack$abstract
 -> go:info.runtime.rawstring$abstract
 -> go:info.*runtime.timer
 -> go:info.[]*runtime.timer
 -> go:info.runtime.traceBufPtr
 -> go:info.runtime.traceFullQueue$abstract
 -> go:info.runtime.traceBufPtr.ptr$abstract
 -> go:info.[]uint64
 -> go:info.*runtime.traceBufPtr
 -> go:info.*runtime.traceBuf
 -> go:info.runtime.(*traceBufPtr).set$abstract
 -> go:info.runtime.(*traceBuf).byte$abstract
 -> go:info.runtime.(*traceBuf).varint$abstract
 -> go:info.**runtime.traceBuf
 -> go:info.runtime.tracefpunwindoff$abstract
 -> go:info.runtime.(*m).hasCgoOnStack$abstract
 -> go:info.runtime.fpTracebackPCs$abstract
 -> go:info.runtime.lockRankMayTraceFlush$abstract
 -> go:info.*runtime.traceStackTable
 -> go:info.runtime.(*traceStackTable).find$abstract
 -> go:info.runtime.(*traceStack).stack$abstract
 -> go:info.*runtime.traceStack
 -> go:info.runtime.(*traceStackTable).newStack$abstract
 -> go:info.*runtime.traceAlloc
 -> go:info.*runtime.traceAllocBlock
 -> go:info.runtime.(*traceAllocBlockPtr).set$abstract
 -> go:info.internal/abi.NameOff
 -> go:info.runtime.reflectOffsLock$abstract
 -> go:info.runtime.reflectOffsUnlock$abstract
 -> go:info.internal/abi.TypeOff
 -> go:info.internal/abi.TextOff
 -> go:info.internal/abi.Name.Data$abstract
 -> go:info.runtime.panicunsafestringlen$abstract
 -> go:info.runtime.panicunsafestringnilptr$abstract
type:runtime/internal/atomic.noCopy <UsedInIface> -> type:.namedata.*atomic.noCopy-
type:runtime/internal/atomic.noCopy <UsedInIface> -> type:*runtime/internal/atomic.noCopy <UsedInIface>
type:*runtime/internal/atomic.noCopy <UsedInIface> -> type:.namedata.Lock.
type:*runtime/internal/atomic.noCopy <UsedInIface> -> type:.namedata.Unlock.
type:runtime/internal/atomic.Bool <UsedInIface> -> type:.namedata.*atomic.Bool.
type:runtime/internal/atomic.Bool <UsedInIface> -> type:*runtime/internal/atomic.Bool <UsedInIface>
type:runtime/internal/atomic.Bool <UsedInIface> -> type:.namedata.u-
type:runtime/internal/atomic.Bool <UsedInIface> -> type:runtime/internal/atomic.Uint8 <UsedInIface>
type:runtime/internal/atomic.Uint8 <UsedInIface> -> type:.namedata.*atomic.Uint8.
type:runtime/internal/atomic.Uint8 <UsedInIface> -> type:*runtime/internal/atomic.Uint8 <UsedInIface>
type:*runtime/internal/atomic.Uint8 <UsedInIface> -> type:.namedata.And.
type:*runtime/internal/atomic.Uint8 <UsedInIface> -> type:.namedata.Or.
type:runtime/internal/atomic.Uint64 -> type:.eqfunc.runtime/internal/atomic.Uint64
type:runtime/internal/atomic.Uint64 -> type:.namedata.*atomic.Uint64.
type:runtime/internal/atomic.Uint64 -> type:*runtime/internal/atomic.Uint64
type:runtime/internal/atomic.Uint64 -> type:runtime/internal/atomic.align64
type:runtime/internal/atomic.align64 -> type:.namedata.*atomic.align64-
type:runtime/internal/atomic.align64 -> type:*runtime/internal/atomic.align64
type:*runtime/internal/atomic.Uint64 -> type:.namedata.Add.
type:*runtime/internal/atomic.Uint64 -> type:.namedata.LoadAcquire.
type:*runtime/internal/atomic.Uint64 -> type:.namedata.StoreRelease.
type:*runtime/internal/atomic.Uint64 -> type:.namedata.Swap.
type:runtime/internal/atomic.Int64 -> type:.eqfunc.runtime/internal/atomic.Int64
type:runtime/internal/atomic.Int64 -> type:.namedata.*atomic.Int64.
type:runtime/internal/atomic.Int64 -> type:*runtime/internal/atomic.Int64
type:runtime/internal/atomic.Uint32 <UsedInIface> -> type:.namedata.*atomic.Uint32.
type:runtime/internal/atomic.Uint32 <UsedInIface> -> type:*runtime/internal/atomic.Uint32 <UsedInIface>
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> type:.namedata.CompareAndSwapRelease.
type:runtime/internal/sys.NotInHeap -> type:.eqfunc.runtime/internal/sys.NotInHeap
type:runtime/internal/sys.NotInHeap -> type:.namedata.*sys.NotInHeap.
type:runtime/internal/sys.NotInHeap -> type:*runtime/internal/sys.NotInHeap
type:runtime/internal/sys.NotInHeap -> type:.importpath.runtime/internal/sys.
type:runtime/internal/sys.NotInHeap -> type:runtime/internal/sys.nih
type:runtime/internal/sys.nih -> type:.namedata.*sys.nih-
type:runtime/internal/sys.nih -> type:*runtime/internal/sys.nih
runtime.memequal64·f -> runtime.memequal64
runtime.memequal32·f -> runtime.memequal32
type:func() <UsedInIface> -> type:.namedata.*func()-
runtime.interequal·f -> runtime.interequal
runtime.interequal -> runtime.ifaceeq
runtime.ifaceeq -> go:string."comparing uncomparable type "
runtime.ifaceeq -> runtime.concatstring2
runtime.concatstring2 -> gclocals·hYXh8R94h8YSj6dF425rfQ==
runtime.concatstring2 -> runtime.concatstring2.stkobj
runtime.concatstring2 -> fmt.(*fmt).fmtSx.arginfo1
 -> go:info.func(unsafe.Pointer, unsafe.Pointer) bool
 -> go:info.runtime.isDirectIface$abstract
type:func() string <UsedInIface> -> type:.namedata.*func() string-
runtime.strequal·f -> runtime.strequal
runtime.memequal128·f -> runtime.memequal128
type:.eqfunc24 -> runtime.memequal_varlen
type:[2]uintptr -> type:.namedata.*[2]uintptr-
runtime.memequal0·f -> runtime.memequal0
runtime.memequal16·f -> runtime.memequal16
type:func(unsafe.Pointer, unsafe.Pointer) bool <UsedInIface> -> type:.namedata.*func(unsafe.Pointer, unsafe.Pointer) bool-
runtime.memequal8·f -> runtime.memequal8
runtime..stmp_107 -> go:string."non-empty mark queue after concurrent mark"
runtime..stmp_113 -> go:string."Bad varint"
runtime..stmp_123 -> go:string."semaRoot queue"
runtime..stmp_124 -> go:string."makeslice: len out of range"
runtime..stmp_125 -> go:string."makeslice: cap out of range"
runtime..stmp_131 -> go:string."growslice: len out of range"
runtime..stmp_150 -> go:string."unsafe.String: len out of range"
runtime..stmp_151 -> go:string."unsafe.String: ptr is nil and len is not zero"
runtime.persistentalloc.stkobj -> runtime.gcbits.1200000000000000
runtime.markroot.stkobj -> runtime.gcbits.0e00000000000000
runtime.(*pageAlloc).enableChunkHugePages.stkobj -> runtime.gcbits.1100000000000000
runtime.netpoll.stkobj -> runtime.gcbits.2222222222222222222222222222222222222222222222222222222222222222
runtime.addOneOpenDeferFrame.stkobj -> runtime.gcbits.1c00000000000000
runtime.entersyscallblock.stkobj -> runtime.gcbits.1000000000000000
runtime.concatstring2.stkobj -> runtime.gcbits.0500000000000000
runtime.concatstring3.stkobj -> runtime.gcbits.1500000000000000
runtime.callers.stkobj -> runtime.gcbits.5800000000000000
runtime.morestackc -> runtime.morestackc
runtime.morestackc -> go:string."attempt to execute system stack code on user stack"
go:info.runtime/internal/atomic.(*Uint64).Add$abstract -> go:info.*runtime/internal/atomic.Uint64
go:info.runtime.(*mSpanStateBox).get$abstract -> go:info.*runtime.mSpanStateBox
go:info.runtime.taggedPointer.pointer$abstract -> go:info.runtime.taggedPointer
go:info.runtime.(*scavChunkFlags).isEmpty$abstract -> go:info.*runtime.scavChunkFlags
go:info.runtime/internal/atomic.(*Uintptr).Load$abstract -> go:info.*runtime/internal/atomic.Uintptr
go:info.runtime.(*atomicScavChunkData).load$abstract -> go:info.*runtime.atomicScavChunkData
go:info.runtime.(*fixalloc).free$abstract -> go:info.*runtime.mlink
go:info.runtime/internal/atomic.(*Float64).Store$abstract -> go:info.*runtime/internal/atomic.Float64
go:info.runtime.(*muintptr).set$abstract -> go:info.*runtime.muintptr
go:info.runtime.(*puintptr).set$abstract -> go:info.*runtime.puintptr
go:info.runtime.(*traceAllocBlockPtr).set$abstract -> go:info.*runtime.traceAllocBlockPtr
go:info.runtime.(*specialsIter).valid$abstract -> go:info.*runtime.specialsIter
go:info.runtime.(*markBits).advance$abstract -> go:info.*runtime.markBits
go:info.runtime.(*mProfCycleHolder).read$abstract -> go:info.*runtime.mProfCycleHolder
go:info.runtime.(*atomicSpanSetSpinePointer).Load$abstract -> go:info.*runtime.atomicSpanSetSpinePointer
go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]
go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]).StoreNoWB$abstract -> go:info.*go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }
go:info.runtime.(*atomicMSpanPointer).StoreNoWB$abstract -> go:info.*runtime.atomicMSpanPointer
go:info.runtime.(*goroutineProfileStateHolder).Load$abstract -> go:info.*runtime.goroutineProfileStateHolder
go:info.runtime.(*bucket).stk$abstract -> go:info.*[32]uintptr
go:info.runtime.(*semTable).rootFor$abstract -> go:info.*runtime.semTable
go:info.runtime.(*randomOrder).reset$abstract -> go:info.*runtime.randomOrder
go:info.runtime.(*sweepClass).load$abstract -> go:info.*runtime.sweepClass
go:info.runtime.(*scavengerState).ready$abstract -> go:info.*runtime.scavengerState
go:info.runtime.(*memRecordCycle).add$abstract -> go:info.*runtime.memRecordCycle
go:info.runtime/internal/atomic.(*Pointer[go.shape.func()]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.func()]
go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string) func()]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.func(string) func()]
go:info.runtime/internal/atomic.(*Pointer[go.shape.func()]).Store$abstract -> go:info.*go.shape.func()
runtime.c128equal·f -> runtime.c128equal
runtime.c64equal·f -> runtime.c64equal
runtime.f32equal·f -> runtime.f32equal
runtime.f64equal·f -> runtime.f64equal
type:interface {} <UsedInIface> -> runtime.nilinterequal·f
type:interface {} <UsedInIface> -> type:.namedata.*interface {}-
runtime.nilinterequal·f -> runtime.nilinterequal
runtime.nilinterequal -> runtime.efaceeq
type:[]uintptr <UsedInIface> -> type:.namedata.*[]uintptr-
type:[32]uintptr <UsedInIface> -> type:.namedata.*[32]uintptr-
type:[]uint8 <UsedInIface> -> type:.namedata.*[]uint8-
type:map[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.*map[abi.TypeOff]*abi.Type-
type:map[internal/abi.TypeOff]*internal/abi.Type -> type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type
type:map[internal/abi.TypeOff]*internal/abi.Type -> runtime.memhash32·f
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> runtime.gcbits.e03f000000000000
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.*map.bucket[abi.TypeOff]*abi.Type-
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.importpath..
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.topbits-
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:[8]uint8
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.keys-
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:noalg.[8]internal/abi.TypeOff
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.elems-
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:noalg.[8]*internal/abi.Type
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.overflow-
type:[8]uint8 -> type:.namedata.*[8]uint8-
type:noalg.[8]internal/abi.TypeOff -> type:.namedata.*[8]abi.TypeOff-
type:noalg.[8]internal/abi.TypeOff -> type:[]internal/abi.TypeOff
type:[]internal/abi.TypeOff -> type:.namedata.*[]abi.TypeOff-
type:noalg.[8]*internal/abi.Type -> runtime.gcbits.ff00000000000000
type:noalg.[8]*internal/abi.Type -> type:.namedata.*[8]*abi.Type-
type:noalg.[8]*internal/abi.Type -> type:[]*internal/abi.Type
type:[]*internal/abi.Type -> type:.namedata.*[]*abi.Type-
runtime.memhash32·f -> runtime.memhash32
type:[0]*runtime.PanicNilError <UsedInIface> -> type:.namedata.*[0]*runtime.PanicNilError-
type:[0]*runtime.PanicNilError <UsedInIface> -> type:[]*runtime.PanicNilError <UsedInIface>
type:[]*runtime.PanicNilError <UsedInIface> -> type:.namedata.*[]*runtime.PanicNilError-
type:.eqfunc.runtime.PanicNilError -> type:.eq.runtime.PanicNilError
 -> go:info.*runtime.PanicNilError
type:.eqfunc.runtime.TypeAssertionError -> type:.eq.runtime.TypeAssertionError
 -> go:info.*runtime.TypeAssertionError
type:.eqfunc.runtime._panic -> type:.eq.runtime._panic
type:[6]uintptr <UsedInIface> -> type:.namedata.*[6]uintptr-
type:.eqfunc.runtime.sysmontick -> type:.eq.runtime.sysmontick
 -> go:info.*runtime.sysmontick
type:[136]*runtime.mspan -> type:.eqfunc1088
type:[136]*runtime.mspan -> type:.namedata.*[136]*runtime.mspan-
type:[136]*runtime.mspan -> type:*runtime.mspan
type:[136]*runtime.mspan -> type:[]*runtime.mspan
type:*runtime.mspan -> type:.namedata.*runtime.mspan-
type:*runtime.mspan -> type:runtime.mspan
type:*runtime.mspan -> type:.namedata.allocBitsForIndex-
type:*runtime.mspan -> type:.namedata.countAlloc-
type:*runtime.mspan -> type:.namedata.divideByElemSize-
type:*runtime.mspan -> type:.namedata.ensureSwept-
type:*runtime.mspan -> type:.namedata.inList-
type:*runtime.mspan -> type:.namedata.initHeapBits-
type:*runtime.mspan -> type:.namedata.isFree-
type:*runtime.mspan -> type:.namedata.isUnusedUserArenaChunk-
type:*runtime.mspan -> type:.namedata.layout-
type:*runtime.mspan -> type:.namedata.markBitsForBase-
type:*runtime.mspan -> type:.namedata.markBitsForIndex-
type:*runtime.mspan -> type:.namedata.nextFreeIndex-
type:*runtime.mspan -> type:.namedata.objIndex-
type:*runtime.mspan -> type:.namedata.refillAllocCache-
type:*runtime.mspan -> type:.namedata.reportZombies-
type:*runtime.mspan -> type:.namedata.setUserArenaChunkToFault-
type:*runtime.mspan -> type:.namedata.userArenaNextFree-
type:runtime.mspan -> type:.eqfunc.runtime.mspan
type:runtime.mspan -> type:.namedata.list-
type:runtime.mspan -> type:*runtime.mSpanList
type:runtime.mspan -> type:.namedata.startAddr-
type:runtime.mspan -> type:.namedata.npages-
type:runtime.mspan -> type:.namedata.manualFreeList-
type:runtime.mspan -> type:runtime.gclinkptr
type:runtime.mspan -> type:.namedata.freeindex-
type:runtime.mspan -> type:.namedata.nelems-
type:runtime.mspan -> type:.namedata.allocCache-
type:runtime.mspan -> type:.namedata.allocBits-
type:runtime.mspan -> type:*runtime.gcBits
type:runtime.mspan -> type:.namedata.gcmarkBits-
type:runtime.mspan -> type:.namedata.sweepgen-
type:runtime.mspan -> type:.namedata.divMul-
type:runtime.mspan -> type:.namedata.allocCount-
type:runtime.mspan -> type:.namedata.spanclass-
type:runtime.mspan -> type:runtime.spanClass
type:runtime.mspan -> type:.namedata.state-
type:runtime.mspan -> type:runtime.mSpanStateBox
type:runtime.mspan -> type:.namedata.needzero-
type:runtime.mspan -> type:.namedata.isUserArenaChunk-
type:runtime.mspan -> type:.namedata.allocCountBeforeCache-
type:runtime.mspan -> type:.namedata.limit-
type:runtime.mspan -> type:.namedata.speciallock-
type:runtime.mspan -> type:.namedata.specials-
type:runtime.mspan -> type:*runtime.special
type:runtime.mspan -> type:.namedata.userArenaChunkFree-
type:runtime.mspan -> type:runtime.addrRange
type:runtime.mspan -> type:.namedata.freeIndexForScan-
type:*runtime.mSpanList -> type:.namedata.*runtime.mSpanList-
type:*runtime.mSpanList -> type:runtime.mSpanList
type:*runtime.mSpanList -> type:.namedata.insert-
type:*runtime.mSpanList -> type:.namedata.insertBack-
type:*runtime.mSpanList -> type:.namedata.isEmpty-
type:*runtime.mSpanList -> type:.namedata.remove-
type:*runtime.mSpanList -> type:.namedata.takeAll-
type:runtime.mSpanList -> type:.eqfunc.runtime.mSpanList
type:runtime.gclinkptr -> type:.namedata.*runtime.gclinkptr-
type:runtime.gclinkptr -> type:*runtime.gclinkptr
type:*runtime.gcBits -> type:.namedata.*runtime.gcBits-
type:*runtime.gcBits -> type:runtime.gcBits
type:*runtime.gcBits -> type:.namedata.bitp-
type:*runtime.gcBits -> type:.namedata.bytep-
type:runtime.gcBits -> type:.eqfunc.runtime.gcBits
type:runtime.gcBits -> type:.namedata.x-
type:runtime.spanClass -> type:.namedata.*runtime.spanClass-
type:runtime.spanClass -> type:*runtime.spanClass
type:runtime.spanClass -> type:.namedata.noscan-
type:runtime.spanClass -> type:.namedata.sizeclass-
type:runtime.mSpanStateBox -> type:.namedata.*runtime.mSpanStateBox-
type:runtime.mSpanStateBox -> type:*runtime.mSpanStateBox
type:runtime.mSpanStateBox -> type:.namedata.s-
type:*runtime.mSpanStateBox -> type:.namedata.get-
type:*runtime.special -> type:.namedata.*runtime.special-
type:*runtime.special -> type:runtime.special
type:runtime.special -> type:.eqfunc.runtime.special
type:runtime.special -> type:.namedata.offset-
type:runtime.special -> type:.namedata.kind-
type:runtime.addrRange -> type:.namedata.*runtime.addrRange-
type:runtime.addrRange -> type:*runtime.addrRange
type:runtime.addrRange -> type:runtime.offAddr
type:runtime.addrRange -> type:.namedata.contains-
type:runtime.addrRange -> type:.namedata.removeGreaterEqual-
type:runtime.addrRange -> type:.namedata.size-
type:runtime.addrRange -> type:.namedata.subtract-
type:runtime.offAddr -> type:.namedata.*runtime.offAddr-
type:runtime.offAddr -> type:*runtime.offAddr
type:runtime.offAddr -> type:.namedata.a-
type:runtime.offAddr -> type:.namedata.addr-
type:runtime.offAddr -> type:.namedata.diff-
type:runtime.offAddr -> type:.namedata.equal-
type:runtime.offAddr -> type:.namedata.lessEqual-
type:runtime.offAddr -> type:.namedata.lessThan-
type:runtime.offAddr -> type:.namedata.sub-
type:*runtime.addrRange -> type:.namedata.takeFromBack-
type:*runtime.addrRange -> type:.namedata.takeFromFront-
type:.eqfunc.runtime.mSpanList -> type:.eq.runtime.mSpanList
type:.eqfunc.runtime.gcBits -> type:.eq.runtime.gcBits
type:.eqfunc.runtime.special -> type:.eq.runtime.special
type:.eqfunc.runtime.mspan -> type:.eq.runtime.mspan
type:[]*runtime.mspan -> type:.namedata.*[]*runtime.mspan-
type:[2]runtime.stackfreelist -> type:.eqfunc32
type:[2]runtime.stackfreelist -> type:.namedata.*[2]runtime.stackfreelist-
type:[2]runtime.stackfreelist -> type:runtime.stackfreelist
type:[2]runtime.stackfreelist -> type:[]runtime.stackfreelist
type:runtime.stackfreelist -> type:.namedata.*runtime.stackfreelist-
type:runtime.stackfreelist -> type:*runtime.stackfreelist
type:[]runtime.stackfreelist -> type:.namedata.*[]runtime.stackfreelist-
type:.eqfunc.runtime.mcache -> type:.eq.runtime.mcache
type:[]*runtime._defer -> type:.namedata.*[]*runtime._defer-
type:[32]*runtime._defer -> runtime.gcbits.ffffffff00000000
type:[32]*runtime._defer -> type:.namedata.*[32]*runtime._defer-
type:[256]runtime.guintptr -> type:.eqfunc2048
type:[256]runtime.guintptr -> type:.namedata.*[256]runtime.guintptr-
type:[256]runtime.guintptr -> type:[]runtime.guintptr
type:[]runtime.guintptr -> type:.namedata.*[]runtime.guintptr-
type:struct { runtime.gList; runtime.n int32 } -> type:.eqfunc.struct { runtime.gList; runtime.n int32 }
type:struct { runtime.gList; runtime.n int32 } -> type:.namedata.*struct { runtime.gList; n int32 }-
type:struct { runtime.gList; runtime.n int32 } -> type:*struct { runtime.gList; runtime.n int32 }
type:struct { runtime.gList; runtime.n int32 } -> type:.namedata.gList-.embedded
type:struct { runtime.gList; runtime.n int32 } -> type:runtime.gList
type:runtime.gList -> type:.namedata.*runtime.gList-
type:runtime.gList -> type:*runtime.gList
type:runtime.gList -> type:.namedata.head-
type:*runtime.gList -> type:.namedata.pop-
type:*runtime.gList -> type:.namedata.push-
type:*runtime.gList -> type:.namedata.pushAll-
type:.eqfunc.struct { runtime.gList; runtime.n int32 } -> type:.eq.struct { runtime.gList; runtime.n int32 }
 -> go:info.*struct { runtime.gList; runtime.n int32 }
type:*struct { runtime.gList; runtime.n int32 } -> type:.namedata.runtime.0
type:*struct { runtime.gList; runtime.n int32 } -> type:.namedata.runtime.1
type:*struct { runtime.gList; runtime.n int32 } -> type:.namedata.runtime.2
type:*struct { runtime.gList; runtime.n int32 } -> type:.namedata.runtime.3
type:.eqfunc.runtime.hchan -> type:.eq.runtime.hchan
type:.eqfunc.runtime.sudog -> type:.eq.runtime.sudog
type:[]*runtime.sudog -> type:.namedata.*[]*runtime.sudog-
type:[128]*runtime.sudog -> type:.eqfunc1024
type:[128]*runtime.sudog -> runtime.gcbits.ffffffffffffffffffffffffffffffff
type:[128]*runtime.sudog -> type:.namedata.*[128]*runtime.sudog-
type:struct { runtime.len int; runtime.buf [128]*runtime.mspan } -> type:.eqfunc1032
type:struct { runtime.len int; runtime.buf [128]*runtime.mspan } -> type:.namedata.*struct { len int; buf [128]*runtime.mspan }-
type:struct { runtime.len int; runtime.buf [128]*runtime.mspan } -> type:.namedata.len-
type:struct { runtime.len int; runtime.buf [128]*runtime.mspan } -> type:[128]*runtime.mspan
type:[128]*runtime.mspan -> type:.namedata.*[128]*runtime.mspan-
type:.eqfunc.runtime.pTraceState -> type:.eq.runtime.pTraceState
 -> go:info.*runtime.pTraceState
type:.eqfunc.runtime.notInHeap -> type:.eq.runtime.notInHeap
type:.eqfunc.runtime.limiterEvent -> type:.eq.runtime.limiterEvent
type:[253]uintptr -> type:.eqfunc2024
type:[253]uintptr -> type:.namedata.*[253]uintptr-
type:.eqfunc.runtime.workbuf -> type:.eq.runtime.workbuf
type:.eqfunc.runtime.gcWork -> type:.eq.runtime.gcWork
type:[512]uintptr -> type:.eqfunc4096
type:[512]uintptr -> type:.namedata.*[512]uintptr-
type:func(interface {}, uintptr) <UsedInIface> -> type:.namedata.*func(interface {}, uintptr)-
type:[]*runtime.timer -> type:.namedata.*[]*runtime.timer-
type:func(*runtime.g, unsafe.Pointer) bool <UsedInIface> -> type:.namedata.*func(*runtime.g, unsafe.Pointer) bool-
type:.eqfunc.runtime.mOS -> type:.eq.runtime.mOS
 -> go:info.*runtime.mOS
type:[10]runtime.heldLockInfo <UsedInIface> -> type:.eqfunc160
type:[10]runtime.heldLockInfo <UsedInIface> -> type:.namedata.*[10]runtime.heldLockInfo-
type:[10]runtime.heldLockInfo <UsedInIface> -> type:runtime.heldLockInfo <UsedInIface>
type:[10]runtime.heldLockInfo <UsedInIface> -> type:[]runtime.heldLockInfo <UsedInIface>
type:runtime.heldLockInfo <UsedInIface> -> type:.namedata.*runtime.heldLockInfo-
type:runtime.heldLockInfo <UsedInIface> -> type:*runtime.heldLockInfo <UsedInIface>
type:runtime.heldLockInfo <UsedInIface> -> type:.namedata.lockAddr-
type:runtime.heldLockInfo <UsedInIface> -> type:.namedata.rank-
type:runtime.heldLockInfo <UsedInIface> -> type:runtime.lockRank <UsedInIface>
type:runtime.lockRank <UsedInIface> -> type:.namedata.*runtime.lockRank-
type:runtime.lockRank <UsedInIface> -> type:*runtime.lockRank <UsedInIface>
type:[]runtime.heldLockInfo <UsedInIface> -> type:.namedata.*[]runtime.heldLockInfo-
type:[]runtime.ancestorInfo -> type:.namedata.*[]runtime.ancestorInfo-
type:*[]runtime.ancestorInfo <UsedInIface> -> type:[]runtime.ancestorInfo <UsedInIface>
type:[]runtime.ancestorInfo <UsedInIface> -> type:runtime.ancestorInfo <UsedInIface>
type:runtime.ancestorInfo <UsedInIface> -> type:*runtime.ancestorInfo <UsedInIface>
type:.eqfunc.runtime.gTraceState -> type:.eq.runtime.gTraceState
 -> go:info.*runtime.gTraceState
type:map[int32]unsafe.Pointer -> type:.namedata.*map[int32]unsafe.Pointer-
type:map[int32]unsafe.Pointer -> type:noalg.map.bucket[int32]unsafe.Pointer
type:noalg.map.bucket[int32]unsafe.Pointer -> type:.namedata.*map.bucket[int32]unsafe.Pointer-
type:noalg.map.bucket[int32]unsafe.Pointer -> type:noalg.[8]int32
type:noalg.map.bucket[int32]unsafe.Pointer -> type:noalg.[8]unsafe.Pointer
type:noalg.[8]unsafe.Pointer -> type:.namedata.*[8]unsafe.Pointer-
type:noalg.[8]unsafe.Pointer -> type:[]unsafe.Pointer
type:[]unsafe.Pointer -> type:.namedata.*[]unsafe.Pointer-
type:noalg.[8]int32 -> type:.namedata.*[8]int32-
type:noalg.[8]int32 -> type:[]int32
type:[]int32 -> type:.namedata.*[]int32-
runtime.(*mheap).allocSpan.func1·f -> runtime.(*mheap).allocSpan.func1
runtime.(*pageAlloc).sysGrow.func1·f -> runtime.(*pageAlloc).sysGrow.func1
 -> go:info.runtime.offAddr.addr$abstract
 -> go:info.runtime.blockAlignSummaryRange$abstract
runtime.entersyscall_gcwait·f -> runtime.entersyscall_gcwait
runtime.entersyscall_sysmon·f -> runtime.entersyscall_sysmon
runtime.entersyscallblock_handoff·f -> runtime.entersyscallblock_handoff
runtime.entersyscallblock_handoff -> runtime.traceGoSysCall
runtime.entersyscallblock_handoff -> runtime.handoffp
runtime.handoffp -> runtime.wakeNetPoller
 -> go:info.runtime.traceShuttingDown$abstract
 -> go:info.runtime.traceReaderAvailable$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.stack runtime.stack; runtime.stackguard0 uintptr; runtime.stackguard1 uintptr; runtime._panic *runtime._panic; runtime._defer *runtime._defer; runtime.m *runtime.m; runtime.sched runtime.gobuf; runtime.syscallsp uintptr; runtime.syscallpc uintptr; runtime.stktopsp uintptr; runtime.param unsafe.Pointer; runtime.atomicstatus runtime/internal/atomic.Uint32; runtime.stackLock uint32; runtime.goid uint64; runtime.schedlink runtime.guintptr; runtime.waitsince int64; runtime.waitreason runtime.waitReason; runtime.preempt bool; runtime.preemptStop bool; runtime.preemptShrink bool; runtime.asyncSafePoint bool; runtime.paniconfault bool; runtime.gcscandone bool; runtime.throwsplit bool; runtime.activeStackChans bool; runtime.parkingOnChan runtime/internal/atomic.Bool; runtime.raceignore int8; runtime.tracking bool; runtime.trackingSeq uint8; runtime.trackingStamp int64; runtime.runnableTime int64; runtime.lockedm runtime.muintptr; runtime.sig uint32; runtime.writebuf []uint8; runtime.sigcode0 uintptr; runtime.sigcode1 uintptr; runtime.sigpc uintptr; runtime.parentGoid uint64; runtime.gopc uintptr; runtime.ancestors *[]runtime.ancestorInfo; runtime.startpc uintptr; runtime.racectx uintptr; runtime.waiting *runtime.sudog; runtime.cgoCtxt []uintptr; runtime.labels unsafe.Pointer; runtime.timer *runtime.timer; runtime.selectDone runtime/internal/atomic.Uint32; runtime.goroutineProfiled runtime.goroutineProfileStateHolder; runtime.trace runtime.gTraceState; runtime.gcAssistBytes int64 }]).Load$abstract
 -> go:info.runtime.nobarrierWakeTime$abstract
go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.stack runtime.stack; runtime.stackguard0 uintptr; runtime.stackguard1 uintptr; runtime._panic *runtime._panic; runtime._defer *runtime._defer; runtime.m *runtime.m; runtime.sched runtime.gobuf; runtime.syscallsp uintptr; runtime.syscallpc uintptr; runtime.stktopsp uintptr; runtime.param unsafe.Pointer; runtime.atomicstatus runtime/internal/atomic.Uint32; runtime.stackLock uint32; runtime.goid uint64; runtime.schedlink runtime.guintptr; runtime.waitsince int64; runtime.waitreason runtime.waitReason; runtime.preempt bool; runtime.preemptStop bool; runtime.preemptShrink bool; runtime.asyncSafePoint bool; runtime.paniconfault bool; runtime.gcscandone bool; runtime.throwsplit bool; runtime.activeStackChans bool; runtime.parkingOnChan runtime/internal/atomic.Bool; runtime.raceignore int8; runtime.tracking bool; runtime.trackingSeq uint8; runtime.trackingStamp int64; runtime.runnableTime int64; runtime.lockedm runtime.muintptr; runtime.sig uint32; runtime.writebuf []uint8; runtime.sigcode0 uintptr; runtime.sigcode1 uintptr; runtime.sigpc uintptr; runtime.parentGoid uint64; runtime.gopc uintptr; runtime.ancestors *[]runtime.ancestorInfo; runtime.startpc uintptr; runtime.racectx uintptr; runtime.waiting *runtime.sudog; runtime.cgoCtxt []uintptr; runtime.labels unsafe.Pointer; runtime.timer *runtime.timer; runtime.selectDone runtime/internal/atomic.Uint32; runtime.goroutineProfiled runtime.goroutineProfileStateHolder; runtime.trace runtime.gTraceState; runtime.gcAssistBytes int64 }]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.struct { runtime.stack runtime.stack; runtime.stackguard0 uintptr; runtime.stackguard1 uintptr; runtime._panic *runtime._panic; runtime._defer *runtime._defer; runtime.m *runtime.m; runtime.sched runtime.gobuf; runtime.syscallsp uintptr; runtime.syscallpc uintptr; runtime.stktopsp uintptr; runtime.param unsafe.Pointer; runtime.atomicstatus runtime/internal/atomic.Uint32; runtime.stackLock uint32; runtime.goid uint64; runtime.schedlink runtime.guintptr; runtime.waitsince int64; runtime.waitreason runtime.waitReason; runtime.preempt bool; runtime.preemptStop bool; runtime.preemptShrink bool; runtime.asyncSafePoint bool; runtime.paniconfault bool; runtime.gcscandone bool; runtime.throwsplit bool; runtime.activeStackChans bool; runtime.parkingOnChan runtime/internal/atomic.Bool; runtime.raceignore int8; runtime.tracking bool; runtime.trackingSeq uint8; runtime.trackingStamp int64; runtime.runnableTime int64; runtime.lockedm runtime.muintptr; runtime.sig uint32; runtime.writebuf []uint8; runtime.sigcode0 uintptr; runtime.sigcode1 uintptr; runtime.sigpc uintptr; runtime.parentGoid uint64; runtime.gopc uintptr; runtime.ancestors *[]runtime.ancestorInfo; runtime.startpc uintptr; runtime.racectx uintptr; runtime.waiting *runtime.sudog; runtime.cgoCtxt []uintptr; runtime.labels unsafe.Pointer; runtime.timer *runtime.timer; runtime.selectDone runtime/internal/atomic.Uint32; runtime.goroutineProfiled runtime.goroutineProfileStateHolder; runtime.trace runtime.gTraceState; runtime.gcAssistBytes int64 }]
runtime.exitsyscall0·f -> runtime.exitsyscall0
runtime.exitsyscall0 -> runtime.execute
runtime.exitsyscall0 -> runtime.stoplockedm
runtime.exitsyscall0 -> runtime.stopm
runtime.exitsyscall0 -> runtime.schedule
runtime.stopm -> runtime.mput
runtime.stopm -> go:string."stopm spinning"
runtime.stopm -> go:string."stopm holding p"
runtime.stopm -> go:string."stopm holding locks"
runtime.stoplockedm -> runtime.incidlelocked
runtime.stoplockedm -> go:string."runtime:stoplockedm: lockedg (atomicstatus="
runtime.stoplockedm -> go:string.") is not Grunnable or Gscanrunnable\n"
runtime.stoplockedm -> go:string."stoplockedm: not runnable"
runtime.stoplockedm -> go:string."stoplockedm: inconsistent locking"
runtime.stoplockedm -> gclocals·DsEZEqsV1VFgO2VgUUolkQ==
runtime.stoplockedm -> gclocals·4FI4FushYEU3mjALcQ0xCQ==
runtime.execute -> runtime.setThreadCPUProfiler
runtime.execute -> runtime.gogo
runtime.setThreadCPUProfiler -> runtime.profiletimer
runtime.schedule -> runtime.startlockedm
runtime.schedule -> runtime.findRunnable
runtime.schedule -> runtime.resetspinning
runtime.schedule -> go:string."schedule: spinning with local work"
runtime.schedule -> go:string."schedule: in cgo"
runtime.schedule -> go:string."schedule: holding locks"
runtime.startlockedm -> go:string."startlockedm: m has p"
runtime.startlockedm -> go:string."startlockedm: locked to me"
runtime.findRunnable -> runtime.gcstopm
runtime.findRunnable -> runtime.runSafePointFn
runtime.findRunnable -> runtime.checkTimers
runtime.findRunnable -> runtime.traceReader
runtime.findRunnable -> runtime.(*gcControllerState).findRunnableGCWorker
runtime.findRunnable -> runtime.globrunqget
runtime.findRunnable -> runtime.fing
runtime.findRunnable -> runtime.netpollWaiters
runtime.findRunnable -> runtime.stealWork
runtime.findRunnable -> runtime.(*gcControllerState).addIdleMarkWorker
runtime.findRunnable -> runtime.checkRunqsNoP
runtime.findRunnable -> runtime.checkIdleGCNoP
runtime.findRunnable -> runtime.checkTimersNoP
runtime.findRunnable -> runtime.faketime
runtime.findRunnable -> go:string."findrunnable: netpoll with spinning"
runtime.findRunnable -> go:string."findrunnable: netpoll with p"
runtime.findRunnable -> go:string."findrunnable: negative nmspinning"
runtime.findRunnable -> go:string."findrunnable: wrong p"
runtime.findRunnable -> runtime.gcBgMarkWorkerPool
runtime.findRunnable -> runtime.(*gcControllerState).removeIdleMarkWorker
runtime.findRunnable -> gclocals·5ycp9muDlH1Gn4j7Ub8szg==
runtime.findRunnable -> gclocals·zeOwUsKbvyl/iM966yh37A==
runtime.(*gcControllerState).findRunnableGCWorker -> go:string."gcControllerState.findRunnable: blackening not enabled"
runtime.gcstopm -> go:string."gcstopm: negative nmspinning"
runtime.gcstopm -> go:string."gcstopm: not waiting for gc"
runtime.stealWork -> runtime.runqsteal
runtime.checkRunqsNoP -> gclocals·2A2zbY2sHTuUjMt5MjKHOA==
runtime.checkRunqsNoP -> fmt.Append.arginfo1
runtime.checkTimersNoP -> reflect.deepValueEqual.arginfo1
runtime.resetspinning -> go:string."resetspinning: not a spinning m"
runtime.checkTimers -> runtime.adjusttimers
runtime.checkTimers -> runtime.runtimer
runtime.checkTimers -> runtime.clearDeletedTimers
runtime.checkTimers -> gclocals·wzwZd8fw2WzsZRiaoAKqRA==
runtime.incidlelocked -> runtime.checkdead
runtime.checkdead -> runtime.islibrary
runtime.checkdead -> runtime.isarchive
runtime.checkdead -> runtime.cgoHasExtraM
runtime.checkdead -> runtime.checkdead.func1
runtime.checkdead -> go:string."no goroutines (main called runtime.Goexit) - deadlock!"
runtime.checkdead -> runtime.timeSleepUntil
runtime.checkdead -> go:string."checkdead: no m for timer"
runtime.checkdead -> go:string."checkdead: no p for timer"
runtime.checkdead -> go:string."all goroutines are asleep - deadlock!"
runtime.checkdead -> go:string."runtime: checkdead: nmidle="
runtime.checkdead -> go:string." mcount="
runtime.checkdead -> go:string." nmsys="
runtime.checkdead -> go:string."checkdead: inconsistent counts"
runtime.checkdead.func1 -> go:string."runtime: checkdead: find g "
runtime.checkdead.func1 -> go:string." in status "
runtime.checkdead.func1 -> go:string."checkdead: runnable g"
runtime.runqsteal -> runtime.runqgrab
runtime.runqsteal -> go:string."runqsteal: runq overflow"
runtime.runqgrab -> runtime.runqgrab.arginfo1
runtime.adjusttimers -> runtime.adjusttimers.jump19
runtime.adjusttimers -> runtime.dodeltimer
runtime.adjusttimers -> runtime.addAdjustedTimers
runtime.adjusttimers -> go:string."adjusttimers: bad p"
runtime.adjusttimers -> gclocals·IEvgBZYKa2AgiMWIYzMedQ==
runtime.dodeltimer -> runtime.siftdownTimer
runtime.dodeltimer -> go:string."dodeltimer: wrong P"
runtime.runtimer -> runtime.runtimer.jump13
runtime.runtimer -> runtime.dodeltimer0
runtime.runtimer -> runtime.runOneTimer
runtime.runtimer -> go:string."runtimer: bad p"
runtime.dodeltimer0 -> go:string."dodeltimer0: wrong P"
runtime.runOneTimer -> gclocals·t/xps2kNqDgeo8aGJO2G+A==
runtime.runOneTimer -> gclocals·jiTyHuuhQcickEQkR7IMlw==
runtime.clearDeletedTimers -> runtime.clearDeletedTimers.jump14
runtime.clearDeletedTimers -> gclocals·k1WmXHXjhdN9EEzP4xvAhQ==
 -> go:info.runtime.lfstack
 -> go:info.*runtime.gcBgMarkWorkerNode
 -> go:info.runtime.(*gcCPULimiterState).needUpdate$abstract
 -> go:info.runtime.(*gcControllerState).findRunnableGCWorker.func1$abstract
 -> go:info.runtime.mPark$abstract
 -> go:info.runtime.runqget$abstract
 -> go:info.runtime.wakefing$abstract
 -> go:info.runtime.(*m).becomeSpinning$abstract
 -> go:info.runtime/internal/atomic.(*Int64).Swap$abstract
 -> go:info.runtime.randomEnum
 -> go:info.runtime.(*randomOrder).start$abstract
 -> go:info.runtime.(*randomEnum).next$abstract
 -> go:info.runtime.(*randomEnum).done$abstract
 -> go:info.runtime.(*randomEnum).position$abstract
 -> go:info.runtime.pMask.read$abstract
 -> go:info.runtime.(*gcControllerState).needIdleMarkWorker$abstract
 -> go:info.runtime.dropg$abstract
 -> go:info.runtime.setMNoWB$abstract
 -> go:info.runtime.setGNoWB$abstract
 -> go:info.runtime.globrunqput$abstract
 -> go:info.*[256]runtime.guintptr
 -> go:info.runtime.updateTimer0When$abstract
 -> go:info.func(interface {}, uintptr)
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.stack runtime.stack; runtime.stackguard0 uintptr; runtime.stackguard1 uintptr; runtime._panic *runtime._panic; runtime._defer *runtime._defer; runtime.m *runtime.m; runtime.sched runtime.gobuf; runtime.syscallsp uintptr; runtime.syscallpc uintptr; runtime.stktopsp uintptr; runtime.param unsafe.Pointer; runtime.atomicstatus runtime/internal/atomic.Uint32; runtime.stackLock uint32; runtime.goid uint64; runtime.schedlink runtime.guintptr; runtime.waitsince int64; runtime.waitreason runtime.waitReason; runtime.preempt bool; runtime.preemptStop bool; runtime.preemptShrink bool; runtime.asyncSafePoint bool; runtime.paniconfault bool; runtime.gcscandone bool; runtime.throwsplit bool; runtime.activeStackChans bool; runtime.parkingOnChan runtime/internal/atomic.Bool; runtime.raceignore int8; runtime.tracking bool; runtime.trackingSeq uint8; runtime.trackingStamp int64; runtime.runnableTime int64; runtime.lockedm runtime.muintptr; runtime.sig uint32; runtime.writebuf []uint8; runtime.sigcode0 uintptr; runtime.sigcode1 uintptr; runtime.sigpc uintptr; runtime.parentGoid uint64; runtime.gopc uintptr; runtime.ancestors *[]runtime.ancestorInfo; runtime.startpc uintptr; runtime.racectx uintptr; runtime.waiting *runtime.sudog; runtime.cgoCtxt []uintptr; runtime.labels unsafe.Pointer; runtime.timer *runtime.timer; runtime.selectDone runtime/internal/atomic.Uint32; runtime.goroutineProfiled runtime.goroutineProfileStateHolder; runtime.trace runtime.gTraceState; runtime.gcAssistBytes int64 }]).CompareAndSwapNoWB$abstract
 -> go:info.runtime/internal/atomic.(*UnsafePointer).CompareAndSwapNoWB$abstract
go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.stack runtime.stack; runtime.stackguard0 uintptr; runtime.stackguard1 uintptr; runtime._panic *runtime._panic; runtime._defer *runtime._defer; runtime.m *runtime.m; runtime.sched runtime.gobuf; runtime.syscallsp uintptr; runtime.syscallpc uintptr; runtime.stktopsp uintptr; runtime.param unsafe.Pointer; runtime.atomicstatus runtime/internal/atomic.Uint32; runtime.stackLock uint32; runtime.goid uint64; runtime.schedlink runtime.guintptr; runtime.waitsince int64; runtime.waitreason runtime.waitReason; runtime.preempt bool; runtime.preemptStop bool; runtime.preemptShrink bool; runtime.asyncSafePoint bool; runtime.paniconfault bool; runtime.gcscandone bool; runtime.throwsplit bool; runtime.activeStackChans bool; runtime.parkingOnChan runtime/internal/atomic.Bool; runtime.raceignore int8; runtime.tracking bool; runtime.trackingSeq uint8; runtime.trackingStamp int64; runtime.runnableTime int64; runtime.lockedm runtime.muintptr; runtime.sig uint32; runtime.writebuf []uint8; runtime.sigcode0 uintptr; runtime.sigcode1 uintptr; runtime.sigpc uintptr; runtime.parentGoid uint64; runtime.gopc uintptr; runtime.ancestors *[]runtime.ancestorInfo; runtime.startpc uintptr; runtime.racectx uintptr; runtime.waiting *runtime.sudog; runtime.cgoCtxt []uintptr; runtime.labels unsafe.Pointer; runtime.timer *runtime.timer; runtime.selectDone runtime/internal/atomic.Uint32; runtime.goroutineProfiled runtime.goroutineProfileStateHolder; runtime.trace runtime.gTraceState; runtime.gcAssistBytes int64 }]).CompareAndSwapNoWB$abstract -> go:info.*go.shape.struct { runtime.stack runtime.stack; runtime.stackguard0 uintptr; runtime.stackguard1 uintptr; runtime._panic *runtime._panic; runtime._defer *runtime._defer; runtime.m *runtime.m; runtime.sched runtime.gobuf; runtime.syscallsp uintptr; runtime.syscallpc uintptr; runtime.stktopsp uintptr; runtime.param unsafe.Pointer; runtime.atomicstatus runtime/internal/atomic.Uint32; runtime.stackLock uint32; runtime.goid uint64; runtime.schedlink runtime.guintptr; runtime.waitsince int64; runtime.waitreason runtime.waitReason; runtime.preempt bool; runtime.preemptStop bool; runtime.preemptShrink bool; runtime.asyncSafePoint bool; runtime.paniconfault bool; runtime.gcscandone bool; runtime.throwsplit bool; runtime.activeStackChans bool; runtime.parkingOnChan runtime/internal/atomic.Bool; runtime.raceignore int8; runtime.tracking bool; runtime.trackingSeq uint8; runtime.trackingStamp int64; runtime.runnableTime int64; runtime.lockedm runtime.muintptr; runtime.sig uint32; runtime.writebuf []uint8; runtime.sigcode0 uintptr; runtime.sigcode1 uintptr; runtime.sigpc uintptr; runtime.parentGoid uint64; runtime.gopc uintptr; runtime.ancestors *[]runtime.ancestorInfo; runtime.startpc uintptr; runtime.racectx uintptr; runtime.waiting *runtime.sudog; runtime.cgoCtxt []uintptr; runtime.labels unsafe.Pointer; runtime.timer *runtime.timer; runtime.selectDone runtime/internal/atomic.Uint32; runtime.goroutineProfiled runtime.goroutineProfileStateHolder; runtime.trace runtime.gTraceState; runtime.gcAssistBytes int64 }
go:info.runtime.(*randomEnum).done$abstract -> go:info.*runtime.randomEnum
runtime.fatalpanic.func2·f -> runtime.fatalpanic.func2
runtime.freeStackSpans·f -> runtime.freeStackSpans
runtime.gcBgMarkWorker·f -> runtime.gcBgMarkWorker
runtime.gcBgMarkWorker -> go:string."GC worker init"
runtime.gcBgMarkWorker -> type:runtime.gcBgMarkWorkerNode
runtime.gcBgMarkWorker -> runtime.gcBgMarkWorker.func1·f
runtime.gcBgMarkWorker -> runtime.gcBgMarkWorker.func2
runtime.gcBgMarkWorker -> runtime.(*gcControllerState).markWorkerStop
runtime.gcBgMarkWorker -> go:string."runtime: p.gcMarkWorkerMode= "
runtime.gcBgMarkWorker -> go:string." work.nwait= "
runtime.gcBgMarkWorker -> go:string."work.nwait was > work.nproc"
runtime.gcBgMarkWorker -> go:string."gcBgMarkWorker: mode not set"
runtime.gcBgMarkWorker -> go:string."worker mode "
runtime.gcBgMarkWorker -> go:string."gcBgMarkWorker: blackening not enabled"
runtime.gcBgMarkWorker -> gclocals·a+eYhiuKSeQLzGI1ENJjKg==
runtime.gcBgMarkWorker.func2 -> runtime.gcDrain
runtime.gcBgMarkWorker.func2 -> runtime.runqdrain
runtime.gcBgMarkWorker.func2 -> go:string."gcBgMarkWorker: unexpected gcMarkWorkerMode"
runtime.gcBgMarkWorker.func2 -> gclocals·ARj0ZiCgYnc03+5wTwVRqw==
runtime.gcDrain -> runtime.pollWork·f
runtime.gcDrain -> runtime.pollFractionalWorkerExit·f
runtime.gcDrain -> go:string."gcDrain phase incorrect"
runtime.(*gcControllerState).markWorkerStop -> go:string."markWorkerStop: unknown mark worker mode"
type:runtime.gcBgMarkWorkerNode -> type:.namedata.*runtime.gcBgMarkWorkerNode-
type:runtime.gcBgMarkWorkerNode -> type:*runtime.gcBgMarkWorkerNode
type:runtime.gcBgMarkWorkerNode -> type:.namedata.gp-
 -> go:info.runtime.gcDrainFlags
 -> go:info.runtime.gcMarkWorkerMode
runtime.gcBgMarkWorker.func1·f -> runtime.gcBgMarkWorker.func1
runtime.gcControllerCommit·f -> runtime.gcControllerCommit
runtime.gcControllerCommit -> runtime.(*gcControllerState).commit
runtime.gcControllerCommit -> runtime.traceHeapGoal
runtime.gcControllerCommit -> runtime.gcPaceSweeper
runtime.gcControllerCommit -> runtime.gcPaceScavenger
runtime.(*gcControllerState).commit -> $f64.3fe8000000000000
runtime.(*gcControllerState).commit -> $f64.4010000000000000
runtime.(*gcControllerState).commit -> $f64.43e0000000000000
runtime.gcPaceScavenger -> $f64.4057c00000000000
runtime.gcMarkDone.func1·f -> runtime.gcMarkDone.func1
runtime.gcMarkDone.func1 -> runtime.gcMarkDone.func1.1·f
runtime.gcMarkDone.func1 -> runtime.forEachP
runtime.forEachP -> runtime.notetsleep
runtime.forEachP -> go:string."forEachP: P did not run fn"
runtime.forEachP -> go:string."forEachP: not done"
runtime.forEachP -> go:string."forEachP: sched.safePointWait != 0"
runtime.forEachP -> gclocals·2tfxIl3Y8pOd9w9xcIYHoQ==
runtime.forEachP -> gclocals·vukTVx9gjIEhLGvmAObmFQ==
runtime.notetsleep -> go:string."notetsleep not on g0"
 -> go:info.func(*runtime.p)
runtime.gcMarkDone.func1.1·f -> runtime.gcMarkDone.func1.1
runtime.gcMarkDone.func3·f -> runtime.gcMarkDone.func3
runtime.gcMarkTermination.func2·f -> runtime.gcMarkTermination.func2
runtime.gcMarkTermination.func2 -> runtime.startCheckmarks
runtime.gcMarkTermination.func2 -> runtime.gcResetMarkState
runtime.gcMarkTermination.func2 -> runtime.endCheckmarks
runtime.gcMarkTermination.func2 -> runtime.gcSweep
runtime.startCheckmarks -> go:string."out of memory allocating checkmarks bitmap"
runtime.endCheckmarks -> go:string."GC work not flushed"
runtime.gcSweep -> runtime.freeSomeWbufs
runtime.gcSweep -> go:string."gcSweep being done but phase is not GCoff"
runtime.gcResetMarkState -> runtime.gcResetMarkState.func1·f
runtime.freeSomeWbufs -> runtime.freeSomeWbufs.func1
 -> go:info.*runtime.checkmarksMap
 -> go:info.runtime.(*activeSweep).reset$abstract
 -> go:info.runtime.(*sweepClass).clear$abstract
runtime.gcMarkTermination.func3·f -> runtime.gcMarkTermination.func3
runtime.gcMarkTermination.func4·f -> runtime.gcMarkTermination.func4
runtime.gcMarkTermination.func4 -> runtime.gcMarkTermination.func4.1·f
runtime.gcMarkTermination.func4.1·f -> runtime.gcMarkTermination.func4.1
runtime.gcMarkTermination.func4.1 -> runtime.gcMarkTermination.func4.1.1
runtime.gcResetMarkState.func1·f -> runtime.gcResetMarkState.func1
runtime.gcStart.func1·f -> runtime.gcStart.func1
runtime.gcStart.func1 -> runtime.finishsweep_m
runtime.finishsweep_m -> runtime.(*spanSet).reset
runtime.finishsweep_m -> runtime.(*scavengerState).wake
runtime.finishsweep_m -> runtime.nextMarkBitArenaEpoch
runtime.finishsweep_m -> go:string."active sweepers found at start of mark phase"
runtime.(*spanSet).reset -> go:string."fully empty unfreed span set block found in reset"
runtime.(*spanSet).reset -> go:string."span set block with unpopped elements found in reset"
runtime.(*spanSet).reset -> go:string."head = "
runtime.(*spanSet).reset -> go:string."attempt to clear non-empty span set"
 -> go:info.runtime.(*activeSweep).sweepers$abstract
 -> go:info.runtime.(*atomicHeadTailIndex).reset$abstract
runtime.gosched_m·f -> runtime.gosched_m
runtime.gosched_m -> runtime.goschedImpl
runtime.goschedImpl -> go:string."bad g status"
runtime.goschedImpl -> gclocals·jloi1q1oVv77LY1DU2CFXw==
runtime.goschedImpl -> gclocals·ysuwM3msTKPJIyGrEMzChA==
runtime.goschedguarded_m·f -> runtime.goschedguarded_m
runtime.goyield_m·f -> runtime.goyield_m
 -> go:info.runtime.traceGoPreempt$abstract
runtime.injectglist.func1·f -> runtime.injectglist.func1
runtime.markrootFreeGStacks·f -> runtime.markrootFreeGStacks
runtime.mspinning·f -> runtime.mspinning
runtime.osyield·f -> runtime.osyield
runtime.park_m·f -> runtime.park_m
 -> go:info.runtime.traceGoPark$abstract
runtime.parkunlock_c·f -> runtime.parkunlock_c
runtime.pollFractionalWorkerExit·f -> runtime.pollFractionalWorkerExit
runtime.pollFractionalWorkerExit -> $f64.3ff3333333333333
runtime.pollWork·f -> runtime.pollWork
runtime.printCgoTraceback.func1·f -> runtime.printCgoTraceback.func1
runtime.recovery·f -> runtime.recovery
runtime.recovery -> go:string."recover: "
runtime.recovery -> go:string." not in ["
runtime.recovery -> go:string."bad recovery"
runtime.schedtrace.func1·f -> runtime.schedtrace.func1
runtime.schedtrace.func1 -> go:string."  G"
runtime.schedtrace.func1 -> go:string.") m="
runtime.schedtrace.func1 -> go:string." lockedm="
runtime.semacreate.func1·f -> runtime.semacreate.func1
runtime.semacreate.func1 -> go:string."runtime: createevent failed; errno="
runtime.semacreate.func1 -> go:string."runtime.semacreate"
runtime.semacreate.func2·f -> runtime.semacreate.func2
runtime.semasleep.func1·f -> runtime.semasleep.func1
runtime.semasleep.func1 -> go:string."runtime.semasleep wait_abandoned"
runtime.semasleep.func2·f -> runtime.semasleep.func2
runtime.semasleep.func2 -> go:string."runtime: waitforsingleobject wait_failed; errno="
runtime.semasleep.func2 -> go:string."runtime.semasleep wait_failed"
runtime.semawakeup.func1·f -> runtime.semawakeup.func1
runtime.semawakeup.func1 -> go:string."runtime: setevent failed; errno="
runtime.semawakeup.func1 -> go:string."runtime.semawakeup"
runtime.stopTheWorldWithSema·f -> runtime.stopTheWorldWithSema
runtime.stopTheWorldWithSema -> go:string."stopTheWorld: not stopped (stopwait != 0)"
runtime.stopTheWorldWithSema -> go:string."stopTheWorld: not stopped (status != _Pgcstop)"
runtime.stopTheWorldWithSema -> go:string."stopTheWorld: holding locks"
runtime.stopTheWorldWithSema -> gclocals·kCyUDOR0j+5Z//3A4G0NTg==
runtime.sweepone.func1·f -> runtime.sweepone.func1
runtime.sweepone.func1 -> runtime.printScavTrace
runtime.printScavTrace -> go:string."scav "
runtime.printScavTrace -> go:string." KiB work (bg), "
runtime.printScavTrace -> go:string." KiB work (eager), "
runtime.printScavTrace -> go:string." KiB now, "
runtime.printScavTrace -> go:string."% util"
runtime.printScavTrace -> go:string." [controller reset]"
runtime.switchtothread·f -> runtime.switchtothread
runtime.switchtothread -> runtime.switchtothread
runtime.wbBufFlush.func1·f -> runtime.wbBufFlush.func1
runtime.mstart -> runtime.mstart0
runtime.mstart0 -> runtime.mstart0
runtime.mstart0 -> runtime.mstart1
runtime.mstart0 -> runtime.mexit
runtime.mstart1 -> runtime.asminit
runtime.mstart1 -> runtime.minit
runtime.mstart1 -> runtime.m0
runtime.mstart1 -> runtime.mstartm0
runtime.mstart1 -> go:string."bad runtime·mstart"
runtime.minit -> runtime._GetCurrentThreadId
runtime.minit -> runtime.stdcall0
runtime.minit -> runtime._CreateWaitableTimerExW
runtime.minit -> runtime._VirtualQuery
runtime.minit -> runtime.stackcheck
runtime.minit -> go:string."runtime: g0 stack ["
runtime.minit -> go:string."bad g0 stack"
runtime.minit -> go:string."runtime: VirtualQuery failed; errno="
runtime.minit -> go:string."VirtualQuery for stack base failed"
runtime.minit -> go:string."runtime: CreateWaitableTimerEx failed; errno="
runtime.minit -> go:string."CreateWaitableTimerEx when creating timer failed"
runtime.minit -> go:string."runtime.minit: duplicatehandle failed; errno="
runtime.minit -> go:string."runtime.minit: duplicatehandle failed"
runtime.stdcall0 -> reflect.funcName.stkobj
runtime.mstartm0 -> runtime.newextram
runtime.mexit -> runtime.unminit
runtime.mexit -> runtime.ncgocall
runtime.mexit -> runtime.mdestroy
runtime.mexit -> runtime.exitThread
runtime.mexit -> go:string."m not found in allm"
runtime.mexit -> go:string."locked m0 woke up"
runtime.exitThread -> go:string."exitThread"
runtime.newextram -> runtime.extraMWaiters
runtime.newextram -> runtime.oneNewExtraM
runtime.oneNewExtraM -> runtime.traceOneNewExtraM
runtime.oneNewExtraM -> runtime.addExtraM
runtime.addExtraM -> runtime.lockextra
runtime.addExtraM -> runtime.extraM
 -> go:info.runtime.m
 -> go:info.runtime/internal/atomic.Uintptr
 -> go:info.runtime.memoryBasicInformation
 -> go:info.runtime.createHighResTimer$abstract
 -> go:info.runtime/internal/atomic.(*Uint32).Swap$abstract
 -> go:info.runtime.usleep_no_g$abstract
 -> go:info.runtime.osyield_no_g$abstract
 -> go:info.runtime.unlockextra$abstract
runtime.gogo -> gogo
runtime.mcall -> runtime.badmcall
runtime.mcall -> runtime.badmcall2
runtime.mcall -> go:sehuw.12.AQQCBQQDAVAAAAAA
runtime.badmcall -> runtime.badmcall
runtime.badmcall -> go:string."runtime: mcall called on m->g0 stack"
runtime.badmcall2 -> runtime.badmcall2
runtime.badmcall2 -> go:string."runtime: mcall function returned"
runtime.systemstack -> gosave_systemstack_switch
runtime.systemstack -> runtime.badsystemstack
gosave_systemstack_switch -> runtime.systemstack_switch
gosave_systemstack_switch -> runtime.abort
runtime.badsystemstack -> runtime.badsystemstack
runtime.badsystemstack -> go:string."fatal: systemstack called from unexpected goroutine"
 -> go:info.runtime.writeErrStr$abstract
runtime.morestack -> runtime.badmorestackg0
runtime.morestack -> runtime.badmorestackgsignal
runtime.morestack -> runtime.newstack
runtime.badmorestackg0 -> runtime.badmorestackg0
runtime.badmorestackg0 -> go:string."fatal: morestack on g0\n"
runtime.badmorestackgsignal -> runtime.badmorestackgsignal
runtime.badmorestackgsignal -> go:string."fatal: morestack on gsignal\n"
runtime.newstack -> runtime.newstack
runtime.newstack -> go:string."runtime: newstack sp="
runtime.newstack -> go:string." stack=["
runtime.newstack -> go:string."]\n\tmorebuf={pc:"
runtime.newstack -> go:string." sp:"
runtime.newstack -> go:string." lr:"
runtime.newstack -> go:string."}\n\tsched={pc:"
runtime.newstack -> go:string." ctxt:"
runtime.newstack -> runtime.preemptPark
runtime.newstack -> runtime.gopreempt_m
runtime.newstack -> runtime.funcMaxSPDelta
runtime.newstack -> runtime.maxstackceiling
runtime.newstack -> go:string."runtime: goroutine stack exceeds "
runtime.newstack -> go:string."-byte limit\n"
runtime.newstack -> go:string."runtime: sp="
runtime.newstack -> go:string."stack overflow"
runtime.newstack -> go:string."runtime: g is running but p is not"
runtime.newstack -> go:string."runtime: preempt g0"
runtime.newstack -> go:string.", gp->status="
runtime.newstack -> go:string."\n "
runtime.newstack -> go:string."runtime: split stack overflow: "
runtime.newstack -> go:string." < "
runtime.newstack -> go:string."runtime: split stack overflow"
runtime.newstack -> go:string."missing stack in newstack"
runtime.newstack -> go:string."(unknown)"
runtime.newstack -> go:string."runtime: newstack at "
runtime.newstack -> go:string."runtime: stack split at bad time"
runtime.newstack -> go:string."runtime: newstack called from g="
runtime.newstack -> go:string."\n\tm="
runtime.newstack -> go:string." m->curg="
runtime.newstack -> go:string." m->g0="
runtime.newstack -> go:string." m->gsignal="
runtime.newstack -> go:string."runtime: wrong goroutine in newstack"
runtime.newstack -> go:string."stack growth after fork"
runtime.newstack -> gclocals·TjPkq92oe7UkpCx33ztNng==
runtime.preemptPark -> runtime.casGToPreemptScan
runtime.preemptPark -> go:string."runtime: unexpected SPWRITE function "
runtime.preemptPark -> go:string." in async preempt\n"
runtime.preemptPark -> go:string."preempt SPWRITE"
runtime.preemptPark -> go:string."preempt at unknown pc"
runtime.preemptPark -> gclocals·js7paaYkWxwoG9K4Sm3VYg==
runtime.preemptPark -> gclocals·jDl8l6wDo0Ceg2bAjjESKg==
 -> go:info.runtime.gobuf
runtime.asmcgocall -> runtime.asmcgocall.args_stackmap
runtime.asmcgocall -> runtime.asmcgocall.arginfo0
runtime.memhash -> runtime.useAeshash
runtime.memhash -> aeshashbody
runtime.memhash -> runtime.memhashFallback
runtime.memhashFallback -> runtime.hashkey
 -> go:info.[4]uintptr
 -> go:info.runtime.r8$abstract
 -> go:info.runtime.r4$abstract
 -> go:info.runtime.readUnaligned32$abstract
 -> go:info.runtime.mix$abstract
aeshashbody -> runtime.aeskeysched
aeshashbody -> masks
aeshashbody -> shifts
 -> go:info.[128]uint8
go:info.runtime.readUnaligned32$abstract -> go:info.*[4]uint8
runtime.memhash32 -> runtime.memhash32Fallback
runtime.memhash64 -> runtime.memhash64Fallback
runtime.goexit -> runtime.goexit1
runtime.goexit1 -> runtime.goexit1
runtime.goexit1 -> runtime.goexit0·f
 -> go:info.runtime.traceGoEnd$abstract
runtime.goexit0·f -> runtime.goexit0
runtime.goexit0 -> runtime.gfput
runtime.goexit0 -> go:string."invalid m->lockedInt = "
runtime.goexit0 -> go:string."internal lockOSThread error"
runtime.gfput -> go:string."gfput: bad status (not Gdead)"
runtime.gcWriteBarrier1 -> gcWriteBarrier
gcWriteBarrier -> runtime.wbBufFlush
runtime.panicIndex -> runtime.goPanicIndex
runtime.goPanicIndex -> go:string."index out of range"
runtime.goPanicIndex -> type:runtime.boundsError <UsedInIface>
runtime.goPanicIndex -> runtime.convTnoptr
runtime.convTnoptr -> gclocals·jMEwbs2xlC8jTxDFNygHZw==
runtime.convTnoptr -> gclocals·Od6IYKVwEagxAjesR7vuiA==
type:runtime.boundsError <UsedInIface> -> type:.eqfunc.runtime.boundsError
type:runtime.boundsError <UsedInIface> -> type:.namedata.*runtime.boundsError-
type:runtime.boundsError <UsedInIface> -> type:*runtime.boundsError <UsedInIface>
type:runtime.boundsError <UsedInIface> -> type:.namedata.y-
type:runtime.boundsError <UsedInIface> -> type:.namedata.signed-
type:runtime.boundsError <UsedInIface> -> type:.namedata.code-
type:runtime.boundsError <UsedInIface> -> type:runtime.boundsErrorCode <UsedInIface>
type:runtime.boundsErrorCode <UsedInIface> -> type:.namedata.*runtime.boundsErrorCode-
type:runtime.boundsErrorCode <UsedInIface> -> type:*runtime.boundsErrorCode <UsedInIface>
type:.eqfunc.runtime.boundsError -> type:.eq.runtime.boundsError
 -> go:info.*runtime.boundsError
runtime.panicIndexU -> runtime.goPanicIndexU
runtime.panicSliceAlen -> runtime.goPanicSliceAlen
runtime.goPanicSliceAlen -> go:string."slice bounds out of range"
runtime.panicSliceAlenU -> runtime.goPanicSliceAlenU
runtime.panicSliceAcap -> runtime.goPanicSliceAcap
runtime.panicSliceAcapU -> runtime.goPanicSliceAcapU
runtime.panicSliceB -> runtime.goPanicSliceB
runtime.panicSliceBU -> runtime.goPanicSliceBU
runtime.panicSlice3Alen -> runtime.goPanicSlice3Alen
runtime.panicSlice3AlenU -> runtime.goPanicSlice3AlenU
runtime.memmove -> runtime.useAVXmemmove
runtime.asyncPreempt -> runtime.asyncPreempt2
runtime.asyncPreempt -> runtime.asyncPreempt.args_stackmap
runtime.asyncPreempt -> runtime.asyncPreempt.arginfo0
runtime.asyncPreempt2 -> runtime.asyncPreempt2
runtime.asyncPreempt2 -> runtime.preemptPark·f
runtime.asyncPreempt2 -> runtime.gopreempt_m·f
_rt0_amd64_windows -> _rt0_amd64
_rt0_amd64 -> runtime.rt0_go
runtime.rt0_go -> runtime.g0
runtime.rt0_go -> runtime.isIntel
runtime.rt0_go -> runtime.processorVersionInfo
runtime.rt0_go -> _cgo_init
runtime.rt0_go -> setg_gcc
runtime.rt0_go -> runtime.wintls
runtime.rt0_go -> runtime.settls
runtime.rt0_go -> runtime.check
runtime.rt0_go -> runtime.args
runtime.rt0_go -> runtime.osinit
runtime.rt0_go -> runtime.schedinit
runtime.rt0_go -> runtime.mainPC
runtime.rt0_go -> runtime.newproc
runtime.rt0_go -> bad_cpu_msg
runtime.rt0_go -> runtime.write
runtime.rt0_go -> runtime.exit
runtime.rt0_go -> runtime.debugCallV2
 -> go:info.runtime.g
runtime.osinit -> runtime.osinit
runtime.osinit -> runtime.asmstdcall
runtime.osinit -> runtime.loadOptionalSyscalls
runtime.osinit -> runtime.preventErrorDialogs
runtime.osinit -> runtime.initExceptionHandler
runtime.osinit -> runtime.initHighResTimer
runtime.osinit -> runtime.osRelax
runtime.osinit -> runtime.timeBeginPeriodRetValue
runtime.osinit -> runtime.initSysDirectory
runtime.osinit -> runtime.initLongPathSupport
runtime.osinit -> runtime.getproccount
runtime.osinit -> runtime._GetSystemInfo
runtime.osinit -> runtime._SetProcessPriorityBoost
runtime.osinit -> gclocals·oHhi4SNplhqyPEy3Hl2UCw==
runtime.initSysDirectory -> runtime.sysDirectory
runtime.initSysDirectory -> runtime._GetSystemDirectoryA
runtime.initSysDirectory -> runtime.sysDirectoryLen
runtime.initSysDirectory -> go:string."Unable to determine system directory"
runtime.loadOptionalSyscalls -> runtime.kernel32dll
runtime.loadOptionalSyscalls -> runtime._LoadLibraryExW
runtime.loadOptionalSyscalls -> runtime.windowsFindfunc
runtime.loadOptionalSyscalls -> runtime._AddVectoredContinueHandler
runtime.loadOptionalSyscalls -> runtime.advapi32dll
runtime.loadOptionalSyscalls -> runtime._RtlGenRandom
runtime.loadOptionalSyscalls -> runtime.ntdlldll
runtime.loadOptionalSyscalls -> runtime._RtlGetCurrentPeb
runtime.loadOptionalSyscalls -> runtime._RtlGetNtVersionNumbers
runtime.loadOptionalSyscalls -> runtime.winmmdll
runtime.loadOptionalSyscalls -> runtime._timeBeginPeriod
runtime.loadOptionalSyscalls -> runtime._timeEndPeriod
runtime.loadOptionalSyscalls -> runtime.ws2_32dll
runtime.loadOptionalSyscalls -> runtime.initWine
runtime.loadOptionalSyscalls -> go:string."WSAGetOverlappedResult not found"
runtime.loadOptionalSyscalls -> go:string."ws2_32.dll not found"
runtime.loadOptionalSyscalls -> go:string."timeBegin/EndPeriod not found"
runtime.loadOptionalSyscalls -> go:string."winmm.dll not found"
runtime.loadOptionalSyscalls -> go:string."ntdll.dll not found"
runtime.loadOptionalSyscalls -> go:string."advapi32.dll not found"
runtime.loadOptionalSyscalls -> go:string."kernel32.dll not found"
runtime.windowsFindfunc -> runtime._GetProcAddress
runtime.windowsFindfunc -> go:string."usage"
runtime.getproccount -> runtime._GetProcessAffinityMask
runtime.initLongPathSupport -> runtime.longFileName
runtime.initLongPathSupport -> runtime.getRandomData
runtime.initLongPathSupport -> runtime._CreateFileA
runtime.initLongPathSupport -> go:string."runtime: warning: IsLongPathAwareProcess failed to enable long paths; proceeding in fixup mode\n"
runtime.initLongPathSupport -> os.canUseLongPaths
runtime.initWine -> runtime._GetSystemTimeAsFileTime
runtime.initWine -> runtime._QueryPerformanceCounter
runtime.initWine -> runtime._QueryPerformanceFrequency
runtime.initWine -> runtime.qpcStartCounter
runtime.initWine -> runtime.qpcMultiplier
runtime.initWine -> runtime.useQPCTime
runtime.initWine -> go:string."QueryPerformanceFrequency overflow 32 bit divider, check nosplit discussion to proceed"
runtime.initWine -> go:string."QueryPerformanceFrequency syscall returned zero, running on unsupported hardware"
runtime.initWine -> go:string."could not find QPC syscalls"
runtime.initWine -> go:string."could not find GetSystemTimeAsFileTime() syscall"
runtime.getRandomData -> runtime.extendRandom
runtime.preventErrorDialogs -> runtime._GetErrorMode
runtime.preventErrorDialogs -> runtime._SetErrorMode
runtime.preventErrorDialogs -> runtime._WerGetFlags
runtime.preventErrorDialogs -> runtime._WerSetFlags
runtime.initExceptionHandler -> runtime.exceptiontramp
runtime.initExceptionHandler -> runtime._AddVectoredExceptionHandler
runtime.initExceptionHandler -> runtime.firstcontinuetramp
runtime.initExceptionHandler -> runtime.lastcontinuetramp
runtime.initExceptionHandler -> runtime._SetUnhandledExceptionFilter
 -> go:info.[13]uint16
 -> go:info.[10]uint16
 -> go:info.[11]uint16
 -> go:info.[261]uint8
 -> go:info.[523]uint8
 -> go:info.runtime.windowsLoadSystemLib$abstract
 -> go:info.runtime.systeminfo
 -> go:info.runtime.getPageSize$abstract
runtime.schedinit -> runtime.schedinit
runtime.schedinit -> runtime.moduledataverify1
runtime.schedinit -> runtime.mallocinit
runtime.schedinit -> internal/cpu.Initialize
runtime.schedinit -> runtime.x86HasSSE41
runtime.schedinit -> runtime.x86HasFMA
runtime.schedinit -> runtime.alginit
runtime.schedinit -> runtime.modulesinit
runtime.schedinit -> runtime.typelinksinit
runtime.schedinit -> runtime.itabsinit
runtime.schedinit -> runtime.stkobjinit
runtime.schedinit -> runtime.goenvs
runtime.schedinit -> runtime.parsedebugvars
runtime.schedinit -> runtime.gcinit
runtime.schedinit -> runtime.disableMemoryProfiling
runtime.schedinit -> go:string."GOMAXPROCS"
runtime.schedinit -> runtime.gogetenv
runtime.schedinit -> runtime.atoi64
runtime.schedinit -> runtime.buildVersion
runtime.schedinit -> go:string."unknown"
runtime.schedinit -> runtime.modinfo
runtime.schedinit -> go:string."unknown runnable goroutine during bootstrap"
runtime.gogetenv -> runtime.envs
runtime.gogetenv -> go:string."getenv before env init"
runtime.mallocinit -> runtime.(*mheap).init
runtime.mallocinit -> runtime.physHugePageShift
runtime.mallocinit -> go:string."system huge page size ("
runtime.mallocinit -> go:string.") must be a power of 2\n"
runtime.mallocinit -> go:string."bad system huge page size"
runtime.mallocinit -> go:string."system page size ("
runtime.mallocinit -> go:string."bad system page size"
runtime.mallocinit -> go:string.") is smaller than minimum page size ("
runtime.mallocinit -> go:string.") is larger than maximum page size ("
runtime.mallocinit -> go:string."failed to get system page size"
runtime.mallocinit -> go:string."bad TinySizeClass"
runtime.gcinit -> runtime.readGOGC
runtime.gcinit -> runtime.readGOMEMLIMIT
runtime.gcinit -> runtime.(*gcControllerState).init
runtime.(*gcControllerState).init -> fmt.(*ss).scanInt.arginfo1
runtime.readGOGC -> go:string."GOGC"
runtime.readGOMEMLIMIT -> go:string."GOMEMLIMIT"
runtime.readGOMEMLIMIT -> runtime.parseByteCount
runtime.readGOMEMLIMIT -> go:string."GOMEMLIMIT="
runtime.readGOMEMLIMIT -> go:string."malformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`"
runtime.(*mheap).init -> runtime.recordspan·f
runtime.(*mheap).init -> runtime.(*fixalloc).init
runtime.(*mheap).init -> runtime.(*pageAlloc).init
runtime.(*mheap).init -> gclocals·Nmte6XAENM/1rcfNBpcjXA==
runtime.(*fixalloc).init -> go:string."runtime: fixalloc size too large"
runtime.(*fixalloc).init -> gclocals·13TDtuL9rVh9U6NSBAHk4w==
runtime.(*pageAlloc).init -> runtime.(*addrRanges).init
runtime.(*pageAlloc).init -> runtime.(*pageAlloc).sysInit
runtime.(*pageAlloc).init -> runtime.(*scavengeIndex).init
runtime.(*pageAlloc).init -> go:string."runtime: root level max pages = "
runtime.(*pageAlloc).init -> go:string."runtime: summary max pages = "
runtime.(*pageAlloc).init -> go:string."root level max pages doesn't fit in summary"
runtime.(*pageAlloc).init -> gclocals·YtH/kLGDroq4A+wxhTZuuQ==
runtime.(*scavengeIndex).init -> runtime.(*scavengeIndex).sysInit
runtime.(*pageAlloc).sysInit -> go:string."failed to reserve page summary memory"
runtime.(*scavengeIndex).sysInit -> gclocals·KZrB1y+lqctuygdernvR/g==
runtime.goenvs -> runtime._GetEnvironmentStringsW
runtime.goenvs -> runtime.gostringw
runtime.goenvs -> runtime._FreeEnvironmentStringsW
runtime.goenvs -> type:func(uint32) uintptr <UsedInIface>
runtime.goenvs -> runtime.ctrlHandler·f
runtime.goenvs -> syscall.compileCallback
runtime.goenvs -> runtime._SetConsoleCtrlHandler
runtime.goenvs -> runtime.monitorSuspendResume
runtime.goenvs -> gclocals·WFiKlLOLGxjC21pYHZNCjg==
runtime.monitorSuspendResume -> runtime.powrprofdll
runtime.monitorSuspendResume -> type:func(uintptr, uint32, uintptr) uintptr <UsedInIface>
runtime.monitorSuspendResume -> runtime.monitorSuspendResume.func1·f
runtime.parsedebugvars -> go:string."GODEBUG"
runtime.parsedebugvars -> runtime.godebugEnv
runtime.parsedebugvars -> runtime.dbgvars
runtime.parsedebugvars -> runtime.godebugDefault
runtime.parsedebugvars -> runtime.parsegodebug
runtime.parsedebugvars -> go:string."GOTRACEBACK"
runtime.parsedebugvars -> runtime/debug.SetTraceback
runtime.parsedebugvars -> runtime.traceback_env
runtime.parsegodebug -> type:map[string]bool
runtime.parsegodebug -> runtime.mapaccess1_faststr
runtime.parsegodebug -> runtime.mapassign_faststr
runtime.parsegodebug -> go:string..gostring.102.Z2wKHf121bTZsT/ZCqMFPg==
runtime.parsegodebug -> gclocals·JmWCitoALOgbDPUdmo+yGA==
runtime.parsegodebug -> gclocals·REDuWVJv+WSlmvdByJGLtw==
runtime.mapaccess1_faststr -> gclocals·kE0DYMR7pGVKnbvkyXbL9A==
runtime.mapaccess1_faststr -> gclocals·HSr/0yBW3jmC+pu9zHAZOw==
runtime.mapaccess1_faststr -> reflect.mapassign_faststr.stkobj
runtime.mapaccess1_faststr -> reflect.add.arginfo1
runtime.mapassign_faststr -> go:string."concurrent map writes"
runtime.mapassign_faststr -> runtime.hashGrow
runtime.mapassign_faststr -> runtime.growWork_faststr
runtime.mapassign_faststr -> runtime.(*hmap).newoverflow
runtime.mapassign_faststr -> type:runtime.plainError <UsedInIface>
runtime.mapassign_faststr -> runtime..stmp_101
runtime.mapassign_faststr -> gclocals·/AoBRpNiFk8E4ZCqns7SMQ==
runtime.mapassign_faststr -> gclocals·KCpOdE6Ml8xmXI+98ErMnQ==
runtime.(*hmap).newoverflow -> type:runtime.mapextra
runtime.(*hmap).newoverflow -> type:[]*runtime.bmap
runtime.(*hmap).newoverflow -> type:*runtime.bmap
runtime.(*hmap).newoverflow -> gclocals·PrmaJQWdGXnYgjD8uSxfeA==
runtime.hashGrow -> runtime.makeBucketArray
runtime.hashGrow -> go:string."oldoverflow is not nil"
runtime.hashGrow -> gclocals·sFJ8dFKr24TXkTgDKPtggg==
runtime.makeBucketArray -> runtime.newarray
runtime.makeBucketArray -> gclocals·3iNW+PLvQFVHQmli+gLO8Q==
runtime.newarray -> runtime..stmp_91
runtime.growWork_faststr -> runtime.evacuate_faststr
runtime.evacuate_faststr -> runtime.advanceEvacuationMark
runtime.evacuate_faststr -> runtime.typedmemmove
runtime.evacuate_faststr -> go:string."bad map state"
runtime.evacuate_faststr -> gclocals·EVKWQHHPFP6MuLm4GfcARA==
runtime.evacuate_faststr -> gclocals·OJKmj0m3cDUrgsE8ivRzeg==
runtime.evacuate_faststr -> runtime.evacuate.stkobj
runtime.stkobjinit -> type:internal/abi.RegArgs <UsedInIface>
runtime.stkobjinit -> go:string."methodValueCallFrameObjs is not in a module"
runtime.stkobjinit -> go:string."abiRegArgsType needs GC Prog, update methodValueCallFrameObjs"
runtime.stkobjinit -> gclocals·Unomu+3ADQ9kCzfadpasnQ==
runtime.stkobjinit -> runtime.stkobjinit.stkobj
type:internal/abi.RegArgs <UsedInIface> -> type:.eqfunc.internal/abi.RegArgs
type:internal/abi.RegArgs <UsedInIface> -> runtime.gcbits.000000ff01000000
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.*abi.RegArgs.
type:internal/abi.RegArgs <UsedInIface> -> type:*internal/abi.RegArgs <UsedInIface>
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.Ints.
type:internal/abi.RegArgs <UsedInIface> -> type:[9]uintptr <UsedInIface>
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.Floats.
type:internal/abi.RegArgs <UsedInIface> -> type:[15]uint64 <UsedInIface>
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.Ptrs.
type:internal/abi.RegArgs <UsedInIface> -> type:[9]unsafe.Pointer <UsedInIface>
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.ReturnIsPtr.
type:internal/abi.RegArgs <UsedInIface> -> type:internal/abi.IntArgRegBitmap <UsedInIface>
type:internal/abi.IntArgRegBitmap <UsedInIface> -> type:.namedata.*abi.IntArgRegBitmap.
type:internal/abi.IntArgRegBitmap <UsedInIface> -> type:*internal/abi.IntArgRegBitmap <UsedInIface>
type:*internal/abi.IntArgRegBitmap <UsedInIface> -> type:.namedata.Get.
type:*internal/abi.IntArgRegBitmap <UsedInIface> -> type:.namedata.Set.
type:*internal/abi.RegArgs <UsedInIface> -> type:.namedata.Dump.
type:*internal/abi.RegArgs <UsedInIface> -> type:.namedata.IntRegArgAddr.
runtime.gostringw -> runtime.encoderune
runtime.modulesinit -> type:[]*runtime.moduledata
runtime.modulesinit -> type:*runtime.moduledata
runtime.modulesinit -> runtime.progToPointerMask
runtime.progToPointerMask -> go:string."progToPointerMask: overflow"
runtime.moduledataverify1 -> go:string."end"
runtime.moduledataverify1 -> go:string."function symbol table not sorted by PC offset: "
runtime.moduledataverify1 -> go:string." > "
runtime.moduledataverify1 -> go:string." , plugin: "
runtime.moduledataverify1 -> go:string."abi mismatch detected between "
runtime.moduledataverify1 -> go:string."abi mismatch"
runtime.moduledataverify1 -> go:string."minpc= "
runtime.moduledataverify1 -> go:string." min= "
runtime.moduledataverify1 -> go:string." maxpc= "
runtime.moduledataverify1 -> go:string." max= "
runtime.moduledataverify1 -> go:string."minpc or maxpc invalid"
runtime.moduledataverify1 -> go:string."\t "
runtime.moduledataverify1 -> go:string."runtime: pcHeader: magic= "
runtime.moduledataverify1 -> go:string." pad1= "
runtime.moduledataverify1 -> go:string." pad2= "
runtime.moduledataverify1 -> go:string." minLC= "
runtime.moduledataverify1 -> go:string." ptrSize= "
runtime.moduledataverify1 -> go:string." pcHeader.textStart= "
runtime.moduledataverify1 -> go:string." text= "
runtime.moduledataverify1 -> go:string." pluginpath= "
runtime.moduledataverify1 -> go:string."invalid function symbol table"
runtime.moduledataverify1 -> gclocals·Xu4NijPRinf///4s/1zhiQ==
runtime.moduledataverify1 -> gclocals·39LKAhY7fnl9u33eOLjgSg==
runtime.typelinksinit -> type:map[uint32][]*internal/abi.Type
runtime.typelinksinit -> runtime.makemap
runtime.typelinksinit -> runtime.pinnedTypemaps
runtime.typelinksinit -> runtime.mapassign_fast32
runtime.typelinksinit -> runtime.fastrand
runtime.typelinksinit -> runtime.typesEqual
runtime.typelinksinit -> gclocals·nMWWXQwsnu/WLn0q2jROyA==
runtime.typelinksinit -> runtime.typelinksinit.stkobj
runtime.makemap -> type:runtime.hmap
runtime.makemap -> gclocals·IiwFBwJV2dP9tSLC14twTA==
runtime.makemap -> gclocals·tscB6bFX8/bFjArZpiGeaA==
runtime.mapassign_fast32 -> runtime.growWork_fast32
runtime.growWork_fast32 -> runtime.evacuate_fast32
runtime.typesEqual -> type:map[runtime._typePair]struct {}
runtime.typesEqual -> runtime.mapaccess2
runtime.typesEqual -> runtime.mapassign
runtime.typesEqual -> runtime.typesEqual.jump18
runtime.typesEqual -> runtime.typesEqual.jump34
runtime.typesEqual -> runtime.typesEqual.jump63
runtime.typesEqual -> internal/abi.Name.Tag
runtime.typesEqual -> runtime.panicSlice3C
runtime.typesEqual -> go:string."runtime: impossible type kind "
runtime.typesEqual -> go:string."runtime: impossible type kind"
runtime.typesEqual -> gclocals·GzXRQ5PshidyXIghJqGIQw==
runtime.typesEqual -> gclocals·n4oFk2kRQ/x5CcbT3AhDwQ==
 -> go:info.internal/abi.Name.HasTag$abstract
runtime.mapaccess2 -> gclocals·NcOn8W1ImkkMTJ9NAZQ7eA==
runtime.mapassign -> runtime.growWork
runtime.mapassign -> gclocals·TKNuDm3irZe1YV7GFKJxoA==
runtime.mapassign -> gclocals·sXe3n0BrIQMBS1qMQ9CHxQ==
runtime.growWork -> runtime.evacuate
runtime.evacuate -> gclocals·ecGZfvfNO3pXETkBJiIa7g==
runtime.evacuate -> gclocals·k3E4QWn/KnTyQ1i3z1Lhdg==
runtime.encoderune -> strconv.AppendQuoteRune.arginfo1
 -> go:info.runtime/internal/atomic.Pointer[string]
runtime.dbgvars -> runtime..stmp_61
 -> go:info.[]*runtime.dbgVar
 -> go:info.[]map[internal/abi.TypeOff]*internal/abi.Type
runtime..stmp_61 -> runtime..stmp_62
runtime..stmp_61 -> runtime..stmp_63
runtime..stmp_61 -> runtime..stmp_64
runtime..stmp_61 -> runtime..stmp_65
runtime..stmp_61 -> runtime..stmp_66
runtime..stmp_61 -> runtime..stmp_67
runtime..stmp_61 -> runtime..stmp_68
runtime..stmp_61 -> runtime..stmp_69
runtime..stmp_61 -> runtime..stmp_70
runtime..stmp_61 -> runtime..stmp_71
runtime..stmp_61 -> runtime..stmp_72
runtime..stmp_61 -> runtime..stmp_73
runtime..stmp_61 -> runtime..stmp_74
runtime..stmp_61 -> runtime..stmp_75
runtime..stmp_61 -> runtime..stmp_76
runtime..stmp_61 -> runtime..stmp_77
runtime..stmp_61 -> runtime..stmp_78
runtime..stmp_61 -> runtime..stmp_79
runtime..stmp_61 -> runtime..stmp_80
runtime..stmp_61 -> runtime..stmp_81
runtime..stmp_61 -> runtime..stmp_82
runtime..stmp_61 -> runtime..stmp_83
runtime..stmp_61 -> runtime..stmp_84
runtime..stmp_62 -> go:string."allocfreetrace"
runtime..stmp_63 -> go:string."clobberfree"
runtime..stmp_64 -> go:string."cgocheck"
runtime..stmp_65 -> go:string."dontfreezetheworld"
runtime..stmp_66 -> go:string."efence"
runtime..stmp_67 -> go:string."gccheckmark"
runtime..stmp_68 -> go:string."gcpacertrace"
runtime..stmp_69 -> go:string."gcshrinkstackoff"
runtime..stmp_70 -> go:string."gcstoptheworld"
runtime..stmp_71 -> go:string."gctrace"
runtime..stmp_72 -> go:string."invalidptr"
runtime..stmp_73 -> go:string."madvdontneed"
runtime..stmp_74 -> go:string."sbrk"
runtime..stmp_75 -> go:string."scavtrace"
runtime..stmp_76 -> go:string."scheddetail"
runtime..stmp_77 -> go:string."schedtrace"
runtime..stmp_78 -> go:string."tracebackancestors"
runtime..stmp_79 -> go:string."asyncpreemptoff"
runtime..stmp_80 -> go:string."inittrace"
runtime..stmp_81 -> go:string."harddecommit"
runtime..stmp_82 -> go:string."adaptivestackstart"
runtime..stmp_83 -> go:string."tracefpunwindoff"
type:*runtime.moduledata -> type:.namedata.*runtime.moduledata-
type:*runtime.moduledata -> type:runtime.moduledata
type:*runtime.moduledata -> type:.namedata.funcName-
type:*runtime.moduledata -> type:.namedata.textAddr-
type:*runtime.moduledata -> type:.namedata.textOff-
type:runtime.moduledata -> runtime.gcbits.932401000092a4a4d000000000000000
type:runtime.moduledata -> type:.namedata.NotInHeap..embedded
type:runtime.moduledata -> type:.namedata.pcHeader-
type:runtime.moduledata -> type:*runtime.pcHeader
type:runtime.moduledata -> type:.namedata.funcnametab-
type:runtime.moduledata -> type:.namedata.cutab-
type:runtime.moduledata -> type:[]uint32
type:runtime.moduledata -> type:.namedata.filetab-
type:runtime.moduledata -> type:.namedata.pctab-
type:runtime.moduledata -> type:.namedata.pclntable-
type:runtime.moduledata -> type:.namedata.ftab-
type:runtime.moduledata -> type:[]runtime.functab
type:runtime.moduledata -> type:.namedata.findfunctab-
type:runtime.moduledata -> type:.namedata.minpc-
type:runtime.moduledata -> type:.namedata.maxpc-
type:runtime.moduledata -> type:.namedata.text-
type:runtime.moduledata -> type:.namedata.etext-
type:runtime.moduledata -> type:.namedata.noptrdata-
type:runtime.moduledata -> type:.namedata.enoptrdata-
type:runtime.moduledata -> type:.namedata.data-
type:runtime.moduledata -> type:.namedata.edata-
type:runtime.moduledata -> type:.namedata.bss-
type:runtime.moduledata -> type:.namedata.ebss-
type:runtime.moduledata -> type:.namedata.noptrbss-
type:runtime.moduledata -> type:.namedata.enoptrbss-
type:runtime.moduledata -> type:.namedata.covctrs-
type:runtime.moduledata -> type:.namedata.ecovctrs-
type:runtime.moduledata -> type:.namedata.gcdata-
type:runtime.moduledata -> type:.namedata.gcbss-
type:runtime.moduledata -> type:.namedata.types-
type:runtime.moduledata -> type:.namedata.etypes-
type:runtime.moduledata -> type:.namedata.rodata-
type:runtime.moduledata -> type:.namedata.gofunc-
type:runtime.moduledata -> type:.namedata.textsectmap-
type:runtime.moduledata -> type:[]runtime.textsect
type:runtime.moduledata -> type:.namedata.typelinks-
type:runtime.moduledata -> type:.namedata.itablinks-
type:runtime.moduledata -> type:[]*runtime.itab
type:runtime.moduledata -> type:.namedata.ptab-
type:runtime.moduledata -> type:[]runtime.ptabEntry
type:runtime.moduledata -> type:.namedata.pluginpath-
type:runtime.moduledata -> type:.namedata.pkghashes-
type:runtime.moduledata -> type:[]runtime.modulehash
type:runtime.moduledata -> type:.namedata.inittasks-
type:runtime.moduledata -> type:[]*runtime.initTask
type:runtime.moduledata -> type:.namedata.modulename-
type:runtime.moduledata -> type:.namedata.modulehashes-
type:runtime.moduledata -> type:.namedata.hasmain-
type:runtime.moduledata -> type:.namedata.gcdatamask-
type:runtime.moduledata -> type:runtime.bitvector
type:runtime.moduledata -> type:.namedata.gcbssmask-
type:runtime.moduledata -> type:.namedata.typemap-
type:runtime.moduledata -> type:.namedata.bad-
type:*runtime.pcHeader -> type:.namedata.*runtime.pcHeader-
type:*runtime.pcHeader -> type:runtime.pcHeader
type:runtime.pcHeader -> type:.eqfunc72
type:runtime.pcHeader -> type:.namedata.magic-
type:runtime.pcHeader -> type:.namedata.pad1-
type:runtime.pcHeader -> type:.namedata.pad2-
type:runtime.pcHeader -> type:.namedata.minLC-
type:runtime.pcHeader -> type:.namedata.ptrSize-
type:runtime.pcHeader -> type:.namedata.nfunc-
type:runtime.pcHeader -> type:.namedata.nfiles-
type:runtime.pcHeader -> type:.namedata.textStart-
type:runtime.pcHeader -> type:.namedata.funcnameOffset-
type:runtime.pcHeader -> type:.namedata.cuOffset-
type:runtime.pcHeader -> type:.namedata.filetabOffset-
type:runtime.pcHeader -> type:.namedata.pctabOffset-
type:runtime.pcHeader -> type:.namedata.pclnOffset-
type:runtime.bitvector -> type:.eqfunc.runtime.bitvector
type:runtime.bitvector -> type:.namedata.*runtime.bitvector-
type:runtime.bitvector -> type:*runtime.bitvector
type:runtime.bitvector -> type:.namedata.bytedata-
type:*runtime.bitvector -> type:.namedata.ptrbit-
type:*runtime.bmap -> type:.namedata.*runtime.bmap-
type:*runtime.bmap -> type:runtime.bmap
type:*runtime.bmap -> type:.namedata.setoverflow-
type:runtime.bmap -> type:.namedata.tophash-
type:runtime.mapextra -> runtime.gcbits.0700000000000000
type:runtime.mapextra -> type:.namedata.*runtime.mapextra-
type:runtime.mapextra -> type:*runtime.mapextra
type:runtime.mapextra -> type:*[]*runtime.bmap
type:runtime.mapextra -> type:.namedata.oldoverflow-
type:runtime.mapextra -> type:.namedata.nextOverflow-
type:runtime.hmap -> type:.namedata.*runtime.hmap-
type:runtime.hmap -> type:*runtime.hmap
type:runtime.hmap -> type:.namedata.count-
type:runtime.hmap -> type:.namedata.flags-
type:runtime.hmap -> type:.namedata.B.
type:runtime.hmap -> type:.namedata.noverflow-
type:runtime.hmap -> type:.namedata.hash0-
type:runtime.hmap -> type:.namedata.buckets-
type:runtime.hmap -> type:.namedata.oldbuckets-
type:runtime.hmap -> type:.namedata.nevacuate-
type:runtime.hmap -> type:.namedata.extra-
type:*runtime.hmap -> type:.namedata.createOverflow-
type:*runtime.hmap -> type:.namedata.growing-
type:*runtime.hmap -> type:.namedata.incrnoverflow-
type:*runtime.hmap -> type:.namedata.newoverflow-
type:*runtime.hmap -> type:.namedata.noldbuckets-
type:*runtime.hmap -> type:.namedata.oldbucketmask-
type:*runtime.hmap -> type:.namedata.sameSizeGrow-
type:runtime.plainError <UsedInIface> -> type:.namedata.*runtime.plainError-
type:runtime.plainError <UsedInIface> -> type:*runtime.plainError <UsedInIface>
 -> go:info.runtime.initAlgAES$abstract
 -> go:info.runtime.envKeyEqual$abstract
 -> go:info.runtime.lowerASCII$abstract
 -> go:info.runtime.(*bmap).setoverflow$abstract
 -> go:info.runtime.(*hmap).incrnoverflow$abstract
 -> go:info.runtime.(*hmap).createOverflow$abstract
 -> go:info.runtime.overLoadFactor$abstract
 -> go:info.runtime.tophash$abstract
 -> go:info.internal/abi.(*MapType).HashMightPanic$abstract
 -> go:info.internal/abi.(*MapType).IndirectKey$abstract
 -> go:info.internal/abi.(*MapType).IndirectElem$abstract
 -> go:info.runtime.(*hmap).growing$abstract
 -> go:info.runtime.tooManyOverflowBuckets$abstract
 -> go:info.runtime.isEmpty$abstract
 -> go:info.internal/abi.(*MapType).NeedKeyUpdate$abstract
 -> go:info.runtime.(*hmap).oldbucketmask$abstract
 -> go:info.runtime.(*hmap).noldbuckets$abstract
 -> go:info.[2]runtime.evacDst
 -> go:info.internal/abi.(*MapType).ReflexiveKey$abstract
 -> go:info.runtime.bucketEvacuated$abstract
 -> go:info.func(unsafe.Pointer, unsafe.Pointer)
 -> go:info.runtime.(*gcControllerState).setGCPercent$abstract
 -> go:info.runtime/internal/atomic.(*Int32).Store$abstract
 -> go:info.runtime.(*gcControllerState).setMemoryLimit$abstract
 -> go:info.runtime.atoi32$abstract
 -> go:info.runtime.(*mcentral).init$abstract
 -> go:info.runtime.notInHeapSlice
 -> go:info.runtime._DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS·2
 -> go:info.runtime.moduledataverify$abstract
 -> go:info.runtime.stackinit$abstract
 -> go:info.runtime.(*mSpanList).init$abstract
 -> go:info.runtime.cpuinit$abstract
 -> go:info.runtime.fastrandinit$abstract
 -> go:info.*string
 -> go:info.*runtime.dbgVar
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.string]).Store$abstract
 -> go:info.map[string]bool
 -> go:info.runtime.atoi$abstract
 -> go:info.*uint16
 -> go:info.*[70368744177663]uint16
 -> go:info.[8]uint8
 -> go:info.runtime.(*gcControllerState).addGlobals$abstract
 -> go:info.*runtime.pcHeader
 -> go:info.runtime.modulehash
 -> go:info.map[uint32][]*internal/abi.Type
 -> go:info.[]*runtime.moduledata
 -> go:info.[]*internal/abi.Type
 -> go:info.map[internal/abi.TypeOff]*internal/abi.Type
 -> go:info.map[runtime._typePair]struct {}
 -> go:info.struct {}
 -> go:info.runtime._typePair
 -> go:info.**internal/abi.Type
 -> go:info.*internal/abi.ArrayType
 -> go:info.*internal/abi.ChanType
 -> go:info.*internal/abi.FuncType
 -> go:info.*internal/abi.Imethod
 -> go:info.*internal/abi.SliceType
 -> go:info.*internal/abi.StructType
 -> go:info.internal/abi.(*FuncType).InSlice$abstract
 -> go:info.internal/abi.Name.IsEmbedded$abstract
 -> go:info.internal/abi.(*FuncType).OutSlice$abstract
 -> go:info.internal/abi.(*FuncType).NumOut$abstract
internal/cpu.Initialize -> internal/cpu.doinit
internal/cpu.Initialize -> internal/cpu.processOptions
internal/cpu.Initialize -> go:sehuw.12.AQoCBQoDB1AAAAAA
internal/cpu.processOptions -> internal/cpu.options
internal/cpu.processOptions -> go:string."GODEBUG: value \""
internal/cpu.processOptions -> go:string."\" not supported for cpu option \""
internal/cpu.processOptions -> go:string."\"\n"
internal/cpu.processOptions -> go:string."GODEBUG: no value specified for \""
internal/cpu.processOptions -> go:string."GODEBUG: can not enable \""
internal/cpu.processOptions -> go:string."\", missing CPU support\n"
internal/cpu.processOptions -> go:string."GODEBUG: unknown cpu feature \""
internal/cpu.processOptions -> gclocals·5HsMWwMM5F/pFgSwV5E8Vw==
internal/cpu.processOptions -> gclocals·LNUMIKWgmrnB3vMVfO8FBA==
internal/cpu.processOptions -> go:sehuw.12.ARMCBRMDEFAAAAAA
internal/cpu.doinit -> type:[6]internal/cpu.option
internal/cpu.doinit -> go:string."adx"
internal/cpu.doinit -> go:string."aes"
internal/cpu.doinit -> go:string."erms"
internal/cpu.doinit -> go:string."pclmulqdq"
internal/cpu.doinit -> go:string."rdtscp"
internal/cpu.doinit -> go:string."sha"
internal/cpu.doinit -> internal/cpu.getGOAMD64level
internal/cpu.doinit -> type:internal/cpu.option
internal/cpu.doinit -> go:string."popcnt"
internal/cpu.doinit -> go:string."sse3"
internal/cpu.doinit -> go:string."sse41"
internal/cpu.doinit -> go:string."sse42"
internal/cpu.doinit -> go:string."ssse3"
internal/cpu.doinit -> go:string."avx"
internal/cpu.doinit -> go:string."avx2"
internal/cpu.doinit -> go:string."bmi1"
internal/cpu.doinit -> go:string."bmi2"
internal/cpu.doinit -> go:string."fma"
internal/cpu.doinit -> internal/cpu.cpuid
internal/cpu.doinit -> internal/cpu.maxExtendedFunctionInformation
internal/cpu.doinit -> internal/cpu.xgetbv
internal/cpu.doinit -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
 -> go:info.[]internal/cpu.option
type:internal/cpu.option -> type:.eqfunc.internal/cpu.option
type:internal/cpu.option -> type:.namedata.*cpu.option-
type:internal/cpu.option -> type:*internal/cpu.option
type:internal/cpu.option -> type:.importpath.internal/cpu.
type:internal/cpu.option -> type:.namedata.Name.
type:internal/cpu.option -> type:.namedata.Feature.
type:internal/cpu.option -> type:.namedata.Specified.
type:internal/cpu.option -> type:.namedata.Enable.
 -> go:info.internal/cpu.indexByte$abstract
 -> go:info.internal/cpu.isSet$abstract
type:[9]uintptr <UsedInIface> -> type:.namedata.*[9]uintptr-
type:[15]uint64 <UsedInIface> -> type:.eqfunc120
type:[15]uint64 <UsedInIface> -> type:.namedata.*[15]uint64-
type:[15]uint64 <UsedInIface> -> type:[]uint64 <UsedInIface>
type:[9]unsafe.Pointer <UsedInIface> -> runtime.gcbits.ff01000000000000
type:[9]unsafe.Pointer <UsedInIface> -> type:.namedata.*[9]unsafe.Pointer-
type:[9]unsafe.Pointer <UsedInIface> -> type:[]unsafe.Pointer <UsedInIface>
type:.eqfunc.internal/abi.RegArgs -> type:.eq.internal/abi.RegArgs
type:.eq.internal/abi.RegArgs -> go:sehuw.12.AQoCBQoDB1AAAAAA
 -> go:info.*internal/abi.RegArgs
runtime..stmp_91 -> go:string."runtime: allocation size out of range"
runtime..stmp_101 -> go:string."assignment to entry in nil map"
runtime.evacuate.stkobj -> runtime.gcbits.dd00000000000000
runtime.typelinksinit.stkobj -> runtime.gcbits.feff030000000000
runtime.typelinksinit.stkobj -> runtime.gcbits.2049922400000000
runtime/debug.SetTraceback -> runtime.enableWER
syscall.compileCallback -> runtime.(*abiDesc).assignArg
syscall.compileCallback -> runtime.intArgRegs
syscall.compileCallback -> runtime.cbs
syscall.compileCallback -> type:map[runtime.winCallbackKey]int
syscall.compileCallback -> runtime.makemap_small
syscall.compileCallback -> type:runtime.winCallback
syscall.compileCallback -> runtime.callbackasm
syscall.compileCallback -> go:string."too many callback functions"
syscall.compileCallback -> runtime..stmp_143
syscall.compileCallback -> runtime..stmp_142
syscall.compileCallback -> runtime..stmp_139
syscall.compileCallback -> gclocals·5GbM0qDNZ8aIMjx+6HppKQ==
syscall.compileCallback -> syscall.compileCallback.stkobj
syscall.compileCallback -> strconv.index.arginfo1
runtime.(*abiDesc).assignArg -> runtime.(*abiDesc).tryRegAssignArg
runtime.(*abiDesc).assignArg -> type:runtime.abiPart
runtime.(*abiDesc).assignArg -> runtime..stmp_138
runtime.(*abiDesc).assignArg -> runtime..stmp_137
runtime.(*abiDesc).tryRegAssignArg -> runtime.(*abiDesc).tryRegAssignArg.jump3
runtime.(*abiDesc).tryRegAssignArg -> go:string." is currently not supported for use in system callbacks"
runtime.(*abiDesc).tryRegAssignArg -> go:string."compileCallback: type "
 -> go:info.struct { runtime.lock runtime.mutex; runtime.ctxt [2000]runtime.winCallback; runtime.index map[runtime.winCallbackKey]int; runtime.n int }
type:runtime.abiPart -> type:.eqfunc40
type:runtime.abiPart -> type:.namedata.*runtime.abiPart-
type:runtime.abiPart -> type:*runtime.abiPart
type:runtime.abiPart -> type:runtime.abiPartKind
type:runtime.abiPart -> type:.namedata.srcStackOffset-
type:runtime.abiPart -> type:.namedata.dstStackOffset-
type:runtime.abiPart -> type:.namedata.dstRegister-
type:runtime.abiPartKind -> type:.namedata.*runtime.abiPartKind-
type:runtime.abiPartKind -> type:*runtime.abiPartKind
type:*runtime.abiPart -> type:.namedata.tryMerge-
type:runtime.winCallback -> type:.namedata.*runtime.winCallback-
type:runtime.winCallback -> type:*runtime.winCallback
type:runtime.winCallback -> type:*runtime.funcval
type:runtime.winCallback -> type:.namedata.retPop-
type:runtime.winCallback -> type:.namedata.abiMap-
type:runtime.winCallback -> type:runtime.abiDesc
type:runtime.abiDesc -> type:.namedata.*runtime.abiDesc-
type:runtime.abiDesc -> type:*runtime.abiDesc
type:runtime.abiDesc -> type:.namedata.parts-
type:runtime.abiDesc -> type:[]runtime.abiPart
type:runtime.abiDesc -> type:.namedata.srcStackSize-
type:runtime.abiDesc -> type:.namedata.dstStackSize-
type:runtime.abiDesc -> type:.namedata.dstSpill-
type:runtime.abiDesc -> type:.namedata.dstRegisters-
type:runtime.abiDesc -> type:.namedata.retOffset-
type:*runtime.abiDesc -> type:.namedata.assignArg-
type:*runtime.abiDesc -> type:.namedata.assignReg-
type:*runtime.abiDesc -> type:.namedata.tryRegAssignArg-
type:*runtime.funcval -> type:.namedata.*runtime.funcval-
type:*runtime.funcval -> type:runtime.funcval
 -> go:info.*runtime.abiDesc
 -> go:info.[]runtime.abiPart
 -> go:info.runtime.abiPart
 -> go:info.runtime.(*abiPart).tryMerge$abstract
 -> go:info.runtime.(*abiDesc).assignReg$abstract
 -> go:info.runtime.abiDesc
 -> go:info.runtime.winCallbackKey
 -> go:info.runtime.winCallback
 -> go:info.runtime.cbsLock$abstract
 -> go:info.runtime.cbsUnlock$abstract
 -> go:info.runtime.callbackasmAddr$abstract
runtime..stmp_137 -> go:string."compileCallback: argument size is larger than uintptr"
runtime..stmp_138 -> go:string."compileCallback: float arguments not supported"
runtime..stmp_139 -> go:string."compileCallback: expected function with one uintptr-sized result"
runtime..stmp_142 -> go:string."compileCallback: float results not supported"
runtime..stmp_143 -> go:string."compileCallback: function argument frame too large"
runtime.args -> runtime.args
runtime.args -> runtime.int32Hash.arginfo1
runtime.args -> runtime.argc
runtime.args -> runtime.argv
 -> go:info.**uint8
runtime.check -> runtime.check
runtime.check -> runtime.testAtomic64
runtime.check -> runtime.checkASM
runtime.check -> go:string."assembly checks failed"
runtime.check -> go:string."FixedStack is not power-of-2"
runtime.check -> go:string."float32nan2"
runtime.check -> go:string."float32nan"
runtime.check -> go:string."float64nan3"
runtime.check -> go:string."float64nan2"
runtime.check -> go:string."float64nan1"
runtime.check -> go:string."float64nan"
runtime.check -> go:string."atomicand8"
runtime.check -> go:string."atomicor8"
runtime.check -> go:string."cas6"
runtime.check -> go:string."cas5"
runtime.check -> go:string."cas4"
runtime.check -> go:string."cas3"
runtime.check -> go:string."cas2"
runtime.check -> go:string."cas1"
runtime.check -> go:string."bad timediv"
runtime.testAtomic64 -> runtime.test_z64
runtime.testAtomic64 -> runtime.test_x64
runtime.testAtomic64 -> go:string."xchg64 failed"
runtime.testAtomic64 -> go:string."xadd64 failed"
runtime.testAtomic64 -> go:string."store64 failed"
runtime.testAtomic64 -> go:string."load64 failed"
runtime.testAtomic64 -> go:string."cas64 failed"
 -> go:info.[4]uint8
go:info.runtime.(*abiPart).tryMerge$abstract -> go:info.*runtime.abiPart
go:info.runtime/internal/atomic.(*Pointer[go.shape.string]).Store$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.string]
go:info.runtime/internal/atomic.(*Pointer[go.shape.string]).Store$abstract -> go:info.*go.shape.string
type:[]uint32 -> type:.namedata.*[]uint32-
type:[]runtime.functab -> type:.namedata.*[]runtime.functab-
type:[]runtime.functab -> type:runtime.functab
type:runtime.functab -> type:.namedata.*runtime.functab-
type:runtime.functab -> type:*runtime.functab
type:runtime.functab -> type:.namedata.entryoff-
type:runtime.functab -> type:.namedata.funcoff-
type:[]runtime.textsect -> type:.namedata.*[]runtime.textsect-
type:[]runtime.textsect -> type:runtime.textsect
type:runtime.textsect -> type:.namedata.*runtime.textsect-
type:runtime.textsect -> type:*runtime.textsect
type:runtime.textsect -> type:.namedata.vaddr-
type:runtime.textsect -> type:.namedata.baseaddr-
type:[]*runtime.itab -> type:.namedata.*[]*runtime.itab-
type:[]*runtime.itab -> type:*runtime.itab
type:*runtime.itab -> type:.namedata.*runtime.itab-
type:*runtime.itab -> type:runtime.itab
type:runtime.itab -> type:.eqfunc.runtime.itab
type:runtime.itab -> type:.namedata.inter-
type:runtime.itab -> type:*internal/abi.InterfaceType
type:runtime.itab -> type:.namedata._type-
type:runtime.itab -> type:.namedata.hash-
type:runtime.itab -> type:[4]uint8
type:runtime.itab -> type:.namedata.fun-
type:runtime.itab -> type:[1]uintptr
type:*internal/abi.InterfaceType -> type:.namedata.*abi.InterfaceType.
type:*internal/abi.InterfaceType -> type:internal/abi.InterfaceType
type:internal/abi.InterfaceType -> runtime.gcbits.d800000000000000
type:internal/abi.InterfaceType -> type:.namedata.Type..embedded
type:internal/abi.InterfaceType -> type:.namedata.PkgPath.
type:internal/abi.InterfaceType -> type:internal/abi.Name
type:internal/abi.InterfaceType -> type:.namedata.Methods.
type:internal/abi.InterfaceType -> type:[]internal/abi.Imethod
type:internal/abi.Name -> type:.namedata.*abi.Name.
type:internal/abi.Name -> type:*internal/abi.Name
type:internal/abi.Name -> type:.namedata.Bytes.
type:internal/abi.Name -> type:.namedata.Data.
type:internal/abi.Name -> type:.namedata.DataChecked.
type:internal/abi.Name -> type:.namedata.HasTag.
type:internal/abi.Name -> type:.namedata.IsBlank.
type:internal/abi.Name -> type:.namedata.IsEmbedded.
type:internal/abi.Name -> type:.namedata.IsExported.
type:internal/abi.Name -> type:.namedata.ReadVarint.
type:internal/abi.Name -> type:.namedata.Tag.
type:[4]uint8 -> type:.namedata.*[4]uint8-
type:[1]uintptr -> type:.namedata.*[1]uintptr-
type:[]internal/abi.Imethod -> type:.namedata.*[]abi.Imethod-
type:[]internal/abi.Imethod -> type:internal/abi.Imethod
type:internal/abi.Imethod -> type:.namedata.*abi.Imethod.
type:internal/abi.Imethod -> type:*internal/abi.Imethod
type:internal/abi.Imethod -> type:.namedata.Typ.
type:.eqfunc.runtime.itab -> type:.eq.runtime.itab
type:[]runtime.ptabEntry -> type:.namedata.*[]runtime.ptabEntry-
type:[]runtime.ptabEntry -> type:runtime.ptabEntry
type:runtime.ptabEntry -> type:.namedata.*runtime.ptabEntry-
type:runtime.ptabEntry -> type:*runtime.ptabEntry
type:runtime.ptabEntry -> type:.namedata.name-
type:runtime.ptabEntry -> type:.namedata.typ-
type:[]runtime.modulehash -> type:.namedata.*[]runtime.modulehash-
type:[]runtime.modulehash -> type:runtime.modulehash
type:runtime.modulehash -> type:.eqfunc.runtime.modulehash
type:runtime.modulehash -> type:.namedata.*runtime.modulehash-
type:runtime.modulehash -> type:*runtime.modulehash
type:runtime.modulehash -> type:.namedata.linktimehash-
type:runtime.modulehash -> type:.namedata.runtimehash-
type:.eqfunc.runtime.modulehash -> type:.eq.runtime.modulehash
 -> go:info.*runtime.modulehash
type:[]*runtime.initTask -> type:.namedata.*[]*runtime.initTask-
type:[]*runtime.initTask -> type:*runtime.initTask
type:*runtime.initTask -> type:.namedata.*runtime.initTask-
type:*runtime.initTask -> type:runtime.initTask
type:runtime.initTask -> type:.namedata.nfns-
type:.eqfunc.runtime.bitvector -> type:.eq.runtime.bitvector
type:func(uint32) uintptr <UsedInIface> -> type:.namedata.*func(uint32) uintptr-
type:[]uint64 <UsedInIface> -> type:.namedata.*[]uint64-
type:[]runtime.abiPart -> type:.namedata.*[]runtime.abiPart-
type:[]*runtime.bmap -> type:.namedata.*[]*runtime.bmap-
type:[]*runtime.moduledata -> type:.namedata.*[]*runtime.moduledata-
type:func(uintptr, uint32, uintptr) uintptr <UsedInIface> -> type:.namedata.*func(uintptr, uint32, uintptr) uintptr-
type:map[runtime._typePair]struct {} -> type:.namedata.*map[runtime._typePair]struct {}-
type:map[runtime._typePair]struct {} -> type:runtime._typePair
type:map[runtime._typePair]struct {} -> type:struct {}
type:map[runtime._typePair]struct {} -> type:noalg.map.bucket[runtime._typePair]struct {}
type:map[runtime._typePair]struct {} -> runtime.memhash128·f
type:runtime._typePair -> type:.namedata.*runtime._typePair-
type:runtime._typePair -> type:*runtime._typePair
type:runtime._typePair -> type:.namedata.t1-
type:runtime._typePair -> type:.namedata.t2-
type:struct {} -> type:.namedata.*struct {}-
type:noalg.map.bucket[runtime._typePair]struct {} -> type:.namedata.*map.bucket[runtime._typePair]struct {}-
type:noalg.map.bucket[runtime._typePair]struct {} -> type:noalg.[8]runtime._typePair
type:noalg.map.bucket[runtime._typePair]struct {} -> type:noalg.[8]struct {}
type:noalg.[8]struct {} -> type:.namedata.*[8]struct {}-
type:noalg.[8]struct {} -> type:[]struct {}
type:[]struct {} -> type:.namedata.*[]struct {}-
type:noalg.[8]runtime._typePair -> runtime.gcbits.ffff000000000000
type:noalg.[8]runtime._typePair -> type:.namedata.*[8]runtime._typePair-
type:noalg.[8]runtime._typePair -> type:[]runtime._typePair
type:[]runtime._typePair -> type:.namedata.*[]runtime._typePair-
runtime.memhash128·f -> runtime.memhash128
type:map[runtime.winCallbackKey]int -> type:.namedata.*map[runtime.winCallbackKey]int-
type:map[runtime.winCallbackKey]int -> type:runtime.winCallbackKey
type:map[runtime.winCallbackKey]int -> type:noalg.map.bucket[runtime.winCallbackKey]int
type:map[runtime.winCallbackKey]int -> type:.hashfunc.runtime.winCallbackKey
type:runtime.winCallbackKey -> type:.eqfunc.runtime.winCallbackKey
type:runtime.winCallbackKey -> type:.namedata.*runtime.winCallbackKey-
type:runtime.winCallbackKey -> type:*runtime.winCallbackKey
type:runtime.winCallbackKey -> type:.namedata.cdecl-
type:.eqfunc.runtime.winCallbackKey -> type:.eq.runtime.winCallbackKey
 -> go:info.*runtime.winCallbackKey
type:noalg.map.bucket[runtime.winCallbackKey]int -> runtime.gcbits.aaaa000200000000
type:noalg.map.bucket[runtime.winCallbackKey]int -> type:.namedata.*map.bucket[runtime.winCallbackKey]int-
type:noalg.map.bucket[runtime.winCallbackKey]int -> type:noalg.[8]runtime.winCallbackKey
type:noalg.map.bucket[runtime.winCallbackKey]int -> type:noalg.[8]int
type:noalg.[8]int -> type:.namedata.*[8]int-
type:noalg.[8]int -> type:[]int
type:[]int -> type:.namedata.*[]int-
type:noalg.[8]runtime.winCallbackKey -> runtime.gcbits.5555000000000000
type:noalg.[8]runtime.winCallbackKey -> type:.namedata.*[8]runtime.winCallbackKey-
type:noalg.[8]runtime.winCallbackKey -> type:[]runtime.winCallbackKey
type:[]runtime.winCallbackKey -> type:.namedata.*[]runtime.winCallbackKey-
type:.hashfunc.runtime.winCallbackKey -> type:.hash.runtime.winCallbackKey
type:map[string]bool -> type:.namedata.*map[string]bool-
type:map[string]bool -> type:noalg.map.bucket[string]bool
type:map[string]bool -> runtime.strhash·f
runtime.strhash·f -> runtime.strhash
type:noalg.map.bucket[string]bool -> runtime.gcbits.aaaa040000000000
type:noalg.map.bucket[string]bool -> type:.namedata.*map.bucket[string]bool-
type:noalg.map.bucket[string]bool -> type:noalg.[8]string
type:noalg.map.bucket[string]bool -> type:noalg.[8]bool
type:noalg.[8]string -> type:.namedata.*[8]string-
type:noalg.[8]string -> type:[]string
type:noalg.[8]bool -> type:.namedata.*[8]bool-
type:noalg.[8]bool -> type:[]bool
type:[]bool -> type:.namedata.*[]bool-
type:[]string -> type:.namedata.*[]string-
type:map[uint32][]*internal/abi.Type -> type:.namedata.*map[uint32][]*abi.Type-
type:map[uint32][]*internal/abi.Type -> type:noalg.map.bucket[uint32][]*internal/abi.Type
type:noalg.map.bucket[uint32][]*internal/abi.Type -> type:.namedata.*map.bucket[uint32][]*abi.Type-
type:noalg.map.bucket[uint32][]*internal/abi.Type -> type:noalg.[8]uint32
type:noalg.map.bucket[uint32][]*internal/abi.Type -> type:noalg.[8][]*internal/abi.Type
type:noalg.[8]uint32 -> type:.namedata.*[8]uint32-
type:noalg.[8][]*internal/abi.Type -> runtime.gcbits.4992240000000000
type:noalg.[8][]*internal/abi.Type -> type:.namedata.*[8][]*abi.Type-
type:noalg.[8][]*internal/abi.Type -> type:[][]*internal/abi.Type
type:[][]*internal/abi.Type -> type:.namedata.*[][]*abi.Type-
runtime.ctrlHandler·f -> runtime.ctrlHandler
runtime.ctrlHandler -> runtime.sigsend
runtime.sigsend -> runtime.sig
runtime.sigsend -> go:string."sigsend: inconsistent state"
 -> go:info.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state runtime/internal/atomic.Uint32; runtime.delivering runtime/internal/atomic.Uint32; runtime.inuse bool }
 -> go:info.runtime.block$abstract
runtime.monitorSuspendResume.func1·f -> runtime.monitorSuspendResume.func1
runtime.recordspan·f -> runtime.recordspan
runtime.recordspan -> runtime.sysFree
runtime.sysFree -> gclocals·NkFz9ob8NrrpGtxjexQc5A==
 -> go:info.[]*runtime.mspan
runtime.strhash -> runtime.strhashFallback
runtime.checkASM -> runtime.checkASM.args_stackmap
runtime.checkASM -> runtime.checkASM.arginfo0
runtime.debugCallV2 -> runtime.debugCallCheck
runtime.debugCallV2 -> debugCall32
runtime.debugCallV2 -> runtime.debugCallWrap
runtime.debugCallV2 -> debugCall64
runtime.debugCallV2 -> debugCall128
runtime.debugCallV2 -> debugCall256
runtime.debugCallV2 -> debugCall512
runtime.debugCallV2 -> debugCall1024
runtime.debugCallV2 -> debugCall2048
runtime.debugCallV2 -> debugCall4096
runtime.debugCallV2 -> debugCall8192
runtime.debugCallV2 -> debugCall16384
runtime.debugCallV2 -> debugCall32768
runtime.debugCallV2 -> debugCall65536
runtime.debugCallV2 -> debugCallFrameTooLarge
debugCall32 -> go:sehuw.12.ARICBRIDD1AAAAAA
debugCall128 -> go:sehuw.12.AR0CBR0DGlAAAAAA
debugCall256 -> go:sehuw.12.ASACBSADHVAAAAAA
debugCall4096 -> go:sehuw.12.ASQCBSQDIVAAAAAA
runtime.debugCallCheck -> runtime.debugCallCheck
runtime.debugCallCheck -> runtime.debugCallCheck.func1
runtime.debugCallCheck -> go:string."executing on Go runtime stack"
runtime.debugCallCheck -> gclocals·nwxuCj+Mulc1h5gSBd94xQ==
runtime.debugCallCheck -> runtime.debugCallCheck.stkobj
runtime.debugCallCheck.func1 -> go:string."call from unknown function"
runtime.debugCallCheck.func1 -> go:string."call from within the Go runtime"
runtime.debugCallCheck.func1 -> go:string."call not at safe point"
runtime.debugCallCheck.func1 -> gclocals·juSYgsC/UIcgXLIL7+eb6Q==
runtime.debugCallWrap -> runtime.debugCallWrap
runtime.debugCallWrap -> runtime.debugCallWrap.func1
runtime.debugCallWrap -> runtime.debugCallWrap.func2·f
runtime.debugCallWrap -> gclocals·3Y3/4m/OK/DtoFrs9sdV2A==
runtime.debugCallWrap -> runtime.debugCallWrap.stkobj
runtime.debugCallWrap.func1 -> runtime.debugCallWrap1·f
runtime.debugCallWrap.func1 -> type:runtime.debugCallWrapArgs
runtime.debugCallWrap.func1 -> go:string."inconsistent lockedm"
runtime.debugCallWrap.func1 -> gclocals·MWmxllQV+oL9g53kgcO3kw==
type:runtime.debugCallWrapArgs -> type:.namedata.*runtime.debugCallWrapArgs-
type:runtime.debugCallWrapArgs -> type:*runtime.debugCallWrapArgs
type:runtime.debugCallWrapArgs -> type:.namedata.dispatch-
type:runtime.debugCallWrapArgs -> type:.namedata.callingG-
 -> go:info.*runtime.debugCallWrapArgs
runtime.debugCallWrap.stkobj -> runtime.gcbits.3200000000000000
runtime.debugCallWrap.func2·f -> runtime.debugCallWrap.func2
runtime.debugCallWrap1·f -> runtime.debugCallWrap1
runtime.debugCallWrap1 -> runtime.debugCallWrap2
runtime.debugCallWrap1 -> runtime.debugCallWrap1.func1·f
runtime.debugCallWrap2 -> runtime.debugCallWrap2.func1
runtime.debugCallWrap2 -> gclocals·yet6sDYOFtYaEnxEKC0IWA==
runtime.debugCallWrap2 -> runtime.debugCallWrap2.stkobj
runtime.debugCallWrap2 -> io.(*onceError).Store.opendefer
runtime.debugCallWrap2.func1 -> runtime.debugCallPanicked
 -> go:info.runtime.funcval
runtime.debugCallWrap1.func1·f -> runtime.debugCallWrap1.func1
runtime.panicSlice3C -> runtime.goPanicSlice3C
runtime.mainPC -> runtime.main
runtime.main -> runtime.main.func1·f
runtime.main -> runtime.runtime_inittasks
runtime.main -> runtime.doInit1
runtime.main -> runtime.main.func2
runtime.main -> runtime.gcenable
runtime.main -> type:chan bool
runtime.main -> runtime.makechan
runtime.main -> runtime.main_init_done
runtime.main -> _cgo_pthread_key_created
runtime.main -> _cgo_notify_runtime_init_done
runtime.main -> runtime.set_crosscall2
runtime.main -> runtime.startTemplateThread
runtime.main -> runtime.closechan
runtime.main -> runtime.unlockOSThread
runtime.main -> runtime.main_main·f
runtime.main -> runtime.runExitHooks
runtime.main -> go:string."set_crosscall2 missing"
runtime.main -> go:string."_cgo_notify_runtime_init_done missing"
runtime.main -> go:string."_cgo_pthread_key_created missing"
runtime.main -> go:string."nanotime returning zero"
runtime.main -> go:string."runtime.main not on m0"
runtime.main -> gclocals·JKROx8e9XTgEw5brTmIF1g==
runtime.main -> io.(*onceError).Store.stkobj
runtime.main -> runtime.main.opendefer
runtime.makechan -> runtime..stmp_92
runtime.makechan -> go:string."makechan: bad alignment"
runtime.makechan -> go:string."makechan: invalid channel element type"
runtime.closechan -> runtime.typedmemclr
runtime.closechan -> runtime.closechan.func1
runtime.closechan -> runtime..stmp_97
runtime.closechan -> runtime..stmp_96
runtime.closechan -> gclocals·4sERXIH3V0NW1wnC/uQSyQ==
runtime.runExitHooks -> runtime.exitHooks
runtime.runExitHooks -> runtime.runExitHooks.func1·f
runtime.runExitHooks -> go:string."internal error: exit hook invoked panic"
runtime.runExitHooks -> go:string."internal error: exit hook invoked exit"
runtime.gcenable -> type:chan int
runtime.gcenable -> type:noalg.struct { F uintptr; runtime..autotmp_1 chan int }
runtime.gcenable -> runtime.gcenable.func1
runtime.gcenable -> type:noalg.struct { F uintptr; runtime..autotmp_2 chan int }
runtime.gcenable -> runtime.gcenable.func2
runtime.gcenable -> runtime.chanrecv1
runtime.chanrecv1 -> runtime.chanrecv
runtime.chanrecv -> go:string."unreachable"
runtime.chanrecv -> runtime.gcWriteBarrier5
runtime.chanrecv -> runtime.chanparkcommit·f
runtime.chanrecv -> go:string."G waiting list is corrupted"
runtime.chanrecv -> runtime.chanrecv.func1
runtime.chanrecv -> runtime.recv
runtime.chanrecv -> gclocals·CmdfdGItXMUSC1fym9f0uw==
runtime.chanrecv -> gclocals·uwfCjT3h54Ab8NHNQtUojA==
runtime.recv -> runtime.recvDirect
runtime.recv -> runtime.recv.func1
runtime.recv -> gclocals·OMeWtimgvo58gNrJcwLpQQ==
runtime.recv -> gclocals·7nw3WGXeZvA+RxswTVi3aw==
runtime.recv -> runtime.recv.argliveinfo
runtime.recvDirect -> runtime.typeBitsBulkBarrier
runtime.recvDirect -> gclocals·CcEjMr8DNisdVMgXyYQYpg==
runtime.typeBitsBulkBarrier -> go:string."runtime: typeBitsBulkBarrier with type  "
runtime.typeBitsBulkBarrier -> go:string."  with GC prog\n"
runtime.typeBitsBulkBarrier -> go:string."runtime: invalid typeBitsBulkBarrier"
runtime.typeBitsBulkBarrier -> go:string."  of size  "
runtime.typeBitsBulkBarrier -> go:string."  but memory size "
runtime.typeBitsBulkBarrier -> go:string."runtime: typeBitsBulkBarrier without type"
runtime.typeBitsBulkBarrier -> gclocals·v38RuXosoZvFGob7OKVhWw==
runtime.typeBitsBulkBarrier -> runtime.typeBitsBulkBarrier.argliveinfo
runtime.gcenable.func2 -> runtime.bgscavenge
runtime.gcenable.func2 -> runtime.bgscavenge.wrapinfo
runtime.gcenable.func1 -> runtime.bgsweep
runtime.gcenable.func1 -> runtime.bgsweep.wrapinfo
runtime.bgscavenge -> runtime.(*scavengerState).init
runtime.bgscavenge -> runtime.chansend1
runtime.bgscavenge -> runtime.(*scavengerState).park
runtime.bgscavenge -> runtime.(*scavengerState).run
runtime.bgscavenge -> runtime.(*scavengerState).sleep
runtime.chansend1 -> runtime.chansend
runtime.chansend -> runtime.chansend.func1
runtime.chansend -> runtime.send
runtime.chansend -> go:string."chansend: spurious wakeup"
runtime.chansend -> runtime..stmp_94
runtime.chansend -> gclocals·qmf99WUI/PeuzF+MqsWcQg==
runtime.chansend -> gclocals·qxExt+Cw2aJbp577Ym2sqg==
runtime.chansend -> runtime.chansend.arginfo1
runtime.send -> runtime.sendDirect
runtime.send -> runtime.send.func1
runtime.send -> gclocals·vEgytmQ7Fx2/mWWFkHZK7g==
runtime.send -> gclocals·bvzZQ/CnsVICTLF9VDCOYw==
runtime.send -> runtime.send.argliveinfo
runtime.(*scavengerState).init -> type:*runtime.scavengerState <UsedInIface>
runtime.(*scavengerState).init -> runtime.(*scavengerState).init.func1·f
runtime.(*scavengerState).init -> $f64.3f50624dd2f1a9fc
runtime.(*scavengerState).init -> runtime.(*scavengerState).init.func2·f
runtime.(*scavengerState).init -> runtime.(*scavengerState).init.func3·f
runtime.(*scavengerState).init -> runtime.(*scavengerState).init.func4·f
runtime.(*scavengerState).init -> go:string."scavenger state is already wired"
runtime.(*scavengerState).init -> gclocals·wBS4fiKwwXBG0Q3AcyXF/Q==
runtime.(*scavengerState).park -> go:string."tried to park scavenger from another goroutine"
runtime.(*scavengerState).sleep -> $f64.412e848000000000
runtime.(*scavengerState).sleep -> runtime.modtimer
runtime.(*scavengerState).sleep -> runtime.deltimer
runtime.(*scavengerState).sleep -> $f64.3f847ae147ae147b
runtime.(*scavengerState).sleep -> runtime.(*piController).next
runtime.(*scavengerState).sleep -> runtime.(*scavengerState).controllerFailed
runtime.(*scavengerState).sleep -> go:string."tried to sleep scavenger from another goroutine"
runtime.(*scavengerState).run -> $f64.40c3880000000000
runtime.(*scavengerState).run -> go:string."released less than one physical page of memory"
runtime.(*scavengerState).run -> go:string."tried to run scavenger from another goroutine"
runtime.bgsweep -> runtime.goschedIfBusy
runtime.startTemplateThread -> runtime.templateThread·f
runtime.unlockOSThread -> runtime.badunlockosthread·f
runtime.doInit1 -> runtime.funcpkgpath
runtime.doInit1 -> go:string."init "
runtime.doInit1 -> go:string." ms, "
runtime.doInit1 -> go:string." bytes, "
runtime.doInit1 -> go:string." allocs"
runtime.doInit1 -> go:string."inittask with no functions"
runtime.doInit1 -> go:string."recursive call during initialization - linker skew"
runtime.doInit1 -> gclocals·oHzRy6kuSp7HW4luRrcAww==
runtime.doInit1 -> sync/atomic.CompareAndSwapPointer.stkobj
runtime.deltimer -> runtime.deltimer.jump8
runtime.deltimer -> gclocals·5guPwgO/oTXXYbwnvNmqbw==
runtime.modtimer -> runtime.modtimer.jump13
runtime.modtimer -> go:string."timer period must be non-negative"
runtime.modtimer -> go:string."timer when must be positive"
runtime.modtimer -> gclocals·1A0y6sF9OMUm7YoLdQhurA==
runtime.modtimer -> gclocals·VACyJ77YKZVdetlNk+a7eA==
runtime.modtimer -> time.modTimer.arginfo1
runtime.modtimer -> runtime.modtimer.argliveinfo
 -> go:info.struct { runtime.hooks []runtime.exitHook; runtime.runningExitHooks bool }
runtime.runtime_inittasks -> go:runtime.inittasks
 -> go:info.chan bool
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.*runtime.scavengerState-
type:*runtime.scavengerState <UsedInIface> -> type:runtime.scavengerState <UsedInIface>
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.controllerFailed-
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.ready-
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.run-
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.sleep-
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.wake-
type:runtime.scavengerState <UsedInIface> -> runtime.gcbits.0a000f0000000000
type:runtime.scavengerState <UsedInIface> -> type:.namedata.parked-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.sysmonWake-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.targetCPUFraction-
type:runtime.scavengerState <UsedInIface> -> type:float64 <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.sleepRatio-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.sleepController-
type:runtime.scavengerState <UsedInIface> -> type:runtime.piController <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.controllerCooldown-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.printControllerReset-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.sleepStub-
type:runtime.scavengerState <UsedInIface> -> type:func(int64) int64 <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.scavenge-
type:runtime.scavengerState <UsedInIface> -> type:func(uintptr) (uintptr, int64) <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.shouldStop-
type:runtime.scavengerState <UsedInIface> -> type:func() bool <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.gomaxprocs-
type:runtime.scavengerState <UsedInIface> -> type:func() int32 <UsedInIface>
type:float64 <UsedInIface> -> type:*float64 <UsedInIface>
type:runtime.piController <UsedInIface> -> type:.eqfunc.runtime.piController
type:runtime.piController <UsedInIface> -> type:.namedata.*runtime.piController-
type:runtime.piController <UsedInIface> -> type:*runtime.piController <UsedInIface>
type:runtime.piController <UsedInIface> -> type:.namedata.kp-
type:runtime.piController <UsedInIface> -> type:.namedata.ti-
type:runtime.piController <UsedInIface> -> type:.namedata.tt-
type:runtime.piController <UsedInIface> -> type:.namedata.min-
type:runtime.piController <UsedInIface> -> type:.namedata.max-
type:runtime.piController <UsedInIface> -> type:.namedata.errIntegral-
type:runtime.piController <UsedInIface> -> type:.namedata.errOverflow-
type:runtime.piController <UsedInIface> -> type:.namedata.inputOverflow-
 -> go:info.runtime.(*hchan).raceaddr$abstract
 -> go:info.runtime.full$abstract
 -> go:info.runtime.(*waitq).dequeue$abstract
 -> go:info.runtime.(*waitq).enqueue$abstract
 -> go:info.runtime.chanbuf$abstract
 -> go:info.runtime.empty$abstract
 -> go:info.func(func()) bool
 -> go:info.chan int
 -> go:info.time.resetTimer$abstract
 -> go:info.runtime.resettimer$abstract
 -> go:info.time.stopTimer$abstract
 -> go:info.*runtime.piController
 -> go:info.runtime.isInf$abstract
 -> go:info.runtime.isNaN$abstract
 -> go:info.runtime.isFinite$abstract
 -> go:info.runtime.(*piController).reset$abstract
 -> go:info.runtime.lockOSThread$abstract
 -> go:info.runtime.dolockOSThread$abstract
 -> go:info.runtime.doInit$abstract
 -> go:info.runtime.dounlockOSThread$abstract
 -> go:info.*runtime.initTask
 -> go:info.runtime.itoa$abstract
 -> go:info.runtime.funcNameForPrint$abstract
 -> go:info.runtime.updateTimerModifiedEarliest$abstract
type:func() int32 <UsedInIface> -> type:.namedata.*func() int32-
type:func() bool <UsedInIface> -> type:.namedata.*func() bool-
type:chan int -> type:.namedata.*chan int-
runtime..stmp_92 -> go:string."makechan: size out of range"
runtime..stmp_94 -> go:string."send on closed channel"
runtime..stmp_96 -> go:string."close of nil channel"
runtime..stmp_97 -> go:string."close of closed channel"
go:info.runtime.(*waitq).dequeue$abstract -> go:info.*runtime.waitq
go:info.runtime.doInit$abstract -> go:info.[]*runtime.initTask
type:func(int64) int64 <UsedInIface> -> type:.namedata.*func(int64) int64-
type:.eqfunc.runtime.piController -> type:.eq.runtime.piController
type:func(uintptr) (uintptr, int64) <UsedInIface> -> type:.namedata.*func(uintptr) (uintptr, int64)-
type:chan bool -> type:.namedata.*chan bool-
type:noalg.struct { F uintptr; runtime..autotmp_1 chan int } -> type:.namedata.*struct { F uintptr; .autotmp_1 chan int }-
type:noalg.struct { F uintptr; runtime..autotmp_1 chan int } -> type:.namedata..F-
type:noalg.struct { F uintptr; runtime..autotmp_1 chan int } -> type:.namedata..autotmp_1-
type:noalg.struct { F uintptr; runtime..autotmp_2 chan int } -> type:.namedata.*struct { F uintptr; .autotmp_2 chan int }-
type:noalg.struct { F uintptr; runtime..autotmp_2 chan int } -> type:.namedata..autotmp_2-
runtime.main_main·f -> main.main
main.main -> go:string."Method"
main.main -> reflect.Value.MethodByName <ReflectMethod>
main.main -> type:reflect.Value <UsedInIface>
main.main -> runtime.convT
main.main -> os.Stdout
main.main -> go:itab.*os.File,io.Writer
main.main -> fmt.Fprintln
main.main -> gclocals·JpGpk77G7iIS0pdRibK5rg==
main.main -> main.main.stkobj
main.main -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
 -> go:info.reflect.Value
 -> go:info.reflect.ValueOf$abstract
 -> go:info.reflect.unpackEface$abstract
 -> go:info.internal/abi.(*Type).IfaceIndir$abstract
 -> go:info.fmt.Println$abstract
fmt.Fprintln -> fmt.newPrinter
fmt.Fprintln -> fmt.(*pp).doPrintln
fmt.Fprintln -> fmt.(*pp).free
fmt.Fprintln -> gclocals·RT1JGNq6OcJkunM7qcDolg==
fmt.Fprintln -> gclocals·6FDJXLmAY6fdV5V/zopYfw==
fmt.Fprintln -> fmt.Errorf.arginfo1
fmt.Fprintln -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
fmt.newPrinter -> fmt.ppFree
fmt.newPrinter -> sync.(*Pool).Get
fmt.newPrinter -> type:*fmt.pp
fmt.newPrinter -> runtime.panicdottypeE
fmt.(*pp).free -> type:*fmt.pp <UsedInIface>
fmt.(*pp).free -> sync.(*Pool).Put
fmt.(*pp).doPrintln -> fmt.(*pp).printArg
fmt.(*pp).doPrintln -> gclocals·YK7s5NHmu61HhranEBEZBw==
fmt.(*pp).doPrintln -> gclocals·VztAWi4EvUFJi25QE3jnTg==
fmt.(*pp).printArg -> go:itab.*reflect.rtype,reflect.Type
fmt.(*pp).printArg -> fmt.(*fmt).fmtS
fmt.(*pp).printArg -> fmt.(*pp).fmtPointer
fmt.(*pp).printArg -> fmt.(*pp).fmtString
fmt.(*pp).printArg -> fmt.(*pp).fmtInteger
fmt.(*pp).printArg -> fmt.(*pp).fmtComplex
fmt.(*pp).printArg -> go:string."[]byte"
fmt.(*pp).printArg -> fmt.(*pp).fmtBytes
fmt.(*pp).printArg -> fmt.(*pp).fmtFloat
fmt.(*pp).printArg -> fmt.(*pp).fmtBool
fmt.(*pp).printArg -> reflect.valueInterface
fmt.(*pp).printArg -> fmt.(*pp).handleMethods
fmt.(*pp).printArg -> fmt.(*pp).printValue
fmt.(*pp).printArg -> go:string."<nil>"
fmt.(*pp).printArg -> fmt.(*fmt).padString
fmt.(*pp).printArg -> fmt.(*pp).badVerb
fmt.(*pp).printArg -> gclocals·czJtKcw6+bxo/8eTaAcF0A==
fmt.(*pp).printArg -> gclocals·Pm1eqpVXyPWA2fJxOgbrfA==
fmt.(*pp).printArg -> fmt.(*pp).printArg.stkobj
fmt.(*pp).printArg -> fmt.(*pp).fmtString.arginfo1
fmt.(*pp).printArg -> go:sehuw.12.ARMCBRMDEFAAAAAA
fmt.(*fmt).padString -> unicode/utf8.RuneCountInString
fmt.(*fmt).padString -> fmt.(*fmt).writePadding
fmt.(*fmt).padString -> gclocals·THyWSF6xKWF/BKZFwvOijg==
fmt.(*fmt).padString -> gclocals·QLT0Ly+Zc7eOqEUdCfw/IQ==
fmt.(*pp).badVerb -> unicode/utf8.appendRuneNonASCII
fmt.(*pp).badVerb -> reflect.Value.typeSlow
fmt.(*pp).badVerb -> gclocals·jGjXxzrTPkYjmSye13X+9A==
fmt.(*pp).fmtBool -> fmt.(*fmt).fmtBoolean
fmt.(*pp).fmtBool -> fmt.(*pp).fmtBool.arginfo1
fmt.(*pp).fmtBool -> go:sehuw.12.AQoCBQoDB1AAAAAA
fmt.(*pp).fmtInteger -> fmt.(*fmt).fmtUnicode
fmt.(*pp).fmtInteger -> fmt.(*fmt).fmtC
fmt.(*pp).fmtInteger -> go:string."0123456789abcdefx"
fmt.(*pp).fmtInteger -> fmt.(*fmt).fmtInteger
fmt.(*pp).fmtInteger -> go:string."0123456789ABCDEFX"
fmt.(*pp).fmtInteger -> fmt.(*pp).fmt0x64
fmt.(*pp).fmtInteger -> fmt.(*fmt).fmtQc
fmt.(*pp).fmtInteger -> fmt.(*pp).fmtInteger.arginfo1
fmt.(*fmt).fmtUnicode -> strconv.IsPrint
fmt.(*fmt).fmtUnicode -> unicode/utf8.EncodeRune
fmt.(*fmt).fmtUnicode -> fmt.(*fmt).pad
fmt.(*fmt).pad -> unicode/utf8.RuneCount
fmt.(*fmt).fmtInteger -> fmt..stmp_3
fmt.(*fmt).fmtInteger -> gclocals·dAEQfkX+CmyUTfVKHTwEyQ==
fmt.(*fmt).fmtInteger -> fmt.(*fmt).fmtInteger.arginfo1
fmt.(*fmt).fmtInteger -> fmt.(*fmt).fmtInteger.argliveinfo
fmt.(*fmt).fmtQc -> strconv.appendQuotedRuneWith
fmt.(*pp).fmtFloat -> fmt.(*fmt).fmtFloat
fmt.(*pp).fmtFloat -> fmt.(*pp).fmtFloat.arginfo1
fmt.(*fmt).fmtFloat -> strconv.genericFtoa
fmt.(*fmt).fmtFloat -> gclocals·mlHaC5xEQP3YmChGxFqrzQ==
fmt.(*fmt).fmtFloat -> gclocals·WSzv42LJZ33rmU2aJVRGWg==
fmt.(*fmt).fmtFloat -> fmt.(*fmt).fmtFloat.arginfo1
fmt.(*fmt).fmtFloat -> fmt.(*fmt).fmtFloat.argliveinfo
fmt.(*pp).fmtComplex -> fmt.(*pp).fmtComplex.arginfo1
fmt.(*pp).fmtComplex -> fmt.(*pp).fmtComplex.argliveinfo
fmt.(*pp).fmtString -> fmt.(*fmt).fmtQ
fmt.(*pp).fmtString -> fmt.(*fmt).fmtSbx
fmt.(*fmt).fmtSbx -> gclocals·jjYRaA7sv+FSHVm0VcEIHQ==
fmt.(*fmt).fmtSbx -> fmt.(*fmt).fmtSbx.arginfo1
fmt.(*fmt).fmtSbx -> fmt.(*fmt).fmtSbx.argliveinfo
fmt.(*fmt).fmtQ -> strconv.CanBackquote
fmt.(*fmt).fmtQ -> strconv.appendQuotedWith
fmt.(*fmt).fmtQ -> go:string."`"
fmt.(*pp).fmtBytes -> runtime.convTslice
fmt.(*pp).fmtBytes -> fmt.(*fmt).fmtBs
fmt.(*pp).fmtBytes -> gclocals·6OjZ0a04H8YIBd62D5aeaQ==
fmt.(*pp).fmtBytes -> gclocals·BGa6e7IIXdzuET3ghyKs8A==
fmt.(*pp).fmtBytes -> fmt.(*pp).fmtBytes.arginfo1
fmt.(*pp).fmtBytes -> fmt.(*pp).fmtBytes.argliveinfo
fmt.(*fmt).fmtBs -> fmt.(*fmt).truncate
fmt.(*fmt).truncate -> unicode/utf8.DecodeRune
fmt.(*fmt).truncate -> fmt.(*fmt).truncate.argliveinfo
fmt.(*pp).fmtPointer -> reflect.Value.Pointer
fmt.(*pp).fmtPointer -> gclocals·Fk6a18rDscRrKEKbVX2vWA==
fmt.(*pp).fmtPointer -> gclocals·01/xo09qUtSWTRc8qTJ9Tg==
fmt.(*pp).fmtPointer -> fmt.(*pp).fmtPointer.arginfo1
fmt.(*pp).fmtPointer -> fmt.(*pp).fmtPointer.argliveinfo
fmt.(*pp).handleMethods -> type:fmt.Formatter
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.func3
fmt.(*pp).handleMethods -> runtime.deferprocStack
fmt.(*pp).handleMethods -> type:fmt.Stringer
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.func4
fmt.(*pp).handleMethods -> type:fmt.GoStringer
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.func2
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.func1
fmt.(*pp).handleMethods -> go:itab.*fmt.pp,fmt.State
fmt.(*pp).handleMethods -> gclocals·9MuUDOHRKMCKyi8SApwP1A==
fmt.(*pp).handleMethods -> gclocals·7mzduenLSi8rA8r1Zgum2w==
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.stkobj
fmt.(*pp).handleMethods -> go:sehuw.12.ARYCBRYDE1AAAAAA
fmt.(*pp).handleMethods.func4 -> go:string."String"
fmt.(*pp).handleMethods.func4 -> fmt.(*pp).catchPanic
fmt.(*pp).handleMethods.func4 -> fmt.(*pp).catchPanic.wrapinfo
fmt.(*pp).catchPanic -> gclocals·7W6NV5HLRZ6rDrAf2DAeHg==
fmt.(*pp).catchPanic -> gclocals·1LAMG/2Zpbm9EC2da2J5aw==
fmt.(*pp).catchPanic -> fmt.(*pp).catchPanic.arginfo1
fmt.(*pp).handleMethods.func3 -> go:string."Error"
fmt.(*pp).handleMethods.func2 -> go:string."GoString"
fmt.(*pp).handleMethods.func1 -> go:string."Format"
fmt.(*pp).printValue -> fmt.(*pp).printValue.jump18
fmt.(*pp).printValue -> go:string."<invalid reflect.Value>"
fmt.(*pp).printValue -> reflect.Value.Elem
fmt.(*pp).printValue -> internal/fmtsort.Sort
fmt.(*pp).printValue -> reflect.Value.lenNonSlice
fmt.(*pp).printValue -> reflect.Value.Slice
fmt.(*pp).printValue -> reflect.bytesType
fmt.(*pp).printValue -> reflect.Value.bytesSlow
fmt.(*pp).printValue -> fmt.(*pp).unknownType
fmt.(*pp).printValue -> fmt.getField
fmt.(*pp).printValue -> reflect.Value.NumField
fmt.(*pp).printValue -> reflect.Value.Index
fmt.(*pp).printValue -> type:reflect.ValueError
fmt.(*pp).printValue -> go:string."reflect.Value.Uint"
fmt.(*pp).printValue -> type:*reflect.ValueError <UsedInIface>
fmt.(*pp).printValue -> go:string."reflect.Value.Int"
fmt.(*pp).printValue -> gclocals·vID8S3T2dEZwqIkwkA4DMg==
fmt.(*pp).printValue -> gclocals·4JkWYm3ACU6xeCC5gUdbxQ==
fmt.(*pp).printValue -> fmt.(*pp).printValue.arginfo1
fmt.getField -> reflect.Value.Field
fmt.(*pp).unknownType -> gclocals·TDFV0/D34++ehcXXDsf8Bw==
fmt.(*pp).unknownType -> gclocals·YBx7UlhgSzSqYe9dkt/rmg==
type:*fmt.pp <UsedInIface> -> type:.namedata.*fmt.pp-
type:*fmt.pp <UsedInIface> -> type:fmt.pp <UsedInIface>
type:*fmt.pp <UsedInIface> -> type:.importpath.fmt.
type:*fmt.pp <UsedInIface> -> type:.namedata.Flag.
type:*fmt.pp <UsedInIface> -> type:.namedata.Precision.
type:*fmt.pp <UsedInIface> -> type:.namedata.Width.
type:*fmt.pp <UsedInIface> -> type:.namedata.Write.
type:*fmt.pp <UsedInIface> -> type:.namedata.WriteString.
type:*fmt.pp <UsedInIface> -> type:.namedata.argNumber-
type:*fmt.pp <UsedInIface> -> type:.namedata.badArgNum-
type:*fmt.pp <UsedInIface> -> type:.namedata.badVerb-
type:*fmt.pp <UsedInIface> -> type:.namedata.catchPanic-
type:*fmt.pp <UsedInIface> -> type:.namedata.doPrint-
type:*fmt.pp <UsedInIface> -> type:.namedata.doPrintf-
type:*fmt.pp <UsedInIface> -> type:.namedata.doPrintln-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmt0x64-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtBool-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtBytes-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtComplex-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtFloat-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtInteger-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtPointer-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtString-
type:*fmt.pp <UsedInIface> -> type:.namedata.free-
type:*fmt.pp <UsedInIface> -> type:.namedata.handleMethods-
type:*fmt.pp <UsedInIface> -> type:.namedata.missingArg-
type:*fmt.pp <UsedInIface> -> type:.namedata.printArg-
type:*fmt.pp <UsedInIface> -> type:.namedata.printValue-
type:*fmt.pp <UsedInIface> -> type:.namedata.unknownType-
type:fmt.pp <UsedInIface> -> runtime.gcbits.7101800000000000
type:fmt.pp <UsedInIface> -> type:fmt.buffer <UsedInIface>
type:fmt.pp <UsedInIface> -> type:fmt.fmt <UsedInIface>
type:fmt.pp <UsedInIface> -> type:.namedata.reordered-
type:fmt.pp <UsedInIface> -> type:.namedata.goodArgNum-
type:fmt.pp <UsedInIface> -> type:.namedata.panicking-
type:fmt.pp <UsedInIface> -> type:.namedata.erroring-
type:fmt.pp <UsedInIface> -> type:.namedata.wrapErrs-
type:fmt.pp <UsedInIface> -> type:.namedata.wrappedErrs-
type:fmt.pp <UsedInIface> -> type:[]int <UsedInIface>
type:fmt.buffer <UsedInIface> -> type:.namedata.*fmt.buffer-
type:fmt.buffer <UsedInIface> -> type:*fmt.buffer <UsedInIface>
type:*fmt.buffer <UsedInIface> -> type:.namedata.write-
type:*fmt.buffer <UsedInIface> -> type:.namedata.writeByte-
type:*fmt.buffer <UsedInIface> -> type:.namedata.writeRune-
type:*fmt.buffer <UsedInIface> -> type:.namedata.writeString-
type:fmt.fmt <UsedInIface> -> type:.eqfunc.fmt.fmt
type:fmt.fmt <UsedInIface> -> type:.namedata.*fmt.fmt-
type:fmt.fmt <UsedInIface> -> type:*fmt.fmt <UsedInIface>
type:fmt.fmt <UsedInIface> -> type:.namedata.fmtFlags-.embedded
type:fmt.fmt <UsedInIface> -> type:fmt.fmtFlags <UsedInIface>
type:fmt.fmt <UsedInIface> -> type:.namedata.wid-
type:fmt.fmt <UsedInIface> -> type:.namedata.prec-
type:fmt.fmt <UsedInIface> -> type:.namedata.intbuf-
type:fmt.fmt <UsedInIface> -> type:[68]uint8 <UsedInIface>
type:fmt.fmtFlags <UsedInIface> -> type:.eqfunc9
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.*fmt.fmtFlags-
type:fmt.fmtFlags <UsedInIface> -> type:*fmt.fmtFlags <UsedInIface>
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.widPresent-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.precPresent-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.minus-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.plus-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.sharp-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.space-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.zero-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.plusV-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.sharpV-
type:*fmt.fmt <UsedInIface> -> type:.namedata.clearflags-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtBoolean-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtBs-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtBx-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtC-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtQ-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtQc-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtS-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtSbx-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtSx-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtUnicode-
type:*fmt.fmt <UsedInIface> -> type:.namedata.pad-
type:*fmt.fmt <UsedInIface> -> type:.namedata.padString-
type:*fmt.fmt <UsedInIface> -> type:.namedata.truncate-
type:*fmt.fmt <UsedInIface> -> type:.namedata.truncateString-
type:*fmt.fmt <UsedInIface> -> type:.namedata.writePadding-
fmt.ppFree -> fmt.glob..func1·f
 -> go:info.sync.Pool
type:fmt.Formatter -> type:.namedata.*fmt.Formatter.
type:fmt.Formatter -> type:*fmt.Formatter
type:fmt.Formatter -> type:.namedata.Format.
type:fmt.Formatter -> type:func(fmt.State, int32)
type:fmt.GoStringer -> type:.namedata.*fmt.GoStringer.
type:fmt.GoStringer -> type:*fmt.GoStringer
type:fmt.GoStringer -> type:.namedata.GoString.
type:fmt.Stringer -> type:.namedata.*fmt.Stringer.
type:fmt.Stringer -> type:*fmt.Stringer
 -> go:info.*fmt.fmt
 -> go:info.fmt.buffer
 -> go:info.fmt.(*buffer).write$abstract
 -> go:info.fmt.(*buffer).writeString$abstract
 -> go:info.unicode/utf8.RuneLen$abstract
 -> go:info.fmt.(*fmt).truncateString$abstract
 -> go:info.strconv.AppendQuote$abstract
 -> go:info.strconv.AppendQuoteToASCII$abstract
 -> go:info.unicode/utf8.AppendRune$abstract
 -> go:info.strconv.AppendQuoteRuneToASCII$abstract
 -> go:info.strconv.AppendQuoteRune$abstract
 -> go:info.[6]uint8
 -> go:info.strconv.AppendFloat$abstract
 -> go:info.fmt.(*buffer).writeByte$abstract
 -> go:info.*fmt.pp
 -> go:info.fmt.(*fmt).init$abstract
 -> go:info.fmt.(*fmt).clearflags$abstract
 -> go:info.io.Writer
 -> go:info.[]interface {}
 -> go:info.reflect.Value.Kind$abstract
 -> go:info.reflect.flag.kind$abstract
 -> go:info.reflect.Value.IsNil$abstract
 -> go:info.reflect.Value.IsValid$abstract
 -> go:info.reflect.Value.Type$abstract
 -> go:info.fmt.(*buffer).writeRune$abstract
 -> go:info.reflect.TypeOf$abstract
 -> go:info.reflect.toType$abstract
 -> go:info.fmt.(*fmt).fmtSx$abstract
 -> go:info.fmt.(*fmt).fmtBx$abstract
 -> go:info.fmt.fmtFlags
 -> go:info.fmt.Formatter
 -> go:info.fmt.GoStringer
 -> go:info.fmt.Stringer
 -> go:info.reflect.Value.CanInterface$abstract
 -> go:info.reflect.Value.Interface$abstract
 -> go:info.*internal/fmtsort.SortedMap
 -> go:info.reflect.Type
 -> go:info.reflect.Value.Bool$abstract
 -> go:info.reflect.Value.Int$abstract
 -> go:info.reflect.Value.Uint$abstract
 -> go:info.reflect.Value.Float$abstract
 -> go:info.reflect.Value.Complex$abstract
 -> go:info.reflect.Value.CanAddr$abstract
 -> go:info.reflect.Value.Len$abstract
 -> go:info.reflect.Value.Bytes$abstract
 -> go:info.reflect.Value.String$abstract
reflect.Value.bytesSlow -> reflect..stmp_51
reflect.Value.bytesSlow -> go:string."reflect.Value.Bytes"
reflect.Value.bytesSlow -> runtime.panicunsafeslicenilptr
reflect.Value.bytesSlow -> reflect..stmp_53
reflect.Value.bytesSlow -> reflect..stmp_52
reflect.Value.bytesSlow -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
reflect.Value.Elem -> reflect.verifyNotInHeapPtr
reflect.Value.Elem -> internal/abi.(*Type).NumMethod
reflect.Value.Elem -> reflect..stmp_93
reflect.Value.Elem -> go:string."reflect.Value.Elem"
reflect.Value.Elem -> gclocals·RIv/8N0+7S2xMex1RQ+GRA==
reflect.Value.Field -> reflect..stmp_94
reflect.Value.Field -> go:string."reflect.Value.Field"
reflect.Value.Index -> reflect.uint8Type
reflect.Value.Index -> reflect..stmp_98
reflect.Value.Index -> go:string."reflect.Value.Index"
reflect.Value.Index -> reflect..stmp_18
reflect.Value.Index -> reflect..stmp_96
reflect.valueInterface -> go:string."Interface"
reflect.valueInterface -> reflect.makeMethodValue
reflect.valueInterface -> reflect.Value.NumMethod
reflect.valueInterface -> reflect.packEface
reflect.valueInterface -> reflect..stmp_99
reflect.valueInterface -> go:string."reflect.Value.Interface"
reflect.valueInterface -> reflect.valueInterface.arginfo1
reflect.makeMethodValue -> reflect.methodValueCall
reflect.makeMethodValue -> reflect.funcLayout
reflect.makeMethodValue -> type:reflect.methodValue
reflect.makeMethodValue -> reflect.methodReceiver
reflect.makeMethodValue -> type:reflect.Type
reflect.makeMethodValue -> runtime.panicdottypeI
reflect.makeMethodValue -> reflect..stmp_17
reflect.makeMethodValue -> gclocals·m+yuV0GxbjNSNVwqDXd+Pg==
reflect.makeMethodValue -> gclocals·yvu4wIi4ZJmA8ZHy2CaayQ==
reflect.makeMethodValue -> go:sehuw.12.ARYCBRYDE1AAAAAA
reflect.funcLayout -> reflect.layoutCache
reflect.funcLayout -> type:reflect.layoutKey <UsedInIface>
reflect.funcLayout -> sync.(*Map).Load
reflect.funcLayout -> type:reflect.layoutType <UsedInIface>
reflect.funcLayout -> reflect.newAbiDesc
reflect.funcLayout -> reflect.(*rtype).String
reflect.funcLayout -> go:string.")("
reflect.funcLayout -> go:string."methodargs("
reflect.funcLayout -> runtime.concatstring5
reflect.funcLayout -> go:string."funcargs("
reflect.funcLayout -> internal/abi.NewName
reflect.funcLayout -> reflect.addReflectOff
reflect.funcLayout -> type:sync.Pool
reflect.funcLayout -> type:noalg.struct { F uintptr; reflect.x *internal/abi.Type }
reflect.funcLayout -> reflect.funcLayout.func1
reflect.funcLayout -> sync.(*Map).LoadOrStore
reflect.funcLayout -> go:string."reflect: funcLayout with interface receiver "
reflect.funcLayout -> go:string."reflect: funcLayout of non-func type "
reflect.funcLayout -> gclocals·+B3RfhomkJZi/RphaH45FA==
reflect.funcLayout -> gclocals·F3rvof/DCPPYLCUIwPDBrA==
reflect.funcLayout -> reflect.funcLayout.stkobj
reflect.funcLayout -> reflect.newAbiDesc.arginfo1
reflect.funcLayout -> reflect.newAbiDesc.argliveinfo
reflect.newAbiDesc -> type:reflect.bitVector
reflect.newAbiDesc -> reflect.(*abiSeq).addRcvr
reflect.newAbiDesc -> reflect.(*abiSeq).addArg
reflect.newAbiDesc -> reflect.addTypeBits
reflect.newAbiDesc -> gclocals·321G0Ym/lDXeiBfRy1sRFg==
reflect.newAbiDesc -> gclocals·S+0XXD55KM58+bsQ3vg6cw==
reflect.newAbiDesc -> reflect.newAbiDesc.stkobj
reflect.(*abiSeq).addArg -> reflect.(*abiSeq).regAssign
reflect.(*abiSeq).addArg -> type:reflect.abiSeq
reflect.(*abiSeq).addArg -> type:reflect.abiStep
reflect.(*abiSeq).addArg -> gclocals·HQMy/1JM6rlUYY2s4XzMfg==
reflect.(*abiSeq).addArg -> gclocals·WhUsbJHQAFzb4M6MfKpK7w==
reflect.(*abiSeq).addArg -> go:sehuw.12.ARMCBRMDEFAAAAAA
reflect.(*abiSeq).addRcvr -> reflect.(*abiSeq).assignIntN
reflect.(*abiSeq).regAssign -> reflect.(*abiSeq).regAssign.jump4
reflect.(*abiSeq).regAssign -> reflect.floatArgRegs
reflect.(*abiSeq).regAssign -> reflect.floatRegSize
reflect.(*abiSeq).regAssign -> go:string."t.Kind == "
reflect.(*abiSeq).regAssign -> reflect..stmp_4
reflect.(*abiSeq).regAssign -> gclocals·foM/pdm/hXseFZbhzZY8iA==
reflect.(*abiSeq).assignIntN -> reflect.intArgRegs
reflect.(*abiSeq).assignIntN -> reflect..stmp_7
reflect.(*abiSeq).assignIntN -> reflect..stmp_1
reflect.(*rtype).String -> reflect.resolveNameOff
reflect.(*rtype).String -> go:sehuw.12.AQoCBQoDB1AAAAAA
reflect.funcLayout.func1 -> reflect.unsafe_New
reflect.addTypeBits -> gclocals·e4D0VkZrPb2A/sE/RDKuFA==
reflect.packEface -> reflect.typedmemmove
reflect.packEface -> reflect..stmp_49
reflect.packEface -> gclocals·KI3RUQY/vBl83aRwDdEk0g==
reflect.methodReceiver -> reflect.resolveTypeOff
reflect.methodReceiver -> internal/abi.(*Type).ExportedMethods
reflect.methodReceiver -> reflect.resolveTextOff
reflect.methodReceiver -> go:string."reflect: "
reflect.methodReceiver -> go:string." of unexported method"
reflect.methodReceiver -> reflect..stmp_78
reflect.methodReceiver -> go:string." of method on nil interface value"
reflect.methodReceiver -> gclocals·tvlUN/ZKEir4drQW66JrTQ==
reflect.methodReceiver -> gclocals·9p37S1F04MUBIQrO5E7iBA==
reflect.methodReceiver -> reflect.methodReceiver.arginfo1
reflect.methodReceiver -> reflect.methodReceiver.argliveinfo
reflect.Value.lenNonSlice -> reflect.chanlen
reflect.Value.lenNonSlice -> reflect.maplen
reflect.Value.lenNonSlice -> go:string."reflect.Value.Len"
reflect.Value.lenNonSlice -> reflect..stmp_102
reflect.Value.lenNonSlice -> reflect..stmp_14
reflect.Value.NumMethod -> reflect.(*rtype).NumMethod
reflect.Value.NumMethod -> go:string."reflect.Value.NumMethod"
reflect.(*rtype).NumMethod -> reflect.(*rtype).exportedMethods
reflect.(*rtype).exportedMethods -> reflect.(*rtype).exportedMethods.jump7
reflect.(*rtype).exportedMethods -> go:sehuw.12.AQQCBQQDAVAAAAAA
reflect.Value.MethodByName <ReflectMethod> -> reflect.(*rtype).MethodByName
reflect.Value.MethodByName <ReflectMethod> -> reflect.Value.Method
reflect.Value.MethodByName <ReflectMethod> -> go:string."reflect.Value.MethodByName"
reflect.Value.MethodByName <ReflectMethod> -> gclocals·O3MpPIyjmisSyojl8NMHzw==
reflect.Value.MethodByName <ReflectMethod> -> gclocals·hNmjCc8ejpgbywuNCxrtUw==
reflect.Value.MethodByName <ReflectMethod> -> reflect.Value.FieldByName.arginfo1
reflect.(*rtype).MethodByName -> reflect.(*rtype).MethodByName.jump11
reflect.(*rtype).MethodByName -> reflect.(*interfaceType).MethodByName
reflect.(*rtype).MethodByName -> runtime.cmpstring
reflect.(*rtype).MethodByName -> reflect.(*rtype).Method
reflect.(*rtype).MethodByName -> gclocals·EnFOEJF2vokMILesUJJwxw==
reflect.(*rtype).MethodByName -> gclocals·FcKTh1G/jYcZwo2rqp0TFw==
reflect.(*rtype).MethodByName -> reflect.(*rtype).MethodByName.arginfo1
reflect.(*rtype).MethodByName -> reflect.(*rtype).Method.argliveinfo
reflect.(*rtype).Method -> reflect.(*interfaceType).Method
reflect.(*rtype).Method -> reflect.FuncOf
reflect.(*rtype).Method -> reflect..stmp_20
reflect.(*rtype).Method -> gclocals·ouEo8zNki4ffhEnYFnmEJw==
reflect.(*rtype).Method -> gclocals·JcYzC80nB6zFaqyK6yKoog==
reflect.(*rtype).Method -> reflect.(*rtype).Method.arginfo1
reflect.(*interfaceType).Method -> reflect.pkgPath
reflect.(*interfaceType).Method -> gclocals·Cdz7BbwSkKHNMvOaMh+lHg==
reflect.(*interfaceType).MethodByName -> gclocals·Sj9q0gzJwE6+09c+w5boog==
reflect.(*interfaceType).MethodByName -> gclocals·QuCLQB3B9+O+D/YrISvPqg==
reflect.FuncOf -> reflect.initFuncTypes
reflect.FuncOf -> reflect.New
reflect.FuncOf -> reflect.Value.Addr
reflect.FuncOf -> type:internal/abi.FuncType
reflect.FuncOf -> type:*reflect.rtype <UsedInIface>
reflect.FuncOf -> reflect.funcLookupCache
reflect.FuncOf -> sync.(*Mutex).lockSlow
reflect.FuncOf -> reflect.FuncOf.func2
reflect.FuncOf -> reflect.FuncOf.func1
reflect.FuncOf -> reflect.funcStr
reflect.FuncOf -> reflect.typesByString
reflect.FuncOf -> reflect.haveIdenticalUnderlyingType
reflect.FuncOf -> reflect..stmp_29
reflect.FuncOf -> reflect..stmp_28
reflect.FuncOf -> gclocals·zHlShnY1fMFpfe5miWYb1A==
reflect.FuncOf -> gclocals·VInfWGEyYzr+lB0AAGZ/VA==
reflect.FuncOf -> reflect.FuncOf.stkobj
reflect.FuncOf -> reflect.FuncOf.opendefer
reflect.FuncOf -> reflect.FuncOf.arginfo1
reflect.FuncOf -> reflect.FuncOf.argliveinfo
reflect.haveIdenticalUnderlyingType -> reflect.haveIdenticalType
reflect.haveIdenticalUnderlyingType -> gclocals·6//EIdoy5GYyO6HC6KocaA==
reflect.haveIdenticalUnderlyingType -> gclocals·jdi0jSPRVTK0ekApO8h9Rw==
reflect.haveIdenticalType -> reflect.(*rtype).Name
reflect.haveIdenticalType -> reflect.(*rtype).PkgPath
reflect.(*rtype).PkgPath -> reflect.(*rtype).PkgPath.jump9
reflect.typesByString -> reflect.typelinks
reflect.typesByString -> gclocals·uV2hiwDXsKKNoFUR0lNrFg==
reflect.initFuncTypes -> type:internal/abi.FuncType <UsedInIface>
reflect.initFuncTypes -> reflect.funcTypesMutex
reflect.initFuncTypes -> reflect.initFuncTypes.func1
reflect.initFuncTypes -> reflect.funcTypes
reflect.initFuncTypes -> reflect.ArrayOf
reflect.initFuncTypes -> go:string."FuncType"
reflect.initFuncTypes -> go:string."Args"
reflect.initFuncTypes -> reflect.StructOf
reflect.initFuncTypes -> gclocals·wKwkf5/GGZ9gU/VnnePu2w==
reflect.initFuncTypes -> reflect.initFuncTypes.stkobj
reflect.initFuncTypes -> reflect.initFuncTypes.opendefer
reflect.initFuncTypes.func1 -> sync.(*Mutex).Unlock
reflect.initFuncTypes.func1 -> sync.(*Mutex).Unlock.wrapinfo
reflect.FuncOf.func1 -> type:[]*internal/abi.Type <UsedInIface>
reflect.FuncOf.func1 -> runtime.convT32
reflect.FuncOf.func1 -> sync.(*Map).Swap
reflect.funcStr -> gclocals·698HO3Ui0HPsyYmG8tvwyQ==
reflect.funcStr -> gclocals·UO+KHHYP39PQWz+frC8ZWQ==
reflect.StructOf -> type:struct {} <UsedInIface>
reflect.StructOf -> type:internal/abi.StructField
reflect.StructOf -> reflect.isValidFieldName
reflect.StructOf -> reflect.runtimeStructField
reflect.StructOf -> runtime.stringtoslicebyte
reflect.StructOf -> reflect.StructOf.jump134
reflect.StructOf -> reflect.StructOf.jump244
reflect.StructOf -> type:map[string]struct {}
reflect.StructOf -> runtime.mapaccess2_faststr
reflect.StructOf -> type:reflect.structType <UsedInIface>
reflect.StructOf -> type:internal/abi.UncommonType <UsedInIface>
reflect.StructOf -> type:internal/abi.Method <UsedInIface>
reflect.StructOf -> reflect..stmp_45
reflect.StructOf -> reflect.Value.UnsafePointer
reflect.StructOf -> type:[]internal/abi.Method
reflect.StructOf -> type:reflect.structTypeUncommon
reflect.StructOf -> reflect.structLookupCache
reflect.StructOf -> type:[]reflect.Type
reflect.StructOf -> reflect.StructOf.func7
reflect.StructOf -> reflect.StructOf.func5
reflect.StructOf -> reflect.typeptrdata
reflect.StructOf -> type:noalg.struct { F uintptr; reflect.typ *reflect.structType }
reflect.StructOf -> reflect.StructOf.func6
reflect.StructOf -> reflect.appendGCProg
reflect.StructOf -> reflect..stmp_41
reflect.StructOf -> go:string."reflect.StructOf: duplicate field "
reflect.StructOf -> type:noalg.struct { F uintptr; reflect.ifield int; reflect.imethod int }
reflect.StructOf -> reflect.StructOf.func1
reflect.StructOf -> reflect.MakeFunc
reflect.StructOf -> reflect.StructOf.func2
reflect.StructOf -> reflect.StructOf.func3
reflect.StructOf -> reflect.StructOf.func4
reflect.StructOf -> reflect..stmp_33
reflect.StructOf -> reflect..stmp_39
reflect.StructOf -> reflect..stmp_34
reflect.StructOf -> reflect.StructOf.jump192
reflect.StructOf -> reflect..stmp_35
reflect.StructOf -> go:string."reflect.StructOf: illegal embedded field type "
reflect.StructOf -> go:string."reflect.Struct: fields with different PkgPath "
reflect.StructOf -> runtime.concatstring4
reflect.StructOf -> strconv.FormatInt
reflect.StructOf -> go:string." has no type"
reflect.StructOf -> go:string."reflect.StructOf: field "
reflect.StructOf -> go:string." has invalid name"
reflect.StructOf -> go:string." has no name"
reflect.StructOf -> gclocals·G7EDE21Ep9uJjem1tKTFBQ==
reflect.StructOf -> gclocals·JO8tYLzlZIIIT1DR67iDCQ==
reflect.StructOf -> reflect.StructOf.stkobj
reflect.StructOf -> reflect.StructOf.opendefer
reflect.MakeFunc -> reflect.makeFuncStub
reflect.MakeFunc -> type:reflect.makeFuncImpl
reflect.MakeFunc -> reflect..stmp_16
reflect.MakeFunc -> gclocals·9lq/uzF2FCARpQg6KYOc5Q==
reflect.MakeFunc -> gclocals·yl0Q3sthbcaVpNr+bnCcpQ==
reflect.appendGCProg -> gclocals·jxVpOeGLanU/bnVSQx2QzA==
reflect.appendGCProg -> gclocals·IJ67NNLkizfI/PHLn8DHpg==
reflect.isValidFieldName -> reflect.isLetter
reflect.isValidFieldName -> unicode.Digit
reflect.isValidFieldName -> unicode.isExcludingLatin
reflect.isLetter -> unicode.properties
reflect.isLetter -> unicode.Letter
reflect.StructOf.func5 -> type:[]reflect.Type <UsedInIface>
reflect.StructOf.func5 -> gclocals·SuDKIHcJsOScwLiHYVi+zA==
reflect.StructOf.func5 -> gclocals·3QKsrV3trxJt0hHX4TI54g==
reflect.StructOf.func4 -> reflect.Value.Call
reflect.runtimeStructField -> go:string."reflect.StructOf: field \""
reflect.runtimeStructField -> go:string."\" is unexported but missing PkgPath"
reflect.runtimeStructField -> go:string."\" is anonymous but has PkgPath set"
reflect.runtimeStructField -> gclocals·di3JTVO88HRQRye6dp3q6Q==
reflect.runtimeStructField -> gclocals·BJiAOj1UXq2xBs+KLzdBBQ==
reflect.runtimeStructField -> reflect.StructField.IsExported.arginfo1
reflect.typeptrdata -> go:string."reflect.typeptrdata: unexpected type, "
reflect.ArrayOf -> type:reflect.cacheKey <UsedInIface>
reflect.ArrayOf -> reflect.lookupCache
reflect.ArrayOf -> runtime.assertE2I
reflect.ArrayOf -> type:[1]unsafe.Pointer <UsedInIface>
reflect.ArrayOf -> type:internal/abi.ArrayType
reflect.ArrayOf -> reflect.SliceOf
reflect.ArrayOf -> reflect.emitGCMask
reflect.ArrayOf -> type:noalg.struct { F uintptr; reflect.length int; reflect.esize uintptr; reflect.eequal func(unsafe.Pointer, unsafe.Pointer) bool }
reflect.ArrayOf -> reflect.ArrayOf.func1
reflect.ArrayOf -> reflect..stmp_47
reflect.ArrayOf -> reflect..stmp_46
reflect.ArrayOf -> gclocals·YIPSwDaagMZnR4AURWuD0A==
reflect.ArrayOf -> gclocals·kn13aReudK2odJ8ebcq2bg==
reflect.ArrayOf -> reflect.ChanOf.stkobj
reflect.emitGCMask -> reflect..stmp_32
reflect.emitGCMask -> gclocals·WbOP71sd80jWWggvKD8/4A==
reflect.emitGCMask -> reflect.emitGCMask.arginfo1
reflect.SliceOf -> go:string."[]"
reflect.SliceOf -> type:reflect.sliceType
reflect.SliceOf -> gclocals·RjabTr4+LZu7gNW0oCpMrw==
reflect.SliceOf -> gclocals·luaegQVGQvqxjwTCZZFvJw==
reflect.SliceOf -> reflect.SliceOf.stkobj
reflect.Value.Addr -> reflect.(*rtype).ptrTo
reflect.Value.Addr -> reflect..stmp_50
reflect.(*rtype).ptrTo -> reflect.ptrMap
reflect.(*rtype).ptrTo -> go:string."*"
reflect.(*rtype).ptrTo -> type:*reflect.ptrType <UsedInIface>
reflect.(*rtype).ptrTo -> type:reflect.ptrType
reflect.(*rtype).ptrTo -> gclocals·yAdjD+Y1baTaJ3IxgxbyuA==
reflect.(*rtype).ptrTo -> gclocals·zLSBVamPUTB44E/TTMkhgQ==
reflect.Value.Call -> reflect.flag.mustBeExportedSlow
reflect.Value.Call -> go:string."Call"
reflect.Value.Call -> reflect.Value.call
reflect.Value.Call -> reflect.valueMethodName
reflect.Value.Call -> gclocals·oL3H29t51DupqcA2Z2yp9g==
reflect.Value.Call -> gclocals·0tyFm9gSDD/Bgiuwq5TiQQ==
reflect.Value.Call -> reflect.Value.Call.argliveinfo
reflect.valueMethodName -> type:[5]uintptr
reflect.valueMethodName -> type:runtime.Frames
reflect.valueMethodName -> runtime.(*Frames).Next
reflect.valueMethodName -> go:string."unknown method"
reflect.valueMethodName -> gclocals·pFJHMogqdnTA2oIewjg3yA==
reflect.flag.mustBeExportedSlow -> go:string." using value obtained using unexported field"
reflect.Value.call -> reflect.MakeSlice
reflect.Value.call -> reflect.elem
reflect.Value.call -> go:string."reflect.Value.Call"
reflect.Value.call -> reflect.Value.assignTo
reflect.Value.call -> reflect.callGC
reflect.Value.call -> runtime.GC
reflect.Value.call -> runtime.reflectcall
reflect.Value.call -> reflect.typedmemclrpartial
reflect.Value.call -> reflect.typedmemclr
reflect.Value.call -> reflect.Zero
reflect.Value.call -> reflect.intFromReg
reflect.Value.call -> reflect..stmp_65
reflect.Value.call -> reflect..stmp_68
reflect.Value.call -> reflect..stmp_12
reflect.Value.call -> go:string."kind="
reflect.Value.call -> go:string.", type="
reflect.Value.call -> reflect..stmp_66
reflect.Value.call -> reflect.intToReg
reflect.Value.call -> reflect..stmp_63
reflect.Value.call -> reflect..stmp_62
reflect.Value.call -> reflect..stmp_61
reflect.Value.call -> reflect.Value.Set
reflect.Value.call -> go:string."reflect: cannot use "
reflect.Value.call -> go:string." as type "
reflect.Value.call -> go:string." in "
reflect.Value.call -> go:string." using "
reflect.Value.call -> go:string." using zero Value argument"
reflect.Value.call -> reflect..stmp_60
reflect.Value.call -> reflect..stmp_59
reflect.Value.call -> reflect..stmp_58
reflect.Value.call -> reflect..stmp_57
reflect.Value.call -> reflect..stmp_56
reflect.Value.call -> reflect..stmp_55
reflect.Value.call -> gclocals·M3neBoZCSttynJ7p3DF9ng==
reflect.Value.call -> gclocals·hAfVzXzgyHGDYh3GeOgWPw==
reflect.Value.call -> reflect.Value.call.stkobj
reflect.Value.call -> fmt.Appendf.arginfo1
reflect.Value.call -> reflect.Value.call.argliveinfo
reflect.intFromReg -> reflect.memmove
reflect.intFromReg -> reflect..stmp_10
reflect.elem -> go:string."reflect: Elem of invalid type "
reflect.Value.Method -> reflect..stmp_118
reflect.Value.Method -> go:string."reflect.Value.IsNil"
reflect.Value.Method -> go:string."reflect.Value.Method"
reflect.Value.Pointer -> reflect.dummy
reflect.Value.Pointer -> go:string."reflect.Value.Pointer"
reflect.Value.Pointer -> reflect..stmp_119
reflect.Value.Set -> reflect.flag.mustBeAssignableSlow
reflect.Value.Set -> go:string."reflect.Set"
reflect.Value.Set -> gclocals·DnjzWlWCkxGN1+sw2R2bng==
reflect.Value.Set -> gclocals·BkdT/G9ANzBRBh7SQjV77g==
reflect.flag.mustBeAssignableSlow -> go:string." using unaddressable value"
reflect.Value.Slice -> type:internal/unsafeheader.String
reflect.Value.Slice -> reflect..stmp_135
reflect.Value.Slice -> go:string."reflect.Value.Slice"
reflect.Value.Slice -> reflect..stmp_136
reflect.Value.Slice -> reflect..stmp_134
reflect.Value.Slice -> gclocals·z6F3ggV2Coh4mVol1K9bMw==
reflect.Value.Slice -> reflect.Value.Slice.arginfo1
reflect.Value.Slice -> reflect.Value.FieldByIndex.argliveinfo
reflect.Value.typeSlow -> go:string."reflect.Value.Type"
reflect.Value.UnsafePointer -> go:string."reflect.Value.UnsafePointer"
reflect.Value.UnsafePointer -> reflect..stmp_142
reflect.MakeSlice -> type:internal/unsafeheader.Slice
reflect.MakeSlice -> reflect.unsafe_NewArray
reflect.MakeSlice -> reflect..stmp_162
reflect.MakeSlice -> reflect..stmp_161
reflect.MakeSlice -> reflect..stmp_160
reflect.MakeSlice -> reflect..stmp_159
reflect.MakeSlice -> gclocals·GS0gcC+mZet7zFLyt28bUA==
reflect.Zero -> reflect..stmp_167
reflect.New -> reflect..stmp_169
reflect.New -> reflect..stmp_168
reflect.Value.assignTo -> reflect.directlyAssignable
reflect.Value.assignTo -> reflect.implements
reflect.Value.assignTo -> reflect.ifaceE2I
reflect.Value.assignTo -> go:string.": value of type "
reflect.Value.assignTo -> go:string." is not assignable to type "
reflect.Value.assignTo -> gclocals·jOZ5lGVd48/pyofggxBckw==
reflect.Value.assignTo -> gclocals·gZt8J2+x2/w5rBxvX4dGWg==
reflect.Value.assignTo -> reflect.Value.assignTo.arginfo1
reflect.implements -> reflect.implements.jump53
reflect.implements -> gclocals·fTWvoWmYU2M1rzHz+Dbbbg==
reflect.implements -> gclocals·LhyahCle6riNBx2ILTCReQ==
reflect.directlyAssignable -> reflect.specialChannelAssignability
type:reflect.Value <UsedInIface> -> type:.namedata.*reflect.Value.
type:reflect.Value <UsedInIface> -> type:*reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> type:.importpath.reflect.
type:reflect.Value <UsedInIface> -> type:.namedata.typ_-
type:reflect.Value <UsedInIface> -> type:.namedata.flag-.embedded
type:reflect.Value <UsedInIface> -> type:reflect.flag <UsedInIface>
type:reflect.Value <UsedInIface> -> type:.namedata.Addr.
type:reflect.Value <UsedInIface> -> type:.namedata.Bool.
type:reflect.Value <UsedInIface> -> type:.namedata.Call.
type:reflect.Value <UsedInIface> -> type:.namedata.CallSlice.
type:reflect.Value <UsedInIface> -> type:.namedata.CanAddr.
type:reflect.Value <UsedInIface> -> type:.namedata.CanComplex.
type:reflect.Value <UsedInIface> -> type:.namedata.CanConvert.
type:reflect.Value <UsedInIface> -> type:.namedata.CanFloat.
type:reflect.Value <UsedInIface> -> type:.namedata.CanInt.
type:reflect.Value <UsedInIface> -> type:.namedata.CanInterface.
type:reflect.Value <UsedInIface> -> type:.namedata.CanSet.
type:reflect.Value <UsedInIface> -> type:.namedata.CanUint.
type:reflect.Value <UsedInIface> -> type:.namedata.Cap.
type:reflect.Value <UsedInIface> -> type:.namedata.Clear.
type:reflect.Value <UsedInIface> -> type:.namedata.Close.
type:reflect.Value <UsedInIface> -> type:.namedata.Comparable.
type:reflect.Value <UsedInIface> -> type:.namedata.Complex.
type:reflect.Value <UsedInIface> -> type:.namedata.Convert.
type:reflect.Value <UsedInIface> -> type:.namedata.Field.
type:reflect.Value <UsedInIface> -> type:.namedata.FieldByIndex.
type:reflect.Value <UsedInIface> -> type:.namedata.FieldByIndexErr.
type:reflect.Value <UsedInIface> -> type:.namedata.FieldByName.
type:reflect.Value <UsedInIface> -> type:.namedata.FieldByNameFunc.
type:reflect.Value <UsedInIface> -> type:.namedata.Float.
type:reflect.Value <UsedInIface> -> type:.namedata.Grow.
type:reflect.Value <UsedInIface> -> type:.namedata.Index.
type:reflect.Value <UsedInIface> -> type:.namedata.Int.
type:reflect.Value <UsedInIface> -> type:.namedata.Interface.
type:reflect.Value <UsedInIface> -> type:.namedata.InterfaceData.
type:reflect.Value <UsedInIface> -> type:.namedata.IsNil.
type:reflect.Value <UsedInIface> -> type:.namedata.IsValid.
type:reflect.Value <UsedInIface> -> type:.namedata.IsZero.
type:reflect.Value <UsedInIface> -> type:.namedata.MapIndex.
type:reflect.Value <UsedInIface> -> type:.namedata.MapKeys.
type:reflect.Value <UsedInIface> -> type:.namedata.MapRange.
type:reflect.Value <UsedInIface> -> type:.namedata.Method.
type:reflect.Value <UsedInIface> -> type:.namedata.MethodByName.
type:reflect.Value <UsedInIface> -> type:.namedata.NumField.
type:reflect.Value <UsedInIface> -> type:.namedata.OverflowComplex.
type:reflect.Value <UsedInIface> -> type:.namedata.OverflowFloat.
type:reflect.Value <UsedInIface> -> type:.namedata.OverflowInt.
type:reflect.Value <UsedInIface> -> type:.namedata.OverflowUint.
type:reflect.Value <UsedInIface> -> type:.namedata.Pointer.
type:reflect.Value <UsedInIface> -> type:.namedata.Recv.
type:reflect.Value <UsedInIface> -> type:.namedata.Send.
type:reflect.Value <UsedInIface> -> type:.namedata.SetBool.
type:reflect.Value <UsedInIface> -> type:.namedata.SetBytes.
type:reflect.Value <UsedInIface> -> type:.namedata.SetCap.
type:reflect.Value <UsedInIface> -> type:.namedata.SetComplex.
type:reflect.Value <UsedInIface> -> type:.namedata.SetFloat.
type:reflect.Value <UsedInIface> -> type:.namedata.SetInt.
type:reflect.Value <UsedInIface> -> type:.namedata.SetIterKey.
type:reflect.Value <UsedInIface> -> type:.namedata.SetIterValue.
type:reflect.Value <UsedInIface> -> type:.namedata.SetLen.
type:reflect.Value <UsedInIface> -> type:.namedata.SetMapIndex.
type:reflect.Value <UsedInIface> -> type:.namedata.SetPointer.
type:reflect.Value <UsedInIface> -> type:.namedata.SetString.
type:reflect.Value <UsedInIface> -> type:.namedata.SetUint.
type:reflect.Value <UsedInIface> -> type:.namedata.SetZero.
type:reflect.Value <UsedInIface> -> type:.namedata.Slice.
type:reflect.Value <UsedInIface> -> type:.namedata.Slice3.
type:reflect.Value <UsedInIface> -> type:.namedata.TryRecv.
type:reflect.Value <UsedInIface> -> type:.namedata.TrySend.
type:reflect.Value <UsedInIface> -> type:.namedata.Type.
type:reflect.Value <UsedInIface> -> type:.namedata.Uint.
type:reflect.Value <UsedInIface> -> type:.namedata.UnsafeAddr.
type:reflect.Value <UsedInIface> -> type:.namedata.UnsafePointer.
type:reflect.Value <UsedInIface> -> type:.namedata.assignTo-
type:reflect.Value <UsedInIface> -> type:.namedata.bytesSlow-
type:reflect.Value <UsedInIface> -> type:.namedata.call-
type:reflect.Value <UsedInIface> -> type:.namedata.capNonSlice-
type:reflect.Value <UsedInIface> -> type:.namedata.extendSlice-
type:reflect.Value <UsedInIface> -> type:.namedata.grow-
type:reflect.Value <UsedInIface> -> type:.namedata.lenNonSlice-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBe-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBeAssignable-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBeAssignableSlow-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBeExported-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBeExportedSlow-
type:reflect.Value <UsedInIface> -> type:.namedata.panicNotBool-
type:reflect.Value <UsedInIface> -> type:.namedata.panicNotMap-
type:reflect.Value <UsedInIface> -> type:.namedata.pointer-
type:reflect.Value <UsedInIface> -> type:.namedata.recv-
type:reflect.Value <UsedInIface> -> type:.namedata.ro-
type:reflect.Value <UsedInIface> -> type:.namedata.runes-
type:reflect.Value <UsedInIface> -> type:.namedata.send-
type:reflect.Value <UsedInIface> -> type:.namedata.setRunes-
type:reflect.Value <UsedInIface> -> type:.namedata.stringNonString-
type:reflect.Value <UsedInIface> -> type:.namedata.typeSlow-
type:reflect.flag <UsedInIface> -> type:.namedata.*reflect.flag-
type:reflect.flag <UsedInIface> -> type:*reflect.flag <UsedInIface>
type:reflect.Type -> type:.namedata.*reflect.Type.
type:reflect.Type -> type:*reflect.Type
type:reflect.Type -> type:func() int <UsedInIface>
type:reflect.Type -> type:.namedata.AssignableTo.
type:reflect.Type -> type:func(reflect.Type) bool <UsedInIface>
type:reflect.Type -> type:.namedata.Bits.
type:reflect.Type -> type:func() reflect.ChanDir
type:reflect.Type -> type:.namedata.ConvertibleTo.
type:reflect.Type -> type:func() reflect.Type <UsedInIface>
type:reflect.Type -> type:func(int) reflect.StructField
type:reflect.Type -> type:func([]int) reflect.StructField
type:reflect.Type -> type:func(string) (reflect.StructField, bool)
type:reflect.Type -> type:func(func(string) bool) (reflect.StructField, bool)
type:reflect.Type -> type:.namedata.Implements.
type:reflect.Type -> type:.namedata.In.
type:reflect.Type -> type:func(int) reflect.Type
type:reflect.Type -> type:.namedata.IsVariadic.
type:reflect.Type -> type:func() reflect.Kind <UsedInIface>
type:reflect.Type -> type:func(int) reflect.Method
type:reflect.Type -> type:func(string) (reflect.Method, bool)
type:reflect.Type -> type:.namedata.NumIn.
type:reflect.Type -> type:.namedata.NumOut.
type:reflect.Type -> type:.namedata.Out.
type:reflect.Type -> type:func() uintptr <UsedInIface>
type:reflect.Type -> type:.namedata.common-
type:reflect.Type -> type:func() *internal/abi.Type <UsedInIface>
type:reflect.Type -> type:.namedata.uncommon-
type:reflect.Type -> type:func() *internal/abi.UncommonType <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:.namedata.*reflect.rtype-
type:*reflect.rtype <UsedInIface> -> type:reflect.rtype <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func() reflect.ChanDir <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(int) reflect.StructField <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func([]int) reflect.StructField <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(string) (reflect.StructField, bool) <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(func(string) bool) (reflect.StructField, bool) <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(int) reflect.Type <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(int) reflect.Method <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(string) (reflect.Method, bool) <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:.namedata.exportedMethods-
type:*reflect.rtype <UsedInIface> -> type:.namedata.gcSlice-
type:*reflect.rtype <UsedInIface> -> type:.namedata.nameOff-
type:*reflect.rtype <UsedInIface> -> type:.namedata.ptrTo-
type:*reflect.rtype <UsedInIface> -> type:.namedata.typeOff-
type:reflect.rtype <UsedInIface> -> type:.namedata.t-
 -> go:info.sync.Map
 -> go:info.struct { sync.Mutex; reflect.m sync.Map }
 -> go:info.[]reflect.Type
 -> go:info.sync.Mutex
 -> go:info.struct { reflect.b bool; reflect.x interface {} }
type:*reflect.ValueError <UsedInIface> -> type:.namedata.*reflect.ValueError.
type:*reflect.ValueError <UsedInIface> -> type:reflect.ValueError <UsedInIface>
type:reflect.ValueError <UsedInIface> -> type:.eqfunc.reflect.ValueError
type:reflect.ValueError <UsedInIface> -> type:reflect.Kind <UsedInIface>
type:reflect.Kind <UsedInIface> -> type:.namedata.*reflect.Kind.
type:reflect.Kind <UsedInIface> -> type:*reflect.Kind <UsedInIface>
type:reflect.abiStep -> type:.namedata.*reflect.abiStep-
type:reflect.abiStep -> type:*reflect.abiStep
type:reflect.abiStep -> type:reflect.abiStepKind
type:reflect.abiStep -> type:.namedata.stkOff-
type:reflect.abiStep -> type:.namedata.ireg-
type:reflect.abiStep -> type:.namedata.freg-
type:reflect.abiStepKind -> type:.namedata.*reflect.abiStepKind-
type:reflect.abiStepKind -> type:*reflect.abiStepKind
type:reflect.abiSeq -> type:.namedata.*reflect.abiSeq-
type:reflect.abiSeq -> type:*reflect.abiSeq
type:reflect.abiSeq -> type:.namedata.steps-
type:reflect.abiSeq -> type:[]reflect.abiStep
type:reflect.abiSeq -> type:.namedata.valueStart-
type:reflect.abiSeq -> type:.namedata.stackBytes-
type:reflect.abiSeq -> type:.namedata.iregs-
type:reflect.abiSeq -> type:.namedata.fregs-
type:*reflect.abiSeq -> type:.namedata.addArg-
type:*reflect.abiSeq -> type:.namedata.addRcvr-
type:*reflect.abiSeq -> type:.namedata.assignFloatN-
type:*reflect.abiSeq -> type:.namedata.assignIntN-
type:*reflect.abiSeq -> type:.namedata.dump-
type:*reflect.abiSeq -> type:.namedata.regAssign-
type:*reflect.abiSeq -> type:.namedata.stackAssign-
type:*reflect.abiSeq -> type:.namedata.stepsForValue-
type:reflect.bitVector -> type:.namedata.*reflect.bitVector-
type:reflect.bitVector -> type:*reflect.bitVector
type:*reflect.bitVector -> type:.namedata.append-
type:reflect.cacheKey <UsedInIface> -> type:.namedata.*reflect.cacheKey-
type:reflect.cacheKey <UsedInIface> -> type:*reflect.cacheKey <UsedInIface>
type:reflect.structType <UsedInIface> -> type:.namedata.*reflect.structType-
type:reflect.structType <UsedInIface> -> type:*reflect.structType <UsedInIface>
type:reflect.structType <UsedInIface> -> type:.namedata.StructType..embedded
type:reflect.structType <UsedInIface> -> type:internal/abi.StructType <UsedInIface>
type:reflect.layoutKey <UsedInIface> -> type:.namedata.*reflect.layoutKey-
type:reflect.layoutKey <UsedInIface> -> type:*reflect.layoutKey <UsedInIface>
type:reflect.layoutKey <UsedInIface> -> type:.namedata.ftyp-
type:reflect.layoutKey <UsedInIface> -> type:*internal/abi.FuncType <UsedInIface>
type:reflect.layoutKey <UsedInIface> -> type:.namedata.rcvr-
type:reflect.layoutType <UsedInIface> -> runtime.gcbits.2748800000000000
type:reflect.layoutType <UsedInIface> -> type:.namedata.*reflect.layoutType-
type:reflect.layoutType <UsedInIface> -> type:*reflect.layoutType <UsedInIface>
type:reflect.layoutType <UsedInIface> -> type:.namedata.framePool-
type:reflect.layoutType <UsedInIface> -> type:*sync.Pool <UsedInIface>
type:reflect.layoutType <UsedInIface> -> type:.namedata.abid-
type:reflect.layoutType <UsedInIface> -> type:reflect.abiDesc <UsedInIface>
type:reflect.abiDesc <UsedInIface> -> runtime.gcbits.0912200000000000
type:reflect.abiDesc <UsedInIface> -> type:.namedata.*reflect.abiDesc-
type:reflect.abiDesc <UsedInIface> -> type:*reflect.abiDesc <UsedInIface>
type:reflect.abiDesc <UsedInIface> -> type:reflect.abiSeq <UsedInIface>
type:reflect.abiDesc <UsedInIface> -> type:.namedata.stackCallArgsSize-
type:reflect.abiDesc <UsedInIface> -> type:.namedata.spill-
type:reflect.abiDesc <UsedInIface> -> type:.namedata.stackPtrs-
type:reflect.abiDesc <UsedInIface> -> type:*reflect.bitVector <UsedInIface>
type:reflect.abiDesc <UsedInIface> -> type:.namedata.inRegPtrs-
type:reflect.abiDesc <UsedInIface> -> type:.namedata.outRegPtrs-
type:reflect.abiSeq <UsedInIface> -> type:*reflect.abiSeq <UsedInIface>
type:reflect.abiSeq <UsedInIface> -> type:[]reflect.abiStep <UsedInIface>
type:*reflect.bitVector <UsedInIface> -> type:reflect.bitVector <UsedInIface>
type:reflect.makeFuncImpl -> type:.namedata.*reflect.makeFuncImpl-
type:reflect.makeFuncImpl -> type:*reflect.makeFuncImpl
type:reflect.makeFuncImpl -> type:.namedata.makeFuncCtxt-.embedded
type:reflect.makeFuncImpl -> type:reflect.makeFuncCtxt
type:reflect.makeFuncImpl -> type:func([]reflect.Value) []reflect.Value <UsedInIface>
type:reflect.makeFuncCtxt -> type:.eqfunc.reflect.makeFuncCtxt
type:reflect.makeFuncCtxt -> type:.namedata.*reflect.makeFuncCtxt-
type:reflect.makeFuncCtxt -> type:*reflect.makeFuncCtxt
type:reflect.makeFuncCtxt -> type:.namedata.argLen-
type:reflect.makeFuncCtxt -> type:.namedata.regPtrs-
type:reflect.methodValue -> type:.eqfunc.reflect.methodValue
type:reflect.methodValue -> runtime.gcbits.6200000000000000
type:reflect.methodValue -> type:.namedata.*reflect.methodValue-
type:reflect.methodValue -> type:*reflect.methodValue
type:reflect.methodValue -> type:.namedata.method-
type:*reflect.ptrType <UsedInIface> -> type:.namedata.*reflect.ptrType-
type:*reflect.ptrType <UsedInIface> -> type:reflect.ptrType <UsedInIface>
type:reflect.ptrType <UsedInIface> -> type:.namedata.PtrType..embedded
type:reflect.ptrType <UsedInIface> -> type:internal/abi.PtrType <UsedInIface>
type:reflect.sliceType -> type:.namedata.*reflect.sliceType-
type:reflect.sliceType -> type:*reflect.sliceType
type:reflect.sliceType -> type:.namedata.SliceType..embedded
type:reflect.sliceType -> type:internal/abi.SliceType
type:reflect.structTypeUncommon -> type:.namedata.*reflect.structTypeUncommon-
type:reflect.structTypeUncommon -> type:*reflect.structTypeUncommon
type:reflect.structTypeUncommon -> type:.namedata.structType-.embedded
 -> go:info.*reflect.abiSeq
 -> go:info.*reflect.abiStep
 -> go:info.reflect.abiSeq
 -> go:info.internal/abi.(*Type).Size$abstract
 -> go:info.internal/abi.(*Type).Align$abstract
 -> go:info.reflect.(*abiSeq).stackAssign$abstract
 -> go:info.reflect.align$abstract
 -> go:info.reflect.ifaceIndir$abstract
 -> go:info.internal/abi.(*Type).Pointers$abstract
 -> go:info.*reflect.structType
 -> go:info.reflect.(*abiSeq).assignFloatN$abstract
 -> go:info.reflect.abiStepKind
 -> go:info.reflect.abiDesc
 -> go:info.*reflect.bitVector
 -> go:info.internal/abi.IntArgRegBitmap
 -> go:info.reflect.abiStep
 -> go:info.reflect.(*bitVector).append$abstract
 -> go:info.reflect.(*abiSeq).stepsForValue$abstract
 -> go:info.internal/abi.(*IntArgRegBitmap).Set$abstract
 -> go:info.internal/abi.(*RegArgs).IntRegArgAddr$abstract
 -> go:info.func([]reflect.Value) []reflect.Value
 -> go:info.*reflect.makeFuncImpl
 -> go:info.reflect.flag
 -> go:info.*reflect.methodValue
 -> go:info.reflect.methodValueCallCodePtr$abstract
 -> go:info.*reflect.rtype
 -> go:info.reflect.(*rtype).nameOff$abstract
 -> go:info.reflect.(*rtype).uncommon$abstract
 -> go:info.internal/abi.(*UncommonType).ExportedMethods$abstract
 -> go:info.*reflect.interfaceType
 -> go:info.reflect.(*rtype).Kind$abstract
 -> go:info.reflect.(*interfaceType).NumMethod$abstract
 -> go:info.reflect.Method
 -> go:info.reflect.(*rtype).typeOff$abstract
 -> go:info.internal/abi.(*FuncType).NumIn$abstract
 -> go:info.reflect.(*rtype).textOff$abstract
 -> go:info.internal/abi.(*FuncType).IsVariadic$abstract
 -> go:info.*internal/abi.Method
 -> go:info.internal/abi.(*Type).HasName$abstract
 -> go:info.internal/abi.(*Type).Elem$abstract
 -> go:info.reflect.stringFor$abstract
 -> go:info.reflect.(*interfaceType).nameOff$abstract
 -> go:info.reflect.(*interfaceType).typeOff$abstract
 -> go:info.*reflect.ptrType
 -> go:info.reflect.newName$abstract
 -> go:info.reflect.resolveReflectName$abstract
 -> go:info.reflect.fnv1$abstract
 -> go:info.internal/abi.(*UncommonType).Methods$abstract
 -> go:info.reflect.nameOffFor$abstract
 -> go:info.reflect.typeOffFor$abstract
 -> go:info.internal/abi.(*Type).ChanDir$abstract
 -> go:info.reflect.nameFor$abstract
 -> go:info.reflect.pkgPathFor$abstract
 -> go:info.reflect.Kind
 -> go:info.internal/abi.(*Type).Len$abstract
 -> go:info.internal/abi.(*Type).Key$abstract
 -> go:info.internal/abi.(*StructField).Embedded$abstract
 -> go:info.internal/abi.(*FuncType).In$abstract
 -> go:info.internal/abi.(*FuncType).Out$abstract
 -> go:info.[][]int32
 -> go:info.[]int32
 -> go:info.reflect.rtypeOff$abstract
 -> go:info.reflect.add$abstract
 -> go:info.sync.(*Mutex).Lock$abstract
 -> go:info.func(*internal/abi.Type) reflect.Type
 -> go:info.[]*reflect.rtype
 -> go:info.sync.(*Map).Store$abstract
 -> go:info.internal/abi.(*Type).GcSlice$abstract
 -> go:info.internal/abi.unsafeSliceFor$abstract
 -> go:info.*reflect.sliceType
 -> go:info.reflect.cacheKey
 -> go:info.unicode.IsLetter$abstract
 -> go:info.unicode.IsDigit$abstract
 -> go:info.[]reflect.StructField
 -> go:info.map[string]struct {}
 -> go:info.func(reflect.Type) reflect.Type
 -> go:info.[]internal/abi.StructField
 -> go:info.reflect.StructField
 -> go:info.internal/abi.StructField
 -> go:info.internal/abi.Kind
 -> go:info.*reflect.structTypeUncommon
 -> go:info.strconv.Quote$abstract
 -> go:info.strconv.quoteWith$abstract
 -> go:info.reflect.appendVarint$abstract
 -> go:info.reflect.resolveReflectType$abstract
 -> go:info.reflect.resolveReflectText$abstract
 -> go:info.reflect.textOffFor$abstract
 -> go:info.strconv.Itoa$abstract
 -> go:info.[]reflect.Value
 -> go:info.reflect.Indirect$abstract
 -> go:info.reflect.StructField.IsExported$abstract
 -> go:info.reflect.arrayAt$abstract
 -> go:info.*sync.Pool
 -> go:info.reflect.layoutKey
 -> go:info.reflect.layoutType
 -> go:info.reflect.Value.typ$abstract
 -> go:info.*[5]uintptr
 -> go:info.*runtime.Frames
 -> go:info.runtime.Frame
 -> go:info.runtime.Callers$abstract
 -> go:info.runtime.CallersFrames$abstract
 -> go:info.reflect.ptrTo$abstract
 -> go:info.reflect.flag.mustBe$abstract
 -> go:info.reflect.flag.mustBeExported$abstract
 -> go:info.internal/abi.RegArgs
 -> go:info.[]reflect.abiStep
 -> go:info.reflect.storeRcvr$abstract
 -> go:info.reflect.(*rtype).Elem$abstract
 -> go:info.reflect.(*rtype).common$abstract
 -> go:info.reflect.floatFromReg$abstract
 -> go:info.reflect.floatToReg$abstract
 -> go:info.reflect.archFloat32ToReg$abstract
 -> go:info.*reflect.nonEmptyInterface
 -> go:info.reflect.flag.ro$abstract
 -> go:info.*internal/unsafeheader.Slice
 -> go:info.*internal/unsafeheader.String
 -> go:info.reflect.Value.pointer$abstract
 -> go:info.reflect.escapes$abstract
 -> go:info.reflect.flag.mustBeAssignable$abstract
 -> go:info.*[]unsafe.Pointer
strconv.genericFtoa -> strconv.float32info
strconv.genericFtoa -> strconv.float64info
strconv.genericFtoa -> strconv.fmtX
strconv.genericFtoa -> strconv.optimize
strconv.genericFtoa -> strconv.ryuFtoaFixed32
strconv.genericFtoa -> strconv.ryuFtoaFixed64
strconv.genericFtoa -> strconv.bigFtoa
strconv.genericFtoa -> strconv.ryuFtoaShortest
strconv.genericFtoa -> strconv.formatDigits
strconv.genericFtoa -> strconv.fmtB
strconv.genericFtoa -> strconv..stmp_12
strconv.genericFtoa -> gclocals·/0e7XDi+yPTlYfaVle7v7w==
strconv.genericFtoa -> gclocals·yAt0nVANjOenwdahqOFMUg==
strconv.genericFtoa -> strconv.genericFtoa.stkobj
strconv.genericFtoa -> strconv.AppendFloat.arginfo1
strconv.genericFtoa -> strconv.genericFtoa.argliveinfo
strconv.genericFtoa -> go:sehuw.12.ARYCBRYDE1AAAAAA
strconv.bigFtoa -> strconv.(*decimal).Assign
strconv.bigFtoa -> strconv.(*decimal).Shift
strconv.bigFtoa -> strconv.(*decimal).Round
strconv.bigFtoa -> strconv.roundShortest
strconv.bigFtoa -> gclocals·WLNLDMnlx/MJz9q6ZPhyng==
strconv.bigFtoa -> gclocals·yROwgZmxcEjQO7qZUR29ZQ==
strconv.bigFtoa -> strconv.bigFtoa.arginfo1
strconv.bigFtoa -> strconv.bigFtoa.argliveinfo
strconv.(*decimal).Assign -> go:sehuw.12.AQQCBQQDAVAAAAAA
strconv.(*decimal).Shift -> strconv.rightShift
strconv.(*decimal).Shift -> strconv.leftShift
strconv.(*decimal).Shift -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
strconv.leftShift -> strconv.leftcheats
strconv.formatDigits -> strconv.fmtE
strconv.formatDigits -> strconv.fmtF
strconv.formatDigits -> gclocals·aJ0RFkXHGs1bnq/DJ5J1yw==
strconv.formatDigits -> strconv.formatDigits.arginfo1
strconv.formatDigits -> strconv.formatDigits.argliveinfo
strconv.fmtE -> gclocals·Ir0e+QuI3Rw8KXGenHkHEw==
strconv.fmtE -> strconv.fmtE.arginfo1
strconv.fmtE -> strconv.fmtE.argliveinfo
strconv.fmtF -> gclocals·85x/2q5RKyAjZD0Eugv6Tg==
strconv.fmtF -> strconv.fmtF.arginfo1
strconv.fmtF -> strconv.fmtF.argliveinfo
strconv.fmtB -> strconv.formatBits
strconv.fmtB -> gclocals·JeqdgTi6SjErUxFdeiy//Q==
strconv.fmtB -> strconv.fmtB.arginfo1
strconv.fmtB -> strconv.fmtB.argliveinfo
strconv.fmtX -> go:string."0123456789ABCDEF"
strconv.fmtX -> gclocals·fI1B4FjKb6qh0g2VTxO0oA==
strconv.fmtX -> strconv.fmtX.argliveinfo
strconv.ryuFtoaFixed32 -> strconv.mult64bitPow10
strconv.ryuFtoaFixed32 -> strconv.formatDecimal
strconv.ryuFtoaFixed32 -> strconv..stmp_15
strconv.ryuFtoaFixed32 -> strconv..stmp_14
strconv.ryuFtoaFixed32 -> strconv..stmp_13
strconv.ryuFtoaFixed32 -> strconv.ryuFtoaFixed32.arginfo1
strconv.ryuFtoaFixed64 -> strconv.mult128bitPow10
strconv.ryuFtoaFixed64 -> strconv..stmp_17
strconv.ryuFtoaFixed64 -> strconv..stmp_16
strconv.formatDecimal -> strconv.uint64pow10
strconv.formatDecimal -> go:string..gostring.200.QSBD6CASPFh8N+gldNET7A==
strconv.ryuFtoaShortest -> strconv.ryuDigits
strconv.ryuFtoaShortest -> gclocals·h0OUVQBt0BPrp9N+m46wyQ==
strconv.ryuFtoaShortest -> go:sehuw.12.ARMCBRMDEFAAAAAA
strconv.ryuDigits -> strconv.ryuDigits32
strconv.ryuDigits -> strconv.ryuDigits.arginfo1
strconv.ryuDigits32 -> strconv.ryuDigits32.arginfo1
strconv.mult64bitPow10 -> strconv.detailedPowersOfTen
strconv.mult64bitPow10 -> strconv..stmp_19
strconv.mult64bitPow10 -> strconv.mult64bitPow10.arginfo1
strconv.mult128bitPow10 -> strconv..stmp_20
strconv.FormatInt -> go:string."0123456789abcdefghijklmnopqrstuvwxyz"
strconv.formatBits -> strconv..stmp_21
strconv.formatBits -> strconv.formatBits.arginfo1
strconv.appendQuotedWith -> unicode/utf8.DecodeRuneInString
strconv.appendQuotedWith -> strconv.appendEscapedRune
strconv.appendQuotedWith -> gclocals·y+jrKPbABt0/5+nBN1COxA==
strconv.appendQuotedWith -> gclocals·w/w3ma/9mcu3ZEYTbpGxlA==
strconv.appendQuotedWith -> strconv.appendQuotedWith.arginfo1
strconv.appendQuotedWith -> strconv.appendQuotedWith.argliveinfo
strconv.appendQuotedRuneWith -> strconv.appendQuotedRuneWith.arginfo1
strconv.appendQuotedRuneWith -> strconv.appendQuotedRuneWith.argliveinfo
strconv.appendEscapedRune -> strconv.isGraphic
strconv.appendEscapedRune -> strconv.appendEscapedRune.argliveinfo
strconv.IsPrint -> strconv.isPrint16
strconv.IsPrint -> strconv.isPrint32
strconv.IsPrint -> strconv.isNotPrint32
strconv.IsPrint -> strconv.isNotPrint16
strconv.leftcheats -> strconv..stmp_5
 -> go:info.[]strconv.leftCheat
 -> go:info.[696][2]uint64
 -> go:info.strconv.floatInfo
 -> go:info.[20]uint64
strconv.isPrint16 -> strconv..stmp_6
strconv.isNotPrint16 -> strconv..stmp_7
strconv.isPrint32 -> strconv..stmp_8
strconv.isNotPrint32 -> strconv..stmp_9
strconv.isGraphic -> strconv..stmp_10
strconv..stmp_5 -> syscall..stmp_174
strconv..stmp_5 -> go:string."25"
strconv..stmp_5 -> go:string."125"
strconv..stmp_5 -> go:string."625"
strconv..stmp_5 -> go:string."3125"
strconv..stmp_5 -> go:string."15625"
strconv..stmp_5 -> go:string."78125"
strconv..stmp_5 -> go:string."390625"
strconv..stmp_5 -> go:string."1953125"
strconv..stmp_5 -> go:string."9765625"
strconv..stmp_5 -> go:string."48828125"
strconv..stmp_5 -> go:string."244140625"
strconv..stmp_5 -> go:string."1220703125"
strconv..stmp_5 -> go:string."6103515625"
strconv..stmp_5 -> go:string."30517578125"
strconv..stmp_5 -> go:string."152587890625"
strconv..stmp_5 -> go:string."762939453125"
strconv..stmp_5 -> go:string."3814697265625"
strconv..stmp_5 -> go:string."19073486328125"
strconv..stmp_5 -> go:string."95367431640625"
strconv..stmp_5 -> go:string."476837158203125"
strconv..stmp_5 -> go:string."2384185791015625"
strconv..stmp_5 -> go:string."11920928955078125"
strconv..stmp_5 -> go:string."59604644775390625"
strconv..stmp_5 -> go:string."298023223876953125"
strconv..stmp_5 -> go:string."1490116119384765625"
strconv..stmp_5 -> go:string."7450580596923828125"
strconv..stmp_5 -> go:string."37252902984619140625"
strconv..stmp_5 -> go:string."186264514923095703125"
strconv..stmp_5 -> go:string."931322574615478515625"
strconv..stmp_5 -> go:string."4656612873077392578125"
strconv..stmp_5 -> go:string."23283064365386962890625"
strconv..stmp_5 -> go:string."116415321826934814453125"
strconv..stmp_5 -> go:string."582076609134674072265625"
strconv..stmp_5 -> go:string."2910383045673370361328125"
strconv..stmp_5 -> go:string."14551915228366851806640625"
strconv..stmp_5 -> go:string."72759576141834259033203125"
strconv..stmp_5 -> go:string."363797880709171295166015625"
strconv..stmp_5 -> go:string."1818989403545856475830078125"
strconv..stmp_5 -> go:string."9094947017729282379150390625"
strconv..stmp_5 -> go:string."45474735088646411895751953125"
strconv..stmp_5 -> go:string."227373675443232059478759765625"
strconv..stmp_5 -> go:string."1136868377216160297393798828125"
strconv..stmp_5 -> go:string."5684341886080801486968994140625"
strconv..stmp_5 -> go:string."28421709430404007434844970703125"
strconv..stmp_5 -> go:string."142108547152020037174224853515625"
strconv..stmp_5 -> go:string."710542735760100185871124267578125"
strconv..stmp_5 -> go:string."3552713678800500929355621337890625"
strconv..stmp_5 -> go:string."17763568394002504646778106689453125"
strconv..stmp_5 -> go:string."88817841970012523233890533447265625"
strconv..stmp_5 -> go:string."444089209850062616169452667236328125"
strconv..stmp_5 -> go:string."2220446049250313080847263336181640625"
strconv..stmp_5 -> go:string."11102230246251565404236316680908203125"
strconv..stmp_5 -> go:string."55511151231257827021181583404541015625"
strconv..stmp_5 -> go:string."277555756156289135105907917022705078125"
strconv..stmp_5 -> go:string."1387778780781445675529539585113525390625"
strconv..stmp_5 -> go:string."6938893903907228377647697925567626953125"
strconv..stmp_5 -> go:string."34694469519536141888238489627838134765625"
strconv..stmp_5 -> go:string."173472347597680709441192448139190673828125"
strconv..stmp_5 -> go:string."867361737988403547205962240695953369140625"
 -> go:info.*strconv.decimal
 -> go:info.strconv.trim$abstract
 -> go:info.strconv.prefixIsLessThan$abstract
 -> go:info.strconv.shouldRoundUp$abstract
 -> go:info.strconv.(*decimal).RoundUp$abstract
 -> go:info.strconv.(*decimal).RoundDown$abstract
 -> go:info.*strconv.floatInfo
 -> go:info.strconv.decimalSlice
 -> go:info.[32]uint8
 -> go:info.math.Float32bits$abstract
 -> go:info.math.Float64bits$abstract
 -> go:info.strconv.max$abstract
 -> go:info.strconv.min$abstract
 -> go:info.strconv.lower$abstract
 -> go:info.*strconv.decimalSlice
 -> go:info.strconv.mulByLog2Log10$abstract
 -> go:info.strconv.divisibleByPower5$abstract
 -> go:info.strconv.computeBounds$abstract
 -> go:info.strconv.divmod1e9$abstract
 -> go:info.strconv.mulByLog10Log2$abstract
 -> go:info.[2]uint64
 -> go:info.strconv.small$abstract
 -> go:info.[65]uint8
 -> go:info.strconv.isPowerOfTwo$abstract
 -> go:info.math/bits.TrailingZeros$abstract
 -> go:info.unicode/utf8.ValidRune$abstract
 -> go:info.strconv.isInGraphicList$abstract
 -> go:info.strconv.bsearch16$abstract
 -> go:info.strconv.bsearch32$abstract
unicode/utf8.DecodeRune -> unicode/utf8.first
unicode/utf8.DecodeRune -> unicode/utf8.acceptRanges
unicode/utf8.DecodeRune -> go:sehuw.12.AQQCBQQDAVAAAAAA
unicode/utf8.appendRuneNonASCII -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
 -> go:info.[256]uint8
 -> go:info.[16]unicode/utf8.acceptRange
internal/fmtsort.Sort -> reflect.flag.panicNotMap
internal/fmtsort.Sort -> reflect.(*MapIter).Next
internal/fmtsort.Sort -> reflect.(*MapIter).Key
internal/fmtsort.Sort -> reflect.(*MapIter).Value
internal/fmtsort.Sort -> type:internal/fmtsort.SortedMap
internal/fmtsort.Sort -> go:itab.*internal/fmtsort.SortedMap,sort.Interface
internal/fmtsort.Sort -> sort.Stable
internal/fmtsort.Sort -> gclocals·yUTgI26mR2e8xJH2ncoWzg==
internal/fmtsort.Sort -> gclocals·/qYL/dS4VpWZB2dzqwAH8A==
internal/fmtsort.Sort -> internal/fmtsort.Sort.stkobj
internal/fmtsort.Sort -> go:sehuw.12.ARYCBRYDE1AAAAAA
reflect.(*MapIter).Key -> reflect.mapiterkey
reflect.(*MapIter).Key -> reflect.copyVal
reflect.(*MapIter).Key -> reflect..stmp_107
reflect.(*MapIter).Key -> reflect..stmp_106
reflect.(*MapIter).Value -> reflect.mapiterelem
reflect.(*MapIter).Value -> reflect..stmp_111
reflect.(*MapIter).Value -> reflect..stmp_110
reflect.(*MapIter).Next -> reflect.mapiterinit
reflect.(*MapIter).Next -> reflect.mapiternext
reflect.(*MapIter).Next -> reflect..stmp_116
reflect.(*MapIter).Next -> reflect..stmp_114
reflect.copyVal -> gclocals·QMy8w8cIiurtMrEMlsjK+Q==
 -> go:info.*reflect.MapIter
 -> go:info.reflect.(*hiter).initialized$abstract
sort.Stable -> sort.stable
sort.Stable -> go:sehuw.12.AQoCBQoDB1AAAAAA
sort.stable -> sort.insertionSort
sort.stable -> sort.symMerge
sort.stable -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
sort.symMerge -> sort.rotate
sort.symMerge -> sort.siftDown_func.arginfo1
sort.symMerge -> sort.symMerge.argliveinfo
 -> go:info.sort.Interface
 -> go:info.sort.swapRange$abstract
type:internal/fmtsort.SortedMap -> type:.namedata.*fmtsort.SortedMap.
type:internal/fmtsort.SortedMap -> type:*internal/fmtsort.SortedMap <UsedInIface>
type:internal/fmtsort.SortedMap -> type:.importpath.internal/fmtsort.
type:internal/fmtsort.SortedMap -> type:[]reflect.Value
type:internal/fmtsort.SortedMap -> type:.namedata.Value.
type:*internal/fmtsort.SortedMap <UsedInIface> -> type:internal/fmtsort.SortedMap <UsedInIface>
type:*internal/fmtsort.SortedMap <UsedInIface> -> type:.namedata.Less.
type:internal/fmtsort.SortedMap <UsedInIface> -> type:[]reflect.Value <UsedInIface>
 -> go:info.reflect.Value.MapRange$abstract
 -> go:info.*os.File
sync.(*Map).Load -> type:map[interface {}]*sync.entry
sync.(*Map).Load -> sync.(*Map).missLocked
sync.(*Map).Load -> sync.(*Mutex).unlockSlow
sync.(*Map).Load -> sync.expunged
sync.(*Map).Load -> gclocals·wl1vtBOUPMe6N1JPefYkhQ==
sync.(*Map).Load -> gclocals·jJ8ja1/jmWH9tDQl2RSkDQ==
sync.(*Map).Load -> reflect.(*visibleFieldsWalker).walk.stkobj
sync.(*Map).Load -> reflect.(*visibleFieldsWalker).walk.argliveinfo
sync.(*Map).Load -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
sync.(*Map).LoadOrStore -> sync.(*entry).tryLoadOrStore
sync.(*Map).LoadOrStore -> sync/atomic.CompareAndSwapPointer
sync.(*Map).LoadOrStore -> sync.(*Map).dirtyLocked
sync.(*Map).LoadOrStore -> type:sync.readOnly
sync.(*Map).LoadOrStore -> sync/atomic.StorePointer
sync.(*Map).LoadOrStore -> type:sync.entry
sync.(*Map).LoadOrStore -> gclocals·HC21lmAga297N7vuzGHUDg==
sync.(*Map).LoadOrStore -> gclocals·DbWXrTdeWrUuY0ozKt2L1A==
sync.(*entry).tryLoadOrStore -> gclocals·j5wcPKpMKxIy4zdAiLpm0A==
sync.(*Map).Swap -> sync.(*entry).trySwap
sync.(*Map).Swap -> sync/atomic.SwapPointer
sync.(*Map).Swap -> gclocals·1zpSMDqJQ8RuXDYEdAEFew==
sync.(*Map).Swap -> gclocals·ljrYOScoFb1ud/sqw7SvNg==
sync.(*Map).Swap -> sync.(*Map).Swap.argliveinfo
sync.(*entry).trySwap -> go:sehuw.12.AQoCBQoDB1AAAAAA
sync.(*Map).dirtyLocked -> runtime.mapiterinit
sync.(*Map).dirtyLocked -> runtime.mapiternext
sync.(*Map).dirtyLocked -> sync.(*entry).tryExpungeLocked
sync.(*Map).dirtyLocked -> gclocals·/9RxZvb+4Ck/lPTHs/4w0w==
sync.(*Map).dirtyLocked -> gclocals·g2xXkQTNrBYZm05Tk+XJMw==
sync.(*Map).dirtyLocked -> sync.(*Map).dirtyLocked.stkobj
sync.(*Map).dirtyLocked -> go:sehuw.12.ARMCBRMDEFAAAAAA
sync.(*Mutex).lockSlow -> sync.runtime_canSpin
sync.(*Mutex).lockSlow -> go:string."sync: inconsistent mutex state"
sync.(*Mutex).lockSlow -> sync.throw
sync.(*Mutex).lockSlow -> sync.runtime_nanotime
sync.(*Mutex).lockSlow -> sync.runtime_SemacquireMutex
sync.(*Mutex).lockSlow -> sync.runtime_doSpin
sync.(*Mutex).unlockSlow -> go:string."sync: unlock of unlocked mutex"
sync.(*Mutex).unlockSlow -> sync.fatal
sync.(*Mutex).unlockSlow -> sync.runtime_Semrelease
sync.(*Pool).Put -> sync.(*Pool).pin
sync.(*Pool).Put -> sync.(*poolChain).pushHead
sync.(*Pool).Put -> sync.runtime_procUnpin
sync.(*Pool).Get -> sync.(*poolChain).popHead
sync.(*Pool).Get -> sync.(*Pool).getSlow
sync.(*Pool).getSlow -> sync.(*poolChain).popTail
sync.(*Pool).pin -> sync.runtime_procPin
sync.(*Pool).pin -> sync.(*Pool).pinSlow
sync.(*Pool).pinSlow -> sync.allPoolsMu
sync.(*Pool).pinSlow -> sync.(*Pool).pinSlow.func1
sync.(*Pool).pinSlow -> sync.allPools
sync.(*Pool).pinSlow -> runtime.GOMAXPROCS
sync.(*Pool).pinSlow -> type:sync.poolLocal
sync.(*Pool).pinSlow -> gclocals·JmGfyNPPelOiSzqL1jXHRA==
sync.(*Pool).pinSlow -> fmt.(*ss).Token.opendefer
sync.(*poolChain).pushHead -> type:sync.poolChainElt
sync.(*poolChain).pushHead -> type:sync.eface
sync.(*poolChain).pushHead -> sync.(*poolDequeue).pushHead
sync.(*poolChain).pushHead -> gclocals·mlqWOeCrrO7xsUuS1KsOLQ==
sync.(*poolChain).pushHead -> gclocals·SVDO1fant1cX8pWTIX3vAw==
sync.(*poolDequeue).pushHead -> type:sync.dequeueNil <UsedInIface>
sync.(*poolChain).popHead -> sync.(*poolDequeue).popHead
sync.(*poolChain).popTail -> sync.(*poolDequeue).popTail
sync.(*poolChain).popTail -> gclocals·CaiEmdWPuWyE030RkY62Hw==
 -> go:info.*interface {}
 -> go:info.[]*sync.Pool
type:sync.entry -> type:.eqfunc.sync.entry
type:sync.entry -> type:.namedata.*sync.entry-
type:sync.entry -> type:*sync.entry
type:sync.entry -> type:.importpath.sync.
type:sync.entry -> type:sync/atomic.Pointer[interface {}]
type:*sync.entry -> type:.namedata.delete-
type:*sync.entry -> type:.namedata.load-
type:*sync.entry -> type:.namedata.swapLocked-
type:*sync.entry -> type:.namedata.tryCompareAndSwap-
type:*sync.entry -> type:.namedata.tryExpungeLocked-
type:*sync.entry -> type:.namedata.tryLoadOrStore-
type:*sync.entry -> type:.namedata.trySwap-
type:*sync.entry -> type:.namedata.unexpungeLocked-
type:sync.readOnly -> type:.namedata.*sync.readOnly-
type:sync.readOnly -> type:*sync.readOnly
type:sync.readOnly -> type:.namedata.amended-
type:sync.eface -> type:.namedata.*sync.eface-
type:sync.eface -> type:*sync.eface
type:sync.eface -> type:.namedata.val-
type:sync.poolChainElt -> type:.namedata.*sync.poolChainElt-
type:sync.poolChainElt -> type:*sync.poolChainElt
type:sync.poolChainElt -> type:.namedata.poolDequeue-.embedded
type:sync.poolChainElt -> type:sync.poolDequeue
type:sync.poolDequeue -> type:.namedata.*sync.poolDequeue-
type:sync.poolDequeue -> type:*sync.poolDequeue
type:sync.poolDequeue -> type:.namedata.headTail-
type:sync.poolDequeue -> type:.namedata.vals-
type:sync.poolDequeue -> type:[]sync.eface
type:*sync.poolDequeue -> type:.namedata.pack-
type:*sync.poolDequeue -> type:.namedata.popHead-
type:*sync.poolDequeue -> type:.namedata.popTail-
type:*sync.poolDequeue -> type:.namedata.pushHead-
type:*sync.poolDequeue -> type:.namedata.unpack-
type:sync.poolLocal -> type:.eqfunc.sync.poolLocal
type:sync.poolLocal -> type:.namedata.*sync.poolLocal-
type:sync.poolLocal -> type:*sync.poolLocal
type:sync.poolLocal -> type:.namedata.poolLocalInternal-.embedded
type:sync.poolLocal -> type:sync.poolLocalInternal
type:sync.poolLocal -> type:[96]uint8
type:sync.poolLocalInternal -> type:.eqfunc.sync.poolLocalInternal
type:sync.poolLocalInternal -> type:.namedata.*sync.poolLocalInternal-
type:sync.poolLocalInternal -> type:*sync.poolLocalInternal
type:sync.poolLocalInternal -> type:.namedata.private-
type:sync.poolLocalInternal -> type:.namedata.shared-
type:sync.poolLocalInternal -> type:sync.poolChain
type:sync.poolChain -> type:.namedata.*sync.poolChain-
type:sync.poolChain -> type:*sync.poolChain
type:sync.poolChain -> type:.namedata.tail-
type:*sync.Pool <UsedInIface> -> type:.namedata.*sync.Pool.
type:*sync.Pool <UsedInIface> -> type:sync.Pool <UsedInIface>
type:*sync.Pool <UsedInIface> -> type:.namedata.Put.
type:*sync.Pool <UsedInIface> -> type:.namedata.getSlow-
type:*sync.Pool <UsedInIface> -> type:.namedata.pin-
type:*sync.Pool <UsedInIface> -> type:.namedata.pinSlow-
type:sync.Pool <UsedInIface> -> type:sync.noCopy <UsedInIface>
type:sync.Pool <UsedInIface> -> type:.namedata.local-
type:sync.Pool <UsedInIface> -> type:.namedata.localSize-
type:sync.Pool <UsedInIface> -> type:.namedata.victim-
type:sync.Pool <UsedInIface> -> type:.namedata.victimSize-
type:sync.Pool <UsedInIface> -> type:.namedata.New.
type:sync.Pool <UsedInIface> -> type:func() interface {} <UsedInIface>
type:sync.noCopy <UsedInIface> -> type:.namedata.*sync.noCopy-
type:sync.noCopy <UsedInIface> -> type:*sync.noCopy <UsedInIface>
type:sync.dequeueNil <UsedInIface> -> type:.namedata.*sync.dequeueNil-
 -> go:info.*sync.Map
 -> go:info.*sync.entry
 -> go:info.sync.readOnly
 -> go:info.sync.(*Map).loadReadOnly$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]).Load$abstract
 -> go:info.sync.(*Mutex).Unlock$abstract
 -> go:info.sync.(*entry).load$abstract
 -> go:info.sync.(*entry).unexpungeLocked$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.interface {}]).CompareAndSwap$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]).Store$abstract
 -> go:info.sync.newEntry$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.interface {}]).Store$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.interface {}]).Load$abstract
 -> go:info.sync.(*entry).swapLocked$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.interface {}]).Swap$abstract
 -> go:info.map[interface {}]*sync.entry
 -> go:info.*sync.Mutex
 -> go:info.*sync.poolLocal
 -> go:info.sync.indexLocal$abstract
 -> go:info.[]sync.poolLocal
 -> go:info.*sync.poolDequeue
 -> go:info.sync.(*poolDequeue).unpack$abstract
 -> go:info.sync.(*poolDequeue).pack$abstract
 -> go:info.*sync.poolChain
 -> go:info.*sync.poolChainElt
 -> go:info.sync.storePoolChainElt$abstract
 -> go:info.sync.loadPoolChainElt$abstract
internal/abi.(*Type).ExportedMethods -> internal/abi.(*Type).ExportedMethods.jump7
internal/abi.(*Type).ExportedMethods -> go:sehuw.12.AQQCBQQDAVAAAAAA
internal/abi.NewName -> go:string."abi.NewName: tag too long: "
internal/abi.NewName -> go:string."abi.NewName: name too long: "
internal/abi.NewName -> gclocals·TvPEz2KMfo+ULBIyE3rwXg==
internal/abi.NewName -> gclocals·zshnMFzKa7rpeOD7D+TwQg==
internal/abi.NewName -> reflect.newName.arginfo1
internal/abi.NewName -> go:sehuw.12.ARMCBRMDEFAAAAAA
type:internal/abi.Method <UsedInIface> -> type:.namedata.*abi.Method.
type:internal/abi.Method <UsedInIface> -> type:*internal/abi.Method <UsedInIface>
type:internal/abi.Method <UsedInIface> -> type:.namedata.Mtyp.
type:internal/abi.Method <UsedInIface> -> type:.namedata.Ifn.
type:internal/abi.Method <UsedInIface> -> type:internal/abi.TextOff <UsedInIface>
type:internal/abi.Method <UsedInIface> -> type:.namedata.Tfn.
type:internal/abi.TextOff <UsedInIface> -> type:.namedata.*abi.TextOff.
type:internal/abi.TextOff <UsedInIface> -> type:*internal/abi.TextOff <UsedInIface>
type:internal/abi.FuncType <UsedInIface> -> type:.namedata.*abi.FuncType.
type:internal/abi.FuncType <UsedInIface> -> type:.namedata.InCount.
type:internal/abi.FuncType <UsedInIface> -> type:.namedata.OutCount.
type:internal/abi.StructField -> type:.namedata.*abi.StructField.
type:internal/abi.StructField -> type:*internal/abi.StructField
type:internal/abi.StructField -> type:.namedata.Offset.
type:*internal/abi.StructField -> type:.namedata.Embedded.
type:internal/abi.StructType <UsedInIface> -> type:.namedata.*abi.StructType.
type:internal/abi.StructType <UsedInIface> -> type:*internal/abi.StructType <UsedInIface>
type:internal/abi.StructType <UsedInIface> -> type:internal/abi.Name <UsedInIface>
type:internal/abi.StructType <UsedInIface> -> type:.namedata.Fields.
type:internal/abi.StructType <UsedInIface> -> type:[]internal/abi.StructField <UsedInIface>
type:internal/abi.Name <UsedInIface> -> type:*internal/abi.Name <UsedInIface>
type:internal/abi.UncommonType <UsedInIface> -> type:.eqfunc.internal/abi.UncommonType
type:internal/abi.UncommonType <UsedInIface> -> type:.namedata.*abi.UncommonType.
type:internal/abi.UncommonType <UsedInIface> -> type:*internal/abi.UncommonType <UsedInIface>
type:internal/abi.UncommonType <UsedInIface> -> type:.namedata.Mcount.
type:internal/abi.UncommonType <UsedInIface> -> type:.namedata.Xcount.
type:internal/abi.UncommonType <UsedInIface> -> type:.namedata.Moff.
type:*internal/abi.FuncType <UsedInIface> -> type:.namedata.InSlice.
type:*internal/abi.FuncType <UsedInIface> -> type:.namedata.OutSlice.
type:internal/abi.ArrayType -> type:.namedata.*abi.ArrayType.
type:internal/abi.ArrayType -> type:*internal/abi.ArrayType
type:internal/abi.PtrType <UsedInIface> -> type:.namedata.*abi.PtrType.
type:internal/abi.PtrType <UsedInIface> -> type:*internal/abi.PtrType <UsedInIface>
type:internal/abi.SliceType -> type:.namedata.*abi.SliceType.
type:internal/abi.SliceType -> type:*internal/abi.SliceType
 -> go:info.internal/abi.(*InterfaceType).NumMethod$abstract
 -> go:info.[10]uint8
 -> go:info.internal/abi.writeVarint$abstract
type:internal/unsafeheader.Slice -> type:.namedata.*unsafeheader.Slice.
type:internal/unsafeheader.Slice -> type:*internal/unsafeheader.Slice
type:internal/unsafeheader.Slice -> type:.importpath.internal/unsafeheader.
type:internal/unsafeheader.String -> type:.namedata.*unsafeheader.String.
type:internal/unsafeheader.String -> type:*internal/unsafeheader.String
unicode.isExcludingLatin -> unicode.is16
unicode.isExcludingLatin -> unicode.is32
unicode.isExcludingLatin -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
unicode.is16 -> strconv.bsearch16.arginfo1
unicode.is16 -> go:sehuw.12.AQQCBQQDAVAAAAAA
unicode.Digit -> unicode..stmp_45
 -> go:info.*unicode.RangeTable
unicode.Letter -> unicode..stmp_14
unicode..stmp_14 -> unicode..stmp_15
unicode..stmp_14 -> unicode..stmp_16
unicode..stmp_45 -> unicode..stmp_46
unicode..stmp_45 -> unicode..stmp_47
 -> go:info.[]unicode.Range16
 -> go:info.[]unicode.Range32
runtime.GOMAXPROCS -> runtime.stopTheWorldGC
runtime.GOMAXPROCS -> runtime.startTheWorldGC
runtime.panicdottypeI -> gclocals·fWLdQmOFX5Z+dYDCTrASBg==
runtime.convT32 -> runtime.uint32Type
runtime.convTslice -> runtime.sliceType
runtime.mapiternext -> go:string."concurrent map iteration and map write"
runtime.mapiternext -> runtime.mapaccessK
runtime.mapiternext -> gclocals·zRZBaN0Lhivk+9i/uk5tJg==
runtime.mapaccessK -> gclocals·8HYvUm/9PzQ8yY+N9GNIXQ==
runtime.mapaccessK -> gclocals·4nVopPAMYEza9h2wjiR3SQ==
runtime.GC -> runtime.gcWaitOnMark
runtime.GC -> runtime.mProf_PostSweep
runtime.deferprocStack -> runtime.return0
runtime.deferprocStack -> go:string."defer on system stack"
runtime.stopTheWorldGC -> runtime.stopTheWorld
runtime.stopTheWorld -> runtime.stopTheWorld.func1
runtime.startTheWorldGC -> runtime.startTheWorld
runtime.startTheWorld -> runtime.startTheWorld.func1·f
runtime.concatstring4 -> gclocals·vXi8VFVnn6c0AV6oT7spEA==
runtime.concatstring4 -> gclocals·Hy98/6xEkdIEkxCdiINBiA==
runtime.concatstring4 -> runtime.concatstring4.stkobj
runtime.concatstring4 -> runtime.concatstring4.arginfo1
runtime.concatstring4 -> runtime.concatstring4.argliveinfo
runtime.concatstring5 -> gclocals·xX7X77/6/gwCrnInbrSwQg==
runtime.concatstring5 -> gclocals·0XJawOT6f8RgJWfORwBNwg==
runtime.concatstring5 -> runtime.concatstring5.stkobj
runtime.concatstring5 -> runtime.concatstring5.arginfo1
runtime.concatstring5 -> runtime.concatstring5.argliveinfo
runtime.stringtoslicebyte -> runtime.rawbyteslice
runtime.stringtoslicebyte -> runtime.stringtoslicebyte.argliveinfo
runtime.rawbyteslice -> gclocals·lUgQyKx2gV0d+E2SxNDfkg==
runtime.(*Frames).Next -> runtime.expandCgoFrames
runtime.(*Frames).Next -> type:runtime.Frame
runtime.(*Frames).Next -> runtime.(*Func).Entry
runtime.(*Frames).Next -> gclocals·91POOaJmbl2xpndDwSmh3g==
runtime.(*Frames).Next -> gclocals·eKa1AQhWynlKDwe95GYVew==
runtime.(*Frames).Next -> runtime.(*Frames).Next.stkobj
runtime.(*Frames).Next -> runtime.(*Frames).Next.arginfo1
runtime.(*Frames).Next -> runtime.(*Frames).Next.argliveinfo
runtime.expandCgoFrames -> runtime.gostring
runtime.expandCgoFrames -> gclocals·VmcHiHVK6ANTmtzlPXg6nw==
runtime.expandCgoFrames -> runtime.expandCgoFrames.stkobj
runtime.panicunsafeslicenilptr -> runtime.panicunsafeslicenilptr1
runtime.panicunsafeslicenilptr1 -> go:string."unsafe.Slice: ptr is nil and len is not zero"
runtime.panicunsafeslicenilptr1 -> runtime..stmp_164
type:runtime.Frame -> type:.eqfunc.runtime.Frame
type:runtime.Frame -> runtime.gcbits.1600000000000000
type:runtime.Frame -> type:.namedata.*runtime.Frame.
type:runtime.Frame -> type:*runtime.Frame
type:runtime.Frame -> type:.namedata.PC.
type:runtime.Frame -> type:.namedata.Func.
type:runtime.Frame -> type:*runtime.Func
type:runtime.Frame -> type:.namedata.Function.
type:runtime.Frame -> type:.namedata.File.
type:runtime.Frame -> type:.namedata.Line.
type:runtime.Frame -> type:.namedata.startLine-
type:runtime.Frame -> type:.namedata.Entry.
type:runtime.Frame -> type:.namedata.funcInfo-
type:runtime.Frame -> type:runtime.funcInfo
type:runtime.funcInfo -> type:.namedata.*runtime.funcInfo-
type:runtime.funcInfo -> type:*runtime.funcInfo
type:runtime.funcInfo -> type:.namedata._func-.embedded
type:runtime.funcInfo -> type:*runtime._func
type:runtime.funcInfo -> type:.namedata.datap-
type:runtime.funcInfo -> type:.namedata._Func-
type:runtime.funcInfo -> type:.namedata.entry-
type:runtime.funcInfo -> type:.namedata.isInlined-
type:runtime.funcInfo -> type:.namedata.srcFunc-
type:runtime.funcInfo -> type:.namedata.valid-
type:*runtime._func -> type:.namedata.*runtime._func-
type:*runtime._func -> type:runtime._func
type:runtime._func -> type:.eqfunc.runtime._func
type:runtime._func -> type:.namedata.entryOff-
type:runtime._func -> type:.namedata.deferreturn-
type:runtime._func -> type:.namedata.pcsp-
type:runtime._func -> type:.namedata.pcfile-
type:runtime._func -> type:.namedata.pcln-
type:runtime._func -> type:.namedata.npcdata-
type:runtime._func -> type:.namedata.funcID-
type:runtime._func -> type:internal/abi.FuncID
type:runtime._func -> type:.namedata.flag-
type:runtime._func -> type:internal/abi.FuncFlag
type:runtime._func -> type:[1]uint8
type:runtime._func -> type:.namedata.nfuncdata-
type:internal/abi.FuncFlag -> type:.namedata.*abi.FuncFlag.
type:internal/abi.FuncFlag -> type:*internal/abi.FuncFlag
type:internal/abi.FuncID -> type:.namedata.*abi.FuncID.
type:internal/abi.FuncID -> type:*internal/abi.FuncID
type:*runtime.Func -> type:.namedata.*runtime.Func.
type:*runtime.Func -> type:runtime.Func
type:*runtime.Func -> type:.namedata.FileLine.
type:*runtime.Func -> type:.namedata.raw-
type:runtime.Func -> type:.namedata.opaque-
type:runtime.Frames -> runtime.gcbits.89052c0000000000
type:runtime.Frames -> type:.namedata.*runtime.Frames.
type:runtime.Frames -> type:*runtime.Frames
type:runtime.Frames -> type:.namedata.callers-
type:runtime.Frames -> type:.namedata.frames-
type:runtime.Frames -> type:[]runtime.Frame
type:runtime.Frames -> type:.namedata.frameStore-
type:runtime.Frames -> type:[2]runtime.Frame
type:*runtime.Frames -> type:.namedata.Next.
 -> go:info.runtime.panicdottypeE$abstract
 -> go:info.runtime.assertE2I$abstract
 -> go:info.*runtime.hiter
 -> go:info.runtime.fastrand64$abstract
 -> go:info.*runtime.Func
 -> go:info.[]runtime.Frame
 -> go:info.*runtime._func
 -> go:info.*runtime.funcinl
 -> go:info.runtime.(*_func).isInlined$abstract
 -> go:info.runtime.(*_func).funcInfo$abstract
go:itab.*os.File,io.Writer -> type:io.Writer
go:itab.*os.File,io.Writer -> type:*os.File <UsedInIface>
type:io.Writer -> type:.namedata.*io.Writer.
type:io.Writer -> type:*io.Writer
type:io.Writer -> type:.importpath.io.
type:io.Writer -> type:func([]uint8) (int, error) <UsedInIface>
type:*os.File <UsedInIface> -> type:.namedata.*os.File.
type:*os.File <UsedInIface> -> type:os.File <UsedInIface>
type:*os.File <UsedInIface> -> type:.importpath.os.
type:*os.File <UsedInIface> -> type:.namedata.Chdir.
type:*os.File <UsedInIface> -> type:.namedata.Chmod.
type:*os.File <UsedInIface> -> type:.namedata.Chown.
type:*os.File <UsedInIface> -> type:.namedata.Fd.
type:*os.File <UsedInIface> -> type:.namedata.Read.
type:*os.File <UsedInIface> -> type:.namedata.ReadAt.
type:*os.File <UsedInIface> -> type:.namedata.ReadDir.
type:*os.File <UsedInIface> -> type:.namedata.ReadFrom.
type:*os.File <UsedInIface> -> type:.namedata.Readdir.
type:*os.File <UsedInIface> -> type:.namedata.Readdirnames.
type:*os.File <UsedInIface> -> type:.namedata.Seek.
type:*os.File <UsedInIface> -> type:.namedata.SetDeadline.
type:*os.File <UsedInIface> -> type:.namedata.SetReadDeadline.
type:*os.File <UsedInIface> -> type:.namedata.SetWriteDeadline.
type:*os.File <UsedInIface> -> type:.namedata.Stat.
type:*os.File <UsedInIface> -> type:.namedata.Sync.
type:*os.File <UsedInIface> -> type:.namedata.SyscallConn.
type:*os.File <UsedInIface> -> type:.namedata.Truncate.
type:*os.File <UsedInIface> -> type:.namedata.WriteAt.
type:*os.File <UsedInIface> -> type:.namedata.checkValid-
type:*os.File <UsedInIface> -> type:.namedata.chmod-
type:*os.File <UsedInIface> -> type:.namedata.close-
type:*os.File <UsedInIface> -> type:.namedata.pread-
type:*os.File <UsedInIface> -> type:.namedata.pwrite-
type:*os.File <UsedInIface> -> type:.namedata.read-
type:*os.File <UsedInIface> -> type:.namedata.readFrom-
type:*os.File <UsedInIface> -> type:.namedata.readdir-
type:*os.File <UsedInIface> -> type:.namedata.seek-
type:*os.File <UsedInIface> -> type:.namedata.setDeadline-
type:*os.File <UsedInIface> -> type:.namedata.setReadDeadline-
type:*os.File <UsedInIface> -> type:.namedata.setWriteDeadline-
type:*os.File <UsedInIface> -> type:.namedata.wrapErr-
type:os.File <UsedInIface> -> type:.namedata.file-.embedded
type:os.File <UsedInIface> -> type:*os.file <UsedInIface>
type:*os.file <UsedInIface> -> type:.namedata.*os.file-
type:*os.file <UsedInIface> -> type:os.file <UsedInIface>
type:os.file <UsedInIface> -> runtime.gcbits.00b46404d0921192a000000000000000
type:os.file <UsedInIface> -> type:.namedata.pfd-
type:os.file <UsedInIface> -> type:internal/poll.FD <UsedInIface>
type:os.file <UsedInIface> -> type:.namedata.dirinfo-
type:os.file <UsedInIface> -> type:*os.dirInfo <UsedInIface>
type:os.file <UsedInIface> -> type:.namedata.appendMode-
type:*os.dirInfo <UsedInIface> -> type:.namedata.*os.dirInfo-
type:*os.dirInfo <UsedInIface> -> type:os.dirInfo <UsedInIface>
type:os.dirInfo <UsedInIface> -> type:.eqfunc.os.dirInfo
type:os.dirInfo <UsedInIface> -> type:*[]uint8 <UsedInIface>
type:os.dirInfo <UsedInIface> -> type:.namedata.bufp-
type:os.dirInfo <UsedInIface> -> type:.namedata.vol-
type:internal/poll.FD <UsedInIface> -> runtime.gcbits.00b46404d0921192
type:internal/poll.FD <UsedInIface> -> type:.namedata.*poll.FD.
type:internal/poll.FD <UsedInIface> -> type:*internal/poll.FD <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.importpath.internal/poll.
type:internal/poll.FD <UsedInIface> -> type:.namedata.fdmu-
type:internal/poll.FD <UsedInIface> -> type:internal/poll.fdMutex <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.namedata.Sysfd.
type:internal/poll.FD <UsedInIface> -> type:syscall.Handle <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.namedata.rop-
type:internal/poll.FD <UsedInIface> -> type:internal/poll.operation <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.namedata.wop-
type:internal/poll.FD <UsedInIface> -> type:.namedata.pd-
type:internal/poll.FD <UsedInIface> -> type:internal/poll.pollDesc <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.namedata.l-
type:internal/poll.FD <UsedInIface> -> type:sync.Mutex <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.namedata.lastbits-
type:internal/poll.FD <UsedInIface> -> type:.namedata.readuint16-
type:internal/poll.FD <UsedInIface> -> type:[]uint16 <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.namedata.readbyte-
type:internal/poll.FD <UsedInIface> -> type:.namedata.readbyteOffset-
type:internal/poll.FD <UsedInIface> -> type:.namedata.csema-
type:internal/poll.FD <UsedInIface> -> type:.namedata.skipSyncNotif-
type:internal/poll.FD <UsedInIface> -> type:.namedata.IsStream.
type:internal/poll.FD <UsedInIface> -> type:.namedata.ZeroReadIsEOF.
type:internal/poll.FD <UsedInIface> -> type:.namedata.isFile-
type:internal/poll.FD <UsedInIface> -> type:internal/poll.fileKind <UsedInIface>
type:sync.Mutex <UsedInIface> -> type:.namedata.*sync.Mutex.
type:sync.Mutex <UsedInIface> -> type:*sync.Mutex <UsedInIface>
type:sync.Mutex <UsedInIface> -> type:.namedata.sema-
type:*sync.Mutex <UsedInIface> -> type:.namedata.TryLock.
type:*sync.Mutex <UsedInIface> -> type:.namedata.lockSlow-
type:*sync.Mutex <UsedInIface> -> type:.namedata.unlockSlow-
type:syscall.Handle <UsedInIface> -> type:.namedata.*syscall.Handle.
type:syscall.Handle <UsedInIface> -> type:*syscall.Handle <UsedInIface>
type:internal/poll.fdMutex <UsedInIface> -> type:.namedata.*poll.fdMutex-
type:internal/poll.fdMutex <UsedInIface> -> type:*internal/poll.fdMutex <UsedInIface>
type:internal/poll.fdMutex <UsedInIface> -> type:.namedata.rsema-
type:internal/poll.fdMutex <UsedInIface> -> type:.namedata.wsema-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.decref-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.incref-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.increfAndClose-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.rwlock-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.rwunlock-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Accept.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ConnectEx.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Fchdir.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Fchmod.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Fchown.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Fsync.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Ftruncate.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.GetFileInformationByHandle.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.GetFileType.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.GetsockoptInt.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Init.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Pread.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Pwrite.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.RawControl.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.RawRead.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.RawWrite.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadFromInet4.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadFromInet6.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadMsg.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadMsgInet4.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadMsgInet6.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Setsockopt.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptIPMreq.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptIPv6Mreq.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptInet4Addr.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptInt.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptLinger.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Shutdown.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WSAIoctl.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteMsg.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteMsgInet4.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteMsgInet6.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteTo.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteToInet4.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteToInet6.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Writev.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.acceptOne-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.eofError-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.readConsole-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.readLock-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.readUnlock-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.writeConsole-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.writeLock-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.writeUnlock-
type:internal/poll.operation <UsedInIface> -> runtime.gcbits.80968c0000000000
type:internal/poll.operation <UsedInIface> -> type:.namedata.*poll.operation-
type:internal/poll.operation <UsedInIface> -> type:*internal/poll.operation <UsedInIface>
type:internal/poll.operation <UsedInIface> -> type:.namedata.o-
type:internal/poll.operation <UsedInIface> -> type:syscall.Overlapped <UsedInIface>
type:internal/poll.operation <UsedInIface> -> type:.namedata.runtimeCtx-
type:internal/poll.operation <UsedInIface> -> type:.namedata.mode-
type:internal/poll.operation <UsedInIface> -> type:.namedata.errno-
type:internal/poll.operation <UsedInIface> -> type:.namedata.qty-
type:internal/poll.operation <UsedInIface> -> type:syscall.WSABuf <UsedInIface>
type:internal/poll.operation <UsedInIface> -> type:.namedata.msg-
type:internal/poll.operation <UsedInIface> -> type:internal/syscall/windows.WSAMsg <UsedInIface>
type:internal/poll.operation <UsedInIface> -> type:.namedata.sa-
type:internal/poll.operation <UsedInIface> -> type:syscall.Sockaddr <UsedInIface>
type:internal/poll.operation <UsedInIface> -> type:.namedata.rsa-
type:internal/poll.operation <UsedInIface> -> type:*syscall.RawSockaddrAny <UsedInIface>
type:internal/poll.operation <UsedInIface> -> type:.namedata.rsan-
type:internal/poll.operation <UsedInIface> -> type:.namedata.handle-
type:internal/poll.operation <UsedInIface> -> type:.namedata.bufs-
type:internal/poll.operation <UsedInIface> -> type:[]syscall.WSABuf <UsedInIface>
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:.eqfunc.internal/syscall/windows.WSAMsg
type:internal/syscall/windows.WSAMsg <UsedInIface> -> runtime.gcbits.2500000000000000
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:.namedata.*windows.WSAMsg.
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:*internal/syscall/windows.WSAMsg <UsedInIface>
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:.importpath.internal/syscall/windows.
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:syscall.Pointer <UsedInIface>
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:.namedata.Namelen.
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:.namedata.Buffers.
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:*syscall.WSABuf <UsedInIface>
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:.namedata.BufferCount.
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:.namedata.Control.
type:internal/syscall/windows.WSAMsg <UsedInIface> -> type:.namedata.Flags.
type:syscall.Sockaddr <UsedInIface> -> type:.namedata.*syscall.Sockaddr.
type:syscall.Sockaddr <UsedInIface> -> type:*syscall.Sockaddr <UsedInIface>
type:syscall.Sockaddr <UsedInIface> -> type:.namedata.sockaddr-
type:syscall.Sockaddr <UsedInIface> -> type:func() (unsafe.Pointer, int32, error) <UsedInIface>
type:syscall.Pointer <UsedInIface> -> type:.namedata.*syscall.Pointer.
type:syscall.Overlapped <UsedInIface> -> type:.namedata.*syscall.Overlapped.
type:syscall.Overlapped <UsedInIface> -> type:*syscall.Overlapped <UsedInIface>
type:syscall.Overlapped <UsedInIface> -> type:.namedata.Internal.
type:syscall.Overlapped <UsedInIface> -> type:.namedata.InternalHigh.
type:syscall.Overlapped <UsedInIface> -> type:.namedata.OffsetHigh.
type:syscall.Overlapped <UsedInIface> -> type:.namedata.HEvent.
type:*syscall.RawSockaddrAny <UsedInIface> -> type:.namedata.*syscall.RawSockaddrAny.
type:*syscall.RawSockaddrAny <UsedInIface> -> type:syscall.RawSockaddrAny <UsedInIface>
type:*syscall.RawSockaddrAny <UsedInIface> -> type:.namedata.Sockaddr.
type:syscall.RawSockaddrAny <UsedInIface> -> type:.eqfunc116
type:syscall.RawSockaddrAny <UsedInIface> -> type:syscall.RawSockaddr <UsedInIface>
type:syscall.RawSockaddrAny <UsedInIface> -> type:.namedata.Pad.
type:syscall.RawSockaddrAny <UsedInIface> -> type:[100]int8 <UsedInIface>
type:syscall.RawSockaddr <UsedInIface> -> type:.namedata.*syscall.RawSockaddr.
type:syscall.RawSockaddr <UsedInIface> -> type:*syscall.RawSockaddr <UsedInIface>
type:syscall.RawSockaddr <UsedInIface> -> type:.namedata.Family.
type:syscall.RawSockaddr <UsedInIface> -> type:[14]int8 <UsedInIface>
type:*syscall.WSABuf <UsedInIface> -> type:.namedata.*syscall.WSABuf.
type:syscall.WSABuf <UsedInIface> -> type:.eqfunc.syscall.WSABuf
type:syscall.WSABuf <UsedInIface> -> type:.namedata.Buf.
type:*internal/poll.operation <UsedInIface> -> type:.namedata.ClearBufs.
type:*internal/poll.operation <UsedInIface> -> type:.namedata.InitBuf.
type:*internal/poll.operation <UsedInIface> -> type:.namedata.InitBufs.
type:*internal/poll.operation <UsedInIface> -> type:.namedata.InitMsg.
type:internal/poll.pollDesc <UsedInIface> -> type:.namedata.*poll.pollDesc-
type:internal/poll.pollDesc <UsedInIface> -> type:*internal/poll.pollDesc <UsedInIface>
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.evict-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.pollable-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.prepare-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.prepareRead-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.prepareWrite-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.wait-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.waitCanceled-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.waitRead-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.waitWrite-
type:internal/poll.fileKind <UsedInIface> -> type:.namedata.*poll.fileKind-
type:internal/poll.fileKind <UsedInIface> -> type:*internal/poll.fileKind <UsedInIface>
go:info.reflect.unpackEface$abstract -> go:info.*reflect.emptyInterface
go:itab.*fmt.pp,fmt.State -> type:fmt.State
type:fmt.State -> type:.namedata.*fmt.State.
type:fmt.State -> type:*fmt.State
type:fmt.State -> type:func(int) bool <UsedInIface>
type:fmt.State -> type:func() (int, bool) <UsedInIface>
fmt..stmp_3 -> go:string."fmt: unknown base; can't happen"
type:func([]uint8) (int, error) <UsedInIface> -> type:.namedata.*func([]uint8) (int, error)-
type:func([]uint8) (int, error) <UsedInIface> -> type:error <UsedInIface>
type:error <UsedInIface> -> type:*error <UsedInIface>
type:func() (int, bool) <UsedInIface> -> type:.namedata.*func() (int, bool)-
type:func(int) bool <UsedInIface> -> type:.namedata.*func(int) bool-
type:[68]uint8 <UsedInIface> -> type:.eqfunc68
type:[68]uint8 <UsedInIface> -> type:.namedata.*[68]uint8-
type:.eqfunc.fmt.fmt -> type:.eq.fmt.fmt
go:info.fmt.(*fmt).init$abstract -> go:info.*fmt.buffer
go:info.reflect.TypeOf$abstract -> go:info.reflect.emptyInterface
type:func(fmt.State, int32) -> type:.namedata.*func(fmt.State, int32)-
fmt.glob..func1·f -> fmt.glob..func1
reflect..stmp_1 -> go:string."invalid n"
reflect..stmp_4 -> go:string."unknown type kind"
reflect..stmp_7 -> go:string."non-empty pointer map passed for non-pointer-size values"
reflect..stmp_10 -> go:string."invalid argSize"
reflect..stmp_12 -> go:string."bad argSize"
reflect..stmp_14 -> go:string."can't call pointer on a non-pointer Value"
reflect..stmp_16 -> go:string."reflect: call of MakeFunc with non-Func type"
reflect..stmp_17 -> go:string."reflect: internal error: invalid use of makeMethodValue"
reflect..stmp_18 -> go:string."reflect: slice index out of range"
reflect..stmp_20 -> go:string."reflect: Method index out of range"
reflect..stmp_28 -> go:string."reflect.FuncOf: last arg of variadic func must be slice"
reflect..stmp_29 -> go:string."reflect.FuncOf: too many arguments"
reflect..stmp_32 -> go:string."reflect: unexpected GC program"
reflect..stmp_33 -> go:string."reflect: embedded interface with unexported method(s) not implemented"
reflect..stmp_34 -> go:string."reflect: embedded type with methods not implemented if type is not first field"
reflect..stmp_35 -> go:string."reflect: embedded type with methods not implemented if there is more than one field"
reflect..stmp_39 -> go:string."reflect: embedded type with methods not implemented for non-pointer type"
reflect..stmp_41 -> go:string."reflect.StructOf: struct size would exceed virtual address space"
reflect..stmp_45 -> go:string."S"
reflect..stmp_45 -> runtime.gcbits.5500000000000000
reflect..stmp_45 -> go:string."M"
reflect..stmp_46 -> go:string."reflect: negative length passed to ArrayOf"
reflect..stmp_47 -> go:string."reflect.ArrayOf: array size would exceed virtual address space"
reflect..stmp_49 -> go:string."bad indir"
reflect..stmp_50 -> go:string."reflect.Value.Addr of unaddressable value"
reflect..stmp_51 -> go:string."reflect.Value.Bytes of non-byte slice"
reflect..stmp_52 -> go:string."reflect.Value.Bytes of non-byte array"
reflect..stmp_53 -> go:string."reflect.Value.Bytes of unaddressable byte array"
reflect..stmp_55 -> go:string."reflect.Value.Call: call of nil function"
reflect..stmp_56 -> go:string."reflect: CallSlice of non-variadic function"
reflect..stmp_57 -> go:string."reflect: CallSlice with too few input arguments"
reflect..stmp_58 -> go:string."reflect: CallSlice with too many input arguments"
reflect..stmp_59 -> go:string."reflect: Call with too few input arguments"
reflect..stmp_60 -> go:string."reflect: Call with too many input arguments"
reflect..stmp_61 -> go:string."reflect.Value.Call: wrong argument count"
reflect..stmp_62 -> go:string."unknown ABI parameter kind"
reflect..stmp_63 -> go:string."attempted to copy pointer to FP register"
reflect..stmp_65 -> go:string."unknown ABI part kind"
reflect..stmp_66 -> go:string."mismatch between ABI description and types"
reflect..stmp_68 -> go:string."register-based return value has stack component"
reflect..stmp_78 -> go:string."reflect: internal error: invalid method index"
reflect..stmp_93 -> go:string."reflect: reflect.Value.Elem on an invalid notinheap pointer"
reflect..stmp_94 -> go:string."reflect: Field index out of range"
reflect..stmp_96 -> go:string."reflect: array index out of range"
reflect..stmp_98 -> go:string."reflect: string index out of range"
reflect..stmp_99 -> go:string."reflect.Value.Interface: cannot return value obtained from unexported field or method"
reflect..stmp_102 -> go:string."reflect: call of reflect.Value.Len on ptr to non-array Value"
reflect..stmp_106 -> go:string."MapIter.Key called before Next"
reflect..stmp_107 -> go:string."MapIter.Key called on exhausted iterator"
reflect..stmp_110 -> go:string."MapIter.Value called before Next"
reflect..stmp_111 -> go:string."MapIter.Value called on exhausted iterator"
reflect..stmp_114 -> go:string."MapIter.Next called on an iterator that does not have an associated map Value"
reflect..stmp_116 -> go:string."MapIter.Next called on exhausted iterator"
reflect..stmp_118 -> go:string."reflect: Method on nil interface value"
reflect..stmp_119 -> go:string."reflect: reflect.Value.Pointer on an invalid notinheap pointer"
reflect..stmp_134 -> go:string."reflect.Value.Slice: slice of unaddressable array"
reflect..stmp_135 -> go:string."reflect.Value.Slice: string slice index out of bounds"
reflect..stmp_136 -> go:string."reflect.Value.Slice: slice index out of bounds"
reflect..stmp_142 -> go:string."reflect: reflect.Value.UnsafePointer on an invalid notinheap pointer"
reflect..stmp_159 -> go:string."reflect.MakeSlice of non-slice type"
reflect..stmp_160 -> go:string."reflect.MakeSlice: negative len"
reflect..stmp_161 -> go:string."reflect.MakeSlice: negative cap"
reflect..stmp_162 -> go:string."reflect.MakeSlice: len > cap"
reflect..stmp_167 -> go:string."reflect: Zero(nil)"
reflect..stmp_168 -> go:string."reflect: New(nil)"
reflect..stmp_169 -> go:string."reflect: New of type that may not be allocated in heap (possibly undefined cgo C type)"
reflect.initFuncTypes.stkobj -> runtime.gcbits.65a24c0000000000
reflect.StructOf.stkobj -> runtime.gcbits.aaaa020000000000
reflect.StructOf.stkobj -> runtime.gcbits.65a24c9409000000
reflect.Value.call.stkobj -> runtime.gcbits.5505000000000000
type:func() int <UsedInIface> -> type:.namedata.*func() int-
type:func(reflect.Type) bool <UsedInIface> -> type:.namedata.*func(reflect.Type) bool-
type:func(reflect.Type) bool <UsedInIface> -> type:reflect.Type <UsedInIface>
type:reflect.Type <UsedInIface> -> type:*reflect.Type <UsedInIface>
type:func() reflect.ChanDir <UsedInIface> -> type:.namedata.*func() reflect.ChanDir-
type:func() reflect.ChanDir <UsedInIface> -> type:reflect.ChanDir <UsedInIface>
type:reflect.ChanDir <UsedInIface> -> type:.namedata.*reflect.ChanDir.
type:reflect.ChanDir <UsedInIface> -> type:*reflect.ChanDir <UsedInIface>
type:func() reflect.Type <UsedInIface> -> type:.namedata.*func() reflect.Type-
type:func(int) reflect.StructField <UsedInIface> -> type:.namedata.*func(int) reflect.StructField-
type:func(int) reflect.StructField <UsedInIface> -> type:reflect.StructField <UsedInIface>
type:reflect.StructField <UsedInIface> -> runtime.gcbits.6502000000000000
type:reflect.StructField <UsedInIface> -> type:.namedata.*reflect.StructField.
type:reflect.StructField <UsedInIface> -> type:*reflect.StructField <UsedInIface>
type:reflect.StructField <UsedInIface> -> type:reflect.StructTag <UsedInIface>
type:reflect.StructField <UsedInIface> -> type:.namedata.Anonymous.
type:reflect.StructTag <UsedInIface> -> type:.namedata.*reflect.StructTag.
type:reflect.StructTag <UsedInIface> -> type:*reflect.StructTag <UsedInIface>
type:reflect.StructTag <UsedInIface> -> type:.namedata.Lookup.
type:func([]int) reflect.StructField <UsedInIface> -> type:.namedata.*func([]int) reflect.StructField-
type:func(string) (reflect.StructField, bool) <UsedInIface> -> type:.namedata.*func(string) (reflect.StructField, bool)-
type:func(func(string) bool) (reflect.StructField, bool) <UsedInIface> -> type:.namedata.*func(func(string) bool) (reflect.StructField, bool)-
type:func(func(string) bool) (reflect.StructField, bool) <UsedInIface> -> type:func(string) bool <UsedInIface>
type:func(string) bool <UsedInIface> -> type:.namedata.*func(string) bool-
type:func(int) reflect.Type <UsedInIface> -> type:.namedata.*func(int) reflect.Type-
type:func() reflect.Kind <UsedInIface> -> type:.namedata.*func() reflect.Kind-
type:[]reflect.Value <UsedInIface> -> type:.namedata.*[]reflect.Value-
type:func([]reflect.Value) []reflect.Value <UsedInIface> -> type:.namedata.*func([]reflect.Value) []reflect.Value-
type:func() interface {} <UsedInIface> -> type:.namedata.*func() interface {}-
type:func() uintptr <UsedInIface> -> type:.namedata.*func() uintptr-
type:func() *internal/abi.Type <UsedInIface> -> type:.namedata.*func() *abi.Type-
type:func(int) reflect.Method <UsedInIface> -> type:.namedata.*func(int) reflect.Method-
type:func(int) reflect.Method <UsedInIface> -> type:reflect.Method <UsedInIface>
type:reflect.Method <UsedInIface> -> type:.eqfunc.reflect.Method
type:reflect.Method <UsedInIface> -> runtime.gcbits.e500000000000000
type:reflect.Method <UsedInIface> -> type:.namedata.*reflect.Method.
type:reflect.Method <UsedInIface> -> type:*reflect.Method <UsedInIface>
type:.eqfunc.reflect.Method -> type:.eq.reflect.Method
 -> go:info.*reflect.Method
type:func(string) (reflect.Method, bool) <UsedInIface> -> type:.namedata.*func(string) (reflect.Method, bool)-
type:func() *internal/abi.UncommonType <UsedInIface> -> type:.namedata.*func() *abi.UncommonType-
type:[]internal/abi.Method -> type:.namedata.*[]abi.Method-
go:info.internal/abi.(*IntArgRegBitmap).Set$abstract -> go:info.*internal/abi.IntArgRegBitmap
go:info.internal/abi.(*StructField).Embedded$abstract -> go:info.*internal/abi.StructField
go:info.reflect.(*hiter).initialized$abstract -> go:info.*reflect.hiter
go:info.sync/atomic.(*Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]).Store$abstract -> go:info.*sync/atomic.Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]
go:info.sync/atomic.(*Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]).Store$abstract -> go:info.*go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }
go:info.sync/atomic.(*Pointer[go.shape.interface {}]).CompareAndSwap$abstract -> go:info.*sync/atomic.Pointer[go.shape.interface {}]
go:info.sync/atomic.(*Pointer[go.shape.interface {}]).CompareAndSwap$abstract -> go:info.*go.shape.interface {}
type:.eqfunc.reflect.ValueError -> type:.eq.reflect.ValueError
 -> go:info.*reflect.ValueError
type:[]reflect.abiStep <UsedInIface> -> type:.namedata.*[]reflect.abiStep-
type:[]reflect.abiStep <UsedInIface> -> type:reflect.abiStep <UsedInIface>
type:reflect.abiStep <UsedInIface> -> type:*reflect.abiStep <UsedInIface>
type:reflect.abiStep <UsedInIface> -> type:reflect.abiStepKind <UsedInIface>
type:reflect.abiStepKind <UsedInIface> -> type:*reflect.abiStepKind <UsedInIface>
type:.eqfunc.reflect.makeFuncCtxt -> type:.eq.reflect.makeFuncCtxt
 -> go:info.*reflect.makeFuncCtxt
type:.eqfunc.reflect.methodValue -> type:.eq.reflect.methodValue
type:[]reflect.Type <UsedInIface> -> type:.namedata.*[]reflect.Type-
type:[5]uintptr -> type:.namedata.*[5]uintptr-
type:map[interface {}]*sync.entry -> type:.namedata.*map[interface {}]*sync.entry-
type:map[interface {}]*sync.entry -> type:noalg.map.bucket[interface {}]*sync.entry
type:map[interface {}]*sync.entry -> runtime.nilinterhash·f
type:noalg.map.bucket[interface {}]*sync.entry -> runtime.gcbits.5455ff0300000000
type:noalg.map.bucket[interface {}]*sync.entry -> type:.namedata.*map.bucket[interface {}]*sync.entry-
type:noalg.map.bucket[interface {}]*sync.entry -> type:noalg.[8]interface {}
type:noalg.map.bucket[interface {}]*sync.entry -> type:noalg.[8]*sync.entry
type:noalg.[8]interface {} -> runtime.gcbits.aaaa000000000000
type:noalg.[8]interface {} -> type:.namedata.*[8]interface {}-
type:noalg.[8]interface {} -> type:[]interface {}
type:noalg.[8]*sync.entry -> type:.namedata.*[8]*sync.entry-
type:noalg.[8]*sync.entry -> type:[]*sync.entry
type:[]*sync.entry -> type:.namedata.*[]*sync.entry-
runtime.nilinterhash·f -> runtime.nilinterhash
runtime.nilinterhash -> runtime.typehash
runtime.nilinterhash -> go:string."hash of unhashable type "
runtime.typehash -> runtime.typehash.jump14
runtime.typehash -> runtime.f32hash
runtime.typehash -> runtime.f64hash
runtime.typehash -> runtime.c64hash
runtime.typehash -> runtime.c128hash
runtime.typehash -> runtime.interhash
runtime.typehash -> internal/abi.Name.IsBlank
runtime.typehash -> gclocals·wfM1gsD/oVI7myY6tqtXpg==
runtime.typehash -> gclocals·gfTQPta6IFvmtuaX/g8AkQ==
runtime.typehash -> reflect.Select.argliveinfo
 -> go:info.*[2]float32
 -> go:info.*[2]float64
 -> go:info.*runtime.iface
 -> go:info.*runtime.eface
type:sync/atomic.Pointer[interface {}] -> type:.eqfunc.sync/atomic.Pointer[interface {}]
type:sync/atomic.Pointer[interface {}] -> type:.namedata.*atomic.Pointer[interface {}].
type:sync/atomic.Pointer[interface {}] -> type:*sync/atomic.Pointer[interface {}]
type:sync/atomic.Pointer[interface {}] -> type:.importpath.sync/atomic.
type:sync/atomic.Pointer[interface {}] -> type:[0]*interface {}
type:sync/atomic.Pointer[interface {}] -> type:sync/atomic.noCopy
type:sync/atomic.Pointer[interface {}] -> type:.namedata.v-
type:sync/atomic.noCopy -> type:*sync/atomic.noCopy
type:[0]*interface {} -> type:.namedata.*[0]*interface {}-
type:[0]*interface {} -> type:*interface {}
type:[0]*interface {} -> type:[]*interface {}
type:[]*interface {} -> type:.namedata.*[]*interface {}-
type:.eqfunc.sync/atomic.Pointer[interface {}] -> type:.eq.sync/atomic.Pointer[interface {}]
type:.eq.sync/atomic.Pointer[interface {}] -> sync/atomic.(*Pointer[go.shape.interface {}]).Load.arginfo1
 -> go:info.*sync/atomic.Pointer[interface {}]
type:[1]unsafe.Pointer <UsedInIface> -> type:.namedata.*[1]unsafe.Pointer-
type:[]internal/abi.StructField <UsedInIface> -> type:.namedata.*[]abi.StructField-
type:[]internal/abi.StructField <UsedInIface> -> type:internal/abi.StructField <UsedInIface>
type:internal/abi.StructField <UsedInIface> -> type:*internal/abi.StructField <UsedInIface>
type:map[string]struct {} -> type:.namedata.*map[string]struct {}-
type:map[string]struct {} -> type:noalg.map.bucket[string]struct {}
type:noalg.map.bucket[string]struct {} -> type:.namedata.*map.bucket[string]struct {}-
type:noalg.struct { F uintptr; reflect.ifield int; reflect.imethod int } -> type:.namedata.*struct { F uintptr; ifield int; imethod int }-
type:noalg.struct { F uintptr; reflect.ifield int; reflect.imethod int } -> type:.namedata.ifield-
type:noalg.struct { F uintptr; reflect.ifield int; reflect.imethod int } -> type:.namedata.imethod-
type:noalg.struct { F uintptr; reflect.length int; reflect.esize uintptr; reflect.eequal func(unsafe.Pointer, unsafe.Pointer) bool } -> type:.namedata.*struct { F uintptr; length int; esize uintptr; eequal func(unsafe.Pointer, unsafe.Pointer) bool }-
type:noalg.struct { F uintptr; reflect.length int; reflect.esize uintptr; reflect.eequal func(unsafe.Pointer, unsafe.Pointer) bool } -> type:.namedata.length-
type:noalg.struct { F uintptr; reflect.length int; reflect.esize uintptr; reflect.eequal func(unsafe.Pointer, unsafe.Pointer) bool } -> type:.namedata.esize-
type:noalg.struct { F uintptr; reflect.length int; reflect.esize uintptr; reflect.eequal func(unsafe.Pointer, unsafe.Pointer) bool } -> type:.namedata.eequal-
type:noalg.struct { F uintptr; reflect.typ *reflect.structType } -> type:.namedata.*struct { F uintptr; typ *reflect.structType }-
type:noalg.struct { F uintptr; reflect.x *internal/abi.Type } -> type:.namedata.*struct { F uintptr; x *abi.Type }-
reflect.makeFuncStub -> runtime.spillArgs
reflect.makeFuncStub -> reflect.moveMakeFuncArgPtrs
reflect.makeFuncStub -> reflect.callReflect
reflect.makeFuncStub -> runtime.unspillArgs
reflect.makeFuncStub -> reflect.makeFuncStub.args_stackmap
reflect.makeFuncStub -> reflect.makeFuncStub.arginfo0
reflect.makeFuncStub -> go:sehuw.12.ARICBRIDD1AAAAAA
reflect.moveMakeFuncArgPtrs -> reflect.moveMakeFuncArgPtrs
 -> go:info.internal/abi.(*IntArgRegBitmap).Get$abstract
reflect.callReflect -> reflect.callReflect
reflect.callReflect -> gclocals·br8UsANEGWp75kzr7DNKRQ==
reflect.callReflect -> go:sehuw.12.ARICBRIDD1AAAAAA
reflect.callReflect -> type:*reflect.makeFuncImpl <UsedInIface>
reflect.callReflect -> go:string."reflect.MakeFunc"
reflect.callReflect -> reflect.funcName
reflect.callReflect -> go:string." returned value obtained from unexported field"
reflect.callReflect -> go:string."reflect: function created by MakeFunc using "
reflect.callReflect -> go:string." returned zero Value"
reflect.callReflect -> reflect..stmp_74
reflect.callReflect -> gclocals·VsdoPpkc5DjlO8gp3pbjvw==
reflect.callReflect -> gclocals·qSwQFPRYzOTdY9xBLNbwQg==
reflect.callReflect -> reflect.callReflect.stkobj
reflect.funcName -> runtime.FuncForPC
reflect.funcName -> runtime.(*Func).Name
reflect.funcName -> go:string."closure"
type:*reflect.makeFuncImpl <UsedInIface> -> type:reflect.makeFuncImpl <UsedInIface>
type:reflect.makeFuncImpl <UsedInIface> -> type:reflect.makeFuncCtxt <UsedInIface>
type:reflect.makeFuncCtxt <UsedInIface> -> type:*reflect.makeFuncCtxt <UsedInIface>
runtime.FuncForPC -> type:runtime.funcinl
runtime.FuncForPC -> gclocals·M5gL/1F/vWBBJ1PzOTgzaA==
type:runtime.funcinl -> type:.eqfunc.runtime.funcinl
type:runtime.funcinl -> runtime.gcbits.1400000000000000
type:runtime.funcinl -> type:.namedata.*runtime.funcinl-
type:runtime.funcinl -> type:*runtime.funcinl
type:runtime.funcinl -> type:.namedata.ones-
type:runtime.funcinl -> type:.namedata.file-
type:runtime.funcinl -> type:.namedata.line-
 -> go:info.runtime.(*inlineUnwinder).isInlined$abstract
 -> go:info.runtime.(*Func).funcInfo$abstract
reflect..stmp_74 -> go:string."reflect: wrong return count from function created by MakeFunc"
reflect.methodValueCall -> reflect.callMethod
reflect.methodValueCall -> reflect.methodValueCall.args_stackmap
reflect.methodValueCall -> reflect.methodValueCall.arginfo0
reflect.callMethod -> reflect.callMethod
reflect.callMethod -> type:*reflect.methodValue <UsedInIface>
reflect.callMethod -> go:string."call"
reflect.callMethod -> reflect..stmp_86
reflect.callMethod -> reflect..stmp_87
reflect.callMethod -> reflect..stmp_81
reflect.callMethod -> reflect..stmp_84
reflect.callMethod -> gclocals·DaWUIiwQKc54MZvP96jE8Q==
reflect.callMethod -> gclocals·5o/5ewOZIpoVcbtbv4WFcQ==
reflect.callMethod -> reflect.callMethod.stkobj
type:*reflect.methodValue <UsedInIface> -> type:reflect.methodValue <UsedInIface>
reflect..stmp_81 -> go:string."method ABI and value ABI do not align"
reflect..stmp_84 -> go:string."unexpected method step"
reflect..stmp_86 -> go:string."unexpected value step"
reflect..stmp_87 -> go:string."method ABI and value ABI don't align"
strconv..stmp_12 -> go:string."strconv: illegal AppendFloat/FormatFloat bitSize"
strconv..stmp_13 -> go:string."ryuFtoaFixed32 called with negative prec"
strconv..stmp_14 -> go:string."ryuFtoaFixed32 called with prec > 9"
strconv..stmp_15 -> go:string."not enough significant bits after mult64bitPow10"
strconv..stmp_16 -> go:string."ryuFtoaFixed64 called with prec > 18"
strconv..stmp_17 -> go:string."not enough significant bits after mult128bitPow10"
strconv..stmp_19 -> go:string."mult64bitPow10: power of 10 is out of range"
strconv..stmp_20 -> go:string."mult128bitPow10: power of 10 is out of range"
strconv..stmp_21 -> go:string."strconv: illegal AppendInt/FormatInt base"
go:itab.*internal/fmtsort.SortedMap,sort.Interface -> type:sort.Interface
type:sort.Interface -> type:.namedata.*sort.Interface.
type:sort.Interface -> type:*sort.Interface
type:sort.Interface -> type:.importpath.sort.
type:sort.Interface -> type:func(int, int) bool <UsedInIface>
type:sort.Interface -> type:func(int, int) <UsedInIface>
type:func(int, int) <UsedInIface> -> type:.namedata.*func(int, int)-
type:func(int, int) bool <UsedInIface> -> type:.namedata.*func(int, int) bool-
internal/fmtsort.Sort.stkobj -> runtime.gcbits.fb07000000000000
type:.eqfunc.os.dirInfo -> type:.eq.os.dirInfo
 -> go:info.*os.dirInfo
go:info.sync.(*Map).loadReadOnly$abstract -> go:info.*sync.readOnly
go:info.sync.storePoolChainElt$abstract -> go:info.**sync.poolChainElt
type:.eqfunc.sync.entry -> type:.eq.sync.entry
type:[]sync.eface -> type:.namedata.*[]sync.eface-
type:.eqfunc.sync.poolLocalInternal -> type:.eq.sync.poolLocalInternal
 -> go:info.*sync.poolLocalInternal
type:[96]uint8 -> type:.eqfunc96
type:[96]uint8 -> type:.namedata.*[96]uint8-
type:.eqfunc.sync.poolLocal -> type:.eq.sync.poolLocal
type:.eqfunc.internal/abi.UncommonType -> type:.eq.internal/abi.UncommonType
runtime.cmpstring -> cmpbody
runtime.concatstring5.stkobj -> runtime.gcbits.5501000000000000
sync/atomic.StorePointer -> sync/atomic.StoreUintptr
sync/atomic.SwapPointer -> sync/atomic.SwapUintptr
sync/atomic.CompareAndSwapPointer -> sync/atomic.CompareAndSwapUintptr
sync/atomic.CompareAndSwapPointer -> gclocals·ZANNc5cJ/YVB+sVbKHvwQg==
sync/atomic.CompareAndSwapPointer -> gclocals·tuoT4+9Wx7kzJcLjAMp1xA==
reflect.ifaceE2I -> gclocals·HTvlYfAde7sVOfmSdKDj5w==
reflect.ifaceE2I -> fmt.(*ss).convertFloat.arginfo1
reflect.ifaceE2I -> reflect.ifaceE2I.argliveinfo
 -> go:info.reflect.typedmemmove$abstract
 -> go:info.runtime.procPin$abstract
 -> go:info.runtime.procUnpin$abstract
reflect.typelinks -> type:[1][]int32
reflect.typelinks -> gclocals·eQiX0Y4Q/iY/mdfPEQdk+w==
reflect.addReflectOff -> type:map[unsafe.Pointer]int32
reflect.addReflectOff -> runtime.mapaccess2_fast64
reflect.addReflectOff -> runtime.mapassign_fast64ptr
runtime.mapassign_fast64ptr -> runtime.growWork_fast64
runtime.mapassign_fast64ptr -> gclocals·zfYCW1nhxEKRQBaE7Wlk4A==
runtime.mapassign_fast64ptr -> runtime.mapassign_fast32ptr.stkobj
runtime.growWork_fast64 -> runtime.evacuate_fast64
runtime.reflectcall -> runtime.reflectcall
runtime.reflectcall -> gclocals·q6+J+w85bFSUcmRTeNlJUg==
runtime.reflectcall -> runtime.reflectcall.arginfo1
type:[1]uint8 -> type:.namedata.*[1]uint8-
type:.eqfunc.runtime._func -> type:.eq.runtime._func
type:.eqfunc.runtime.Frame -> type:.eq.runtime.Frame
 -> go:info.*runtime.Frame
type:[]runtime.Frame -> type:.namedata.*[]runtime.Frame-
type:[2]runtime.Frame -> type:.eqfunc.[2]runtime.Frame
type:[2]runtime.Frame -> runtime.gcbits.16b0000000000000
type:[2]runtime.Frame -> type:.namedata.*[2]runtime.Frame-
type:.eqfunc.[2]runtime.Frame -> type:.eq.[2]runtime.Frame
 -> go:info.*[2]runtime.Frame
type:.eqfunc.runtime.funcinl -> type:.eq.runtime.funcinl
type:[]uint16 <UsedInIface> -> type:.namedata.*[]uint16-
type:[1][]int32 -> type:.namedata.*[1][]int32-
type:[1][]int32 -> type:[][]int32
type:[][]int32 -> type:.namedata.*[][]int32-
type:[]interface {} -> type:.namedata.*[]interface {}-
type:map[unsafe.Pointer]int32 -> type:.namedata.*map[unsafe.Pointer]int32-
type:map[unsafe.Pointer]int32 -> type:noalg.map.bucket[unsafe.Pointer]int32
type:map[unsafe.Pointer]int32 -> runtime.memhash64·f
type:noalg.map.bucket[unsafe.Pointer]int32 -> runtime.gcbits.fe21000000000000
type:noalg.map.bucket[unsafe.Pointer]int32 -> type:.namedata.*map.bucket[unsafe.Pointer]int32-
runtime.(*scavengerState).init.func1·f -> runtime.(*scavengerState).init.func1
runtime.(*scavengerState).init.func2·f -> runtime.(*scavengerState).init.func2
runtime.(*scavengerState).init.func3·f -> runtime.(*scavengerState).init.func3
runtime.(*scavengerState).init.func4·f -> runtime.(*scavengerState).init.func4
runtime.badunlockosthread·f -> runtime.badunlockosthread
runtime.badunlockosthread -> go:string."runtime: internal error: misuse of lockOSThread/unlockOSThread"
runtime.chanparkcommit·f -> runtime.chanparkcommit
runtime.main.func1·f -> runtime.main.func1
runtime.main.func1 -> runtime.sysmon·f
runtime.runExitHooks.func1·f -> runtime.runExitHooks.func1
runtime.runExitHooks.func1 -> runtime.runExitHooks.func1.1
runtime.runExitHooks.func1 -> gclocals·wdmTuppZUxZYftR7OCq88Q==
runtime.runExitHooks.func1 -> sync.(*Map).CompareAndSwap.opendefer
runtime.startTheWorld.func1·f -> runtime.startTheWorld.func1
runtime.sysmon·f -> runtime.sysmon
runtime.sysmon -> runtime.sysmon.func1
runtime.sysmon -> runtime.retake
runtime.sysmon -> runtime.forcegc
 -> go:info.runtime.forcegcstate
runtime.templateThread·f -> runtime.templateThread
runtime.spillArgs -> runtime.spillArgs.args_stackmap
runtime.spillArgs -> runtime.spillArgs.arginfo0
runtime.unspillArgs -> runtime.unspillArgs.args_stackmap
runtime.unspillArgs -> runtime.unspillArgs.arginfo0
runtime.reflectcall -> runtime.call16
runtime.reflectcall -> runtime.call32
runtime.reflectcall -> runtime.call64
runtime.reflectcall -> runtime.call128
runtime.reflectcall -> runtime.call256
runtime.reflectcall -> runtime.call512
runtime.reflectcall -> runtime.call1024
runtime.reflectcall -> runtime.call2048
runtime.reflectcall -> runtime.call4096
runtime.reflectcall -> runtime.call8192
runtime.reflectcall -> runtime.call16384
runtime.reflectcall -> runtime.call32768
runtime.reflectcall -> runtime.call65536
runtime.reflectcall -> runtime.call131072
runtime.reflectcall -> runtime.call262144
runtime.reflectcall -> runtime.call524288
runtime.reflectcall -> runtime.call1048576
runtime.reflectcall -> runtime.call2097152
runtime.reflectcall -> runtime.call4194304
runtime.reflectcall -> runtime.call8388608
runtime.reflectcall -> runtime.call16777216
runtime.reflectcall -> runtime.call33554432
runtime.reflectcall -> runtime.call67108864
runtime.reflectcall -> runtime.call134217728
runtime.reflectcall -> runtime.call268435456
runtime.reflectcall -> runtime.call536870912
runtime.reflectcall -> runtime.call1073741824
runtime.reflectcall -> runtime.badreflectcall
runtime.reflectcall -> runtime.reflectcall.args_stackmap
runtime.reflectcall -> runtime.reflectcall.arginfo0
runtime.badreflectcall -> runtime.badreflectcall
runtime.badreflectcall -> runtime..stmp_117
runtime..stmp_117 -> go:string."arg size to reflect.call more than 1GB"
runtime.call16 -> callRet
runtime.call16 -> runtime.call16.args_stackmap
runtime.call16 -> runtime.call16.arginfo0
runtime.call16 -> go:sehuw.12.ARgCBRgDFVAAAAAA
callRet -> runtime.reflectcallmove
runtime.reflectcallmove -> runtime.reflectcallmove
runtime.reflectcallmove -> gclocals·+Pa54BXDTbaf5Zry1YmUeA==
runtime.reflectcallmove -> gclocals·xXgYqS+aH7A9q33Q83oSxA==
runtime.reflectcallmove -> runtime.reflectcallmove.argliveinfo
runtime.call32 -> runtime.call32.args_stackmap
runtime.call32 -> runtime.call32.arginfo0
runtime.call64 -> runtime.call64.args_stackmap
runtime.call64 -> runtime.call64.arginfo0
runtime.call128 -> runtime.call128.args_stackmap
runtime.call128 -> runtime.call128.arginfo0
runtime.call128 -> go:sehuw.12.ASECBSEDHlAAAAAA
runtime.call256 -> runtime.call256.args_stackmap
runtime.call256 -> runtime.call256.arginfo0
runtime.call512 -> runtime.call512.args_stackmap
runtime.call512 -> runtime.call512.arginfo0
runtime.call1024 -> runtime.call1024.args_stackmap
runtime.call1024 -> runtime.call1024.arginfo0
runtime.call2048 -> runtime.call2048.args_stackmap
runtime.call2048 -> runtime.call2048.arginfo0
runtime.call4096 -> runtime.call4096.args_stackmap
runtime.call4096 -> runtime.call4096.arginfo0
runtime.call4096 -> go:sehuw.12.ASwCBSwDKVAAAAAA
runtime.call8192 -> runtime.call8192.args_stackmap
runtime.call8192 -> runtime.call8192.arginfo0
runtime.call16384 -> runtime.call16384.args_stackmap
runtime.call16384 -> runtime.call16384.arginfo0
runtime.call32768 -> runtime.call32768.args_stackmap
runtime.call32768 -> runtime.call32768.arginfo0
runtime.call65536 -> runtime.call65536.args_stackmap
runtime.call65536 -> runtime.call65536.arginfo0
runtime.call131072 -> runtime.call131072.args_stackmap
runtime.call131072 -> runtime.call131072.arginfo0
runtime.call262144 -> runtime.call262144.args_stackmap
runtime.call262144 -> runtime.call262144.arginfo0
runtime.call524288 -> runtime.call524288.args_stackmap
runtime.call524288 -> runtime.call524288.arginfo0
runtime.call1048576 -> runtime.call1048576.args_stackmap
runtime.call1048576 -> runtime.call1048576.arginfo0
runtime.call2097152 -> runtime.call2097152.args_stackmap
runtime.call2097152 -> runtime.call2097152.arginfo0
runtime.call4194304 -> runtime.call4194304.args_stackmap
runtime.call4194304 -> runtime.call4194304.arginfo0
runtime.call8388608 -> runtime.call8388608.args_stackmap
runtime.call8388608 -> runtime.call8388608.arginfo0
runtime.call16777216 -> runtime.call16777216.args_stackmap
runtime.call16777216 -> runtime.call16777216.arginfo0
runtime.call33554432 -> runtime.call33554432.args_stackmap
runtime.call33554432 -> runtime.call33554432.arginfo0
runtime.call67108864 -> runtime.call67108864.args_stackmap
runtime.call67108864 -> runtime.call67108864.arginfo0
runtime.call134217728 -> runtime.call134217728.args_stackmap
runtime.call134217728 -> runtime.call134217728.arginfo0
runtime.call268435456 -> runtime.call268435456.args_stackmap
runtime.call268435456 -> runtime.call268435456.arginfo0
runtime.call536870912 -> runtime.call536870912.args_stackmap
runtime.call536870912 -> runtime.call536870912.arginfo0
runtime.call1073741824 -> runtime.call1073741824.args_stackmap
runtime.call1073741824 -> runtime.call1073741824.arginfo0
runtime.asmstdcall -> go:sehuw.12.AQQCBQQDAVAAAAAA
runtime.exceptiontramp -> sigtramp
sigtramp -> runtime.sigtrampgo
runtime.sigtrampgo -> runtime.exceptionhandler·f
runtime.sigtrampgo -> runtime.firstcontinuehandler·f
runtime.sigtrampgo -> runtime.lastcontinuehandler·f
runtime.sigtrampgo -> runtime.sigtrampgo.func1
runtime.sigtrampgo -> runtime.sigresume
runtime.sigtrampgo -> go:string."unknown sigtramp callback"
runtime.sigtrampgo -> gclocals·6jEObZqzcO+E1QwmVF75Ug==
runtime.sigtrampgo -> runtime.sigtrampgo.stkobj
 -> go:info.*runtime.exceptionpointers
 -> go:info.func(*runtime.exceptionrecord, *runtime.context, *runtime.g) int32
 -> go:info.runtime.sigFetchG$abstract
 -> go:info.runtime.prepareContextForSigResume$abstract
runtime.exceptionhandler·f -> runtime.exceptionhandler
runtime.exceptionhandler -> runtime.isAbortPC
runtime.exceptionhandler -> runtime.winthrow
runtime.exceptionhandler -> runtime.sigpanic0
runtime.winthrow -> go:string."Exception "
runtime.winthrow -> go:string."PC="
runtime.winthrow -> go:string."signal arrived during external code execution\n"
runtime.winthrow -> runtime.tracebacktrap
runtime.winthrow -> runtime.dumpregs
runtime.winthrow -> gclocals·6Rx4Ib8uXJH2JL3Tf9RcyQ==
runtime.winthrow -> gclocals·zr2pY9DbFQVHujFxmt/bIA==
runtime.dumpregs -> go:string."rax     "
runtime.dumpregs -> go:string."rbx     "
runtime.dumpregs -> go:string."rcx     "
runtime.dumpregs -> go:string."rdi     "
runtime.dumpregs -> go:string."rsi     "
runtime.dumpregs -> go:string."rbp     "
runtime.dumpregs -> go:string."rsp     "
runtime.dumpregs -> go:string."r8      "
runtime.dumpregs -> go:string."r9      "
runtime.dumpregs -> go:string."r10     "
runtime.dumpregs -> go:string."r11     "
runtime.dumpregs -> go:string."r12     "
runtime.dumpregs -> go:string."r13     "
runtime.dumpregs -> go:string."r14     "
runtime.dumpregs -> go:string."r15     "
runtime.dumpregs -> go:string."rip     "
runtime.dumpregs -> go:string."rflags  "
runtime.dumpregs -> go:string."cs      "
runtime.dumpregs -> go:string."fs      "
runtime.dumpregs -> go:string."gs      "
 -> go:info.runtime.isgoexception$abstract
 -> go:info.runtime.isAbort$abstract
runtime.firstcontinuehandler·f -> runtime.firstcontinuehandler
runtime.firstcontinuehandler -> gclocals·h5TeRCfA0CQRLwP2ec/ZlA==
runtime.lastcontinuehandler·f -> runtime.lastcontinuehandler
runtime.sigpanic0 -> runtime.sigpanic
runtime.sigpanic0 -> runtime.sigpanic0.args_stackmap
runtime.sigpanic0 -> runtime.sigpanic0.arginfo0
runtime.sigpanic -> runtime.canpanic
runtime.sigpanic -> runtime.inUserArenaChunk
runtime.sigpanic -> go:string."accessed data from freed user arena "
runtime.sigpanic -> go:string."fault"
runtime.sigpanic -> go:string."unexpected fault address "
runtime.sigpanic -> go:string."invalid memory address or nil pointer dereference"
runtime.sigpanic -> type:runtime.errorAddressString <UsedInIface>
runtime.sigpanic -> runtime.memoryError
runtime.sigpanic -> go:string."floating point error"
runtime.sigpanic -> runtime.floatError
runtime.sigpanic -> go:string."integer overflow"
runtime.sigpanic -> runtime.overflowError
runtime.sigpanic -> go:string."unexpected signal during runtime execution"
runtime.overflowError -> runtime..stmp_57
runtime.floatError -> runtime..stmp_58
runtime.memoryError -> runtime..stmp_59
type:runtime.errorAddressString <UsedInIface> -> type:.eqfunc.runtime.errorAddressString
type:runtime.errorAddressString <UsedInIface> -> type:.namedata.*runtime.errorAddressString-
type:runtime.errorAddressString <UsedInIface> -> type:*runtime.errorAddressString <UsedInIface>
 -> go:info.runtime.panicmemAddr$abstract
 -> go:info.runtime.panicmem$abstract
 -> go:info.runtime.panicfloat$abstract
 -> go:info.runtime.panicoverflow$abstract
type:.eqfunc.runtime.errorAddressString -> type:.eq.runtime.errorAddressString
 -> go:info.*runtime.errorAddressString
runtime.switchtothread -> runtime._SwitchToThread
runtime.nanotime1 -> runtime.nanotimeQPC
runtime.nanotimeQPC -> runtime.nanotimeQPC
 -> go:info.runtime.nanotimeQPC$abstract
runtime.wintls -> runtime._TlsAlloc
time.now -> runtime.nowQPC
runtime.nowQPC -> runtime.nowQPC
runtime.callbackasm -> runtime.callbackasm1
runtime.callbackasm1 -> runtime.callbackWrap
runtime.callbackasm1 -> runtime.cgocallback
runtime.callbackWrap -> runtime..stmp_144
runtime.callbackWrap -> gclocals·OIBmdWeQmKi9aTQTT348NQ==
runtime.callbackWrap -> runtime.runfinq.stkobj
 -> go:info.*runtime.callbackArgs
runtime..stmp_144 -> go:string."bad ABI description"
runtime.cgocallback -> zeroTLS
runtime.cgocallback -> runtime.needAndBindM
runtime.cgocallback -> runtime.cgocallbackg
runtime.cgocallback -> runtime.dropm
runtime.cgocallback -> runtime.cgocallback.args_stackmap
runtime.cgocallback -> runtime.cgocallback.arginfo0
runtime.needAndBindM -> runtime.needm
runtime.needAndBindM -> runtime.cgoBindM
runtime.needm -> go:string."fatal error: cgo callback before cgo call\n"
runtime.needm -> runtime.getExtraM
runtime.needm -> runtime.osSetupTLS
runtime.needm -> runtime.setg
runtime.needm -> _cgo_getstackbound
runtime.cgoBindM -> go:string."bindm in unexpected GOOS"
runtime.cgoBindM -> go:string."the current g is not g0"
runtime.cgoBindM -> _cgo_bindm
 -> go:info.runtime.sigset
 -> go:info.[2]uintptr
runtime.cgocallbackg -> runtime.cgocallbackg
runtime.cgocallbackg -> go:string."runtime: bad g in cgocallback\n"
runtime.cgocallbackg -> runtime.cgocallbackg1
runtime.cgocallbackg -> go:string."m changed unexpectedly in cgocallbackg"
runtime.cgocallbackg -> gclocals·Vr0xErvbsTR8FBlPvhId3g==
runtime.cgocallbackg -> gclocals·7CEhFp8MWU+soS6ntMZsQw==
runtime.cgocallbackg1 -> runtime.unlockOSThread·f
runtime.cgocallbackg1 -> runtime.newextram·f
runtime.cgocallbackg1 -> runtime.cgocallbackg1.func2
runtime.cgocallbackg1 -> runtime.cgocallbackg1.func1·f
runtime.cgocallbackg1 -> runtime.cgocallbackg1.func3
runtime.cgocallbackg1 -> gclocals·7XBZTuTlonMHIcAyzzmwZw==
runtime.cgocallbackg1 -> gclocals·yJFKvupcYL6/XyPFmBnASQ==
runtime.cgocallbackg1 -> runtime.cgocallbackg1.stkobj
runtime.cgocallbackg1 -> runtime.cgocallbackg1.opendefer
runtime.cgocallbackg1.func3 -> runtime.unwindm
runtime.cgocallbackg1.func3 -> runtime.unwindm.wrapinfo
 -> go:info.runtime.libcall
 -> go:info.func(unsafe.Pointer)
runtime.dropm -> runtime.dropm
 -> go:info.runtime.putExtraM$abstract
runtime.cgocallbackg1.func1·f -> runtime.cgocallbackg1.func1
type:.eqfunc.internal/syscall/windows.WSAMsg -> type:.eq.internal/syscall/windows.WSAMsg
 -> go:info.*internal/syscall/windows.WSAMsg
type:func() (unsafe.Pointer, int32, error) <UsedInIface> -> type:.namedata.*func() (unsafe.Pointer, int32, error)-
type:[14]int8 <UsedInIface> -> type:.eqfunc14
type:[14]int8 <UsedInIface> -> type:.namedata.*[14]int8-
type:[14]int8 <UsedInIface> -> type:[]int8 <UsedInIface>
type:[]int8 <UsedInIface> -> type:.namedata.*[]int8-
type:[100]int8 <UsedInIface> -> type:.eqfunc100
type:[100]int8 <UsedInIface> -> type:.namedata.*[100]int8-
type:.eqfunc.syscall.WSABuf -> type:.eq.syscall.WSABuf
 -> go:info.*syscall.WSABuf
type:[]syscall.WSABuf <UsedInIface> -> type:.namedata.*[]syscall.WSABuf-
type:.eqfunc.internal/cpu.option -> type:.eq.internal/cpu.option
 -> go:info.*internal/cpu.option
type:[6]internal/cpu.option -> type:.eqfunc.[6]internal/cpu.option
type:[6]internal/cpu.option -> runtime.gcbits.5555550000000000
type:[6]internal/cpu.option -> type:.namedata.*[6]cpu.option-
type:[6]internal/cpu.option -> type:[]internal/cpu.option
type:[]internal/cpu.option -> type:.namedata.*[]cpu.option-
type:.eqfunc.[6]internal/cpu.option -> type:.eq.[6]internal/cpu.option
 -> go:info.*[6]internal/cpu.option
internal/cpu.cpuid -> internal/cpu.cpuid.args_stackmap
internal/cpu.cpuid -> internal/cpu.cpuid.arginfo0
internal/cpu.xgetbv -> internal/cpu.xgetbv.args_stackmap
internal/cpu.xgetbv -> internal/cpu.xgetbv.arginfo0
internal/cpu.getGOAMD64level -> internal/cpu.getGOAMD64level.args_stackmap
internal/cpu.getGOAMD64level -> internal/cpu.getGOAMD64level.arginfo0
type:.eqfunc.runtime/internal/atomic.Uint64 -> type:.eq.runtime/internal/atomic.Uint64
type:.eqfunc.runtime/internal/atomic.Int64 -> type:.eq.runtime/internal/atomic.Int64
type:.eqfunc.runtime/internal/sys.NotInHeap -> type:.eq.runtime/internal/sys.NotInHeap
 -> go:info.*runtime/internal/sys.NotInHeap
go:main.inittasks -> internal/bytealg..inittask
go:main.inittasks -> internal/syscall/windows/sysdll..inittask
go:main.inittasks -> math..inittask
go:main.inittasks -> runtime..inittask
go:main.inittasks -> errors..inittask
go:main.inittasks -> sync..inittask
go:main.inittasks -> syscall..inittask
go:main.inittasks -> internal/syscall/windows..inittask
go:main.inittasks -> internal/syscall/windows/registry..inittask
go:main.inittasks -> time..inittask
go:main.inittasks -> internal/poll..inittask
go:main.inittasks -> io/fs..inittask
go:main.inittasks -> os..inittask
go:main.inittasks -> unicode..inittask
go:main.inittasks -> reflect..inittask
reflect..inittask -> reflect.init
reflect.init -> reflect..stmp_177
reflect.init -> reflect.stringType
reflect.init -> gclocals·/ydTHfVJHvKeH/UP4dRKSQ==
 -> go:info.reflect.rtypeOf$abstract
errors..inittask -> errors.init
errors.init -> go:itab.internal/reflectlite.rtype,internal/reflectlite.Type
errors.init -> errors.errorType
errors.init -> go:sehuw.12.AQoCBQoDB1AAAAAA
 -> go:info.internal/reflectlite.Type
 -> go:info.internal/reflectlite.TypeOf$abstract
 -> go:info.internal/reflectlite.toType$abstract
os..inittask -> os.init
os..inittask -> os.init.0
os..inittask -> os.init.1
os.init.0 -> syscall.GetCommandLine
os.init.0 -> internal/syscall/windows.UTF16PtrToString
os.init.0 -> os.Executable
os.init.0 -> type:[1]string
os.init.0 -> os.Args
os.init.0 -> os.commandLineToArgv
os.init.0 -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
os.commandLineToArgv -> os.readNextArg
os.commandLineToArgv -> gclocals·lB4PuL+9Eg2CVo4FQwhBQw==
os.Executable -> os.getModuleFileName
os.Executable -> go:sehuw.12.AQoCBQoDB1AAAAAA
os.getModuleFileName -> internal/syscall/windows.GetModuleFileName
os.getModuleFileName -> syscall.UTF16ToString
os.init -> io/fs.ErrInvalid
os.init -> os.ErrInvalid
os.init -> io/fs.ErrPermission
os.init -> os.ErrPermission
os.init -> io/fs.ErrExist
os.init -> os.ErrExist
os.init -> io/fs.ErrNotExist
os.init -> os.ErrNotExist
os.init -> io/fs.ErrClosed
os.init -> os.ErrClosed
os.init -> internal/poll.ErrNoDeadline
os.init -> os.ErrNoDeadline
os.init -> internal/poll.ErrDeadlineExceeded
os.init -> os.ErrDeadlineExceeded
os.init -> syscall.Stdin
os.init -> go:string."/dev/stdin"
os.init -> go:string."file"
os.init -> os.newFile
os.init -> os.Stdin
os.init -> syscall.Stdout
os.init -> go:string."/dev/stdout"
os.init -> syscall.Stderr
os.init -> go:string."/dev/stderr"
os.init -> os.Stderr
os.newFile -> syscall.GetConsoleMode
os.newFile -> syscall.GetFileType
os.newFile -> go:string."console"
os.newFile -> go:string."pipe"
os.newFile -> type:func(*os.file) error <UsedInIface>
os.newFile -> os.(*file).close·f
os.newFile -> runtime.SetFinalizer
os.newFile -> internal/poll.(*FD).Init
os.newFile -> gclocals·OULzmn5fUvXk8b6TMsixrA==
os.newFile -> gclocals·1sIdqCAtRND2ZdttaBcWlA==
 -> go:info.os.appendBSBytes$abstract
 -> go:info.os.executable$abstract
 -> go:info.syscall.Handle
 -> go:info.os.NewFile$abstract
sync..inittask -> sync.init
sync..inittask -> sync.init.0
sync..inittask -> sync.init.1
sync.init.0 -> sync.poolCleanup·f
sync.init.0 -> sync.runtime_registerPoolCleanup
sync.init.1 -> sync.runtime_notifyListCheck
math..inittask -> math.init
math.init -> math.useFMA
internal/bytealg..inittask -> internal/bytealg.init.0
internal/bytealg.init.0 -> internal/bytealg.MaxLen
unicode..inittask -> unicode.init
unicode.init -> go:string."L"
unicode.init -> type:map[string]*unicode.RangeTable
unicode.init -> unicode.foldL
unicode.init -> go:string."Ll"
unicode.init -> unicode.foldLl
unicode.init -> go:string."Lt"
unicode.init -> unicode.foldLt
unicode.init -> go:string."Lu"
unicode.init -> unicode.foldLu
unicode.init -> unicode.foldM
unicode.init -> go:string."Mn"
unicode.init -> unicode.foldMn
unicode.init -> unicode.FoldCategory
unicode.init -> go:string."Common"
unicode.init -> unicode.foldCommon
unicode.init -> go:string."Greek"
unicode.init -> unicode.foldGreek
unicode.init -> go:string."Inherited"
unicode.init -> unicode.foldInherited
unicode.init -> unicode.FoldScript
unicode.init -> gclocals·HDED++1ZcAEHe1hn57Yo0A==
 -> go:info.map[string]*unicode.RangeTable
unicode.foldL -> unicode..stmp_623
unicode.foldLl -> unicode..stmp_625
unicode.foldLt -> unicode..stmp_628
unicode.foldLu -> unicode..stmp_630
unicode.foldM -> unicode..stmp_633
unicode.foldMn -> unicode..stmp_635
unicode.foldCommon -> unicode..stmp_637
unicode.foldGreek -> unicode..stmp_639
unicode.foldInherited -> unicode..stmp_641
unicode..stmp_623 -> unicode..stmp_624
unicode..stmp_625 -> unicode..stmp_626
unicode..stmp_625 -> unicode..stmp_627
unicode..stmp_628 -> unicode..stmp_629
unicode..stmp_630 -> unicode..stmp_631
unicode..stmp_630 -> unicode..stmp_632
unicode..stmp_633 -> unicode..stmp_634
unicode..stmp_635 -> unicode..stmp_636
unicode..stmp_637 -> unicode..stmp_638
unicode..stmp_639 -> unicode..stmp_640
unicode..stmp_641 -> unicode..stmp_642
runtime.SetFinalizer -> runtime.SetFinalizer.jump91
runtime.SetFinalizer -> runtime.SetFinalizer.jump109
runtime.SetFinalizer -> runtime.SetFinalizer.func1
runtime.SetFinalizer -> runtime.createfing
runtime.SetFinalizer -> runtime.SetFinalizer.func2
runtime.SetFinalizer -> go:string." to finalizer "
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: cannot pass "
runtime.SetFinalizer -> go:string." because dotdotdot"
runtime.SetFinalizer -> go:string.", not a function"
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: second argument is "
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: pointer not at beginning of allocated block"
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: pointer not in allocated block"
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: first argument was allocated into an arena"
runtime.SetFinalizer -> go:string."nil elem type!"
runtime.SetFinalizer -> go:string.", not pointer"
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: first argument is "
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: first argument is nil"
runtime.SetFinalizer -> gclocals·sPiy/NR6R8+sHHDr88aLSQ==
runtime.SetFinalizer -> gclocals·PQuuxZIkU8lIJf1xt/boTA==
runtime.SetFinalizer -> runtime.SetFinalizer.stkobj
runtime.SetFinalizer -> reflect.DeepEqual.arginfo1
runtime.createfing -> runtime.runfinq·f
runtime.SetFinalizer.func2 -> runtime.addfinalizer
runtime.SetFinalizer.func2 -> go:string."runtime.SetFinalizer: finalizer already set"
runtime.SetFinalizer.func1 -> runtime.removefinalizer
runtime.addfinalizer -> gclocals·VBaJumnFu59aNGfEoL8NYQ==
runtime.addfinalizer -> gclocals·HsjFlllpLIcdLNjNFrk/qw==
runtime.removefinalizer -> runtime.removespecial
runtime.removespecial -> go:string."removespecial on invalid pointer"
runtime..inittask -> runtime.init
runtime..inittask -> runtime.init.0
runtime..inittask -> runtime.init.1
runtime..inittask -> runtime.init.4
runtime..inittask -> runtime.init.5
runtime..inittask -> runtime.init.6
runtime.init.0 -> go:string."user arena chunk size is not a multiple of the physical page size"
runtime.init.5 -> go:string."runtime: asyncPreemptStack="
runtime.init.5 -> go:string."async stack too large"
runtime.init.6 -> runtime.forcegchelper·f
runtime.init -> $f64.7ff0000000000000
runtime.init -> runtime.inf
runtime.init -> runtime.uint16Eface
runtime.init -> runtime.uint16Type
runtime.init -> runtime.uint32Eface
runtime.init -> runtime.uint64Eface
runtime.init -> runtime.uint64Type
runtime.init -> runtime.stringEface
runtime.init -> runtime.sliceEface
runtime.init -> runtime.pdEface
runtime.init -> runtime.pdType
runtime.init -> runtime.chansendpc
runtime.init -> runtime.chanrecvpc
runtime.uint16Eface -> type:runtime.uint16InterfacePtr <UsedInIface>
runtime.uint16Eface -> runtime..stmp_0
runtime.uint32Eface -> type:runtime.uint32InterfacePtr <UsedInIface>
runtime.uint32Eface -> runtime..stmp_1
runtime.uint64Eface -> type:runtime.uint64InterfacePtr <UsedInIface>
runtime.uint64Eface -> runtime..stmp_2
runtime.stringEface -> type:runtime.stringInterfacePtr <UsedInIface>
runtime.stringEface -> runtime..stmp_3
runtime.sliceEface -> type:runtime.sliceInterfacePtr <UsedInIface>
runtime.sliceEface -> runtime..stmp_4
runtime.pdEface -> type:*runtime.pollDesc <UsedInIface>
runtime.pdEface -> runtime..stmp_54
type:*runtime.pollDesc <UsedInIface> -> type:.namedata.*runtime.pollDesc-
type:*runtime.pollDesc <UsedInIface> -> type:runtime.pollDesc <UsedInIface>
type:*runtime.pollDesc <UsedInIface> -> type:.namedata.info-
type:*runtime.pollDesc <UsedInIface> -> type:.namedata.makeArg-
type:*runtime.pollDesc <UsedInIface> -> type:.namedata.publishInfo-
type:*runtime.pollDesc <UsedInIface> -> type:.namedata.setEventErr-
type:runtime.pollDesc <UsedInIface> -> runtime.gcbits.0050800200000000
type:runtime.pollDesc <UsedInIface> -> type:runtime/internal/sys.NotInHeap <UsedInIface>
type:runtime.pollDesc <UsedInIface> -> type:.namedata.fdseq-
type:runtime.pollDesc <UsedInIface> -> type:runtime/internal/atomic.Uintptr <UsedInIface>
type:runtime.pollDesc <UsedInIface> -> type:.namedata.atomicInfo-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.rg-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.wg-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.closing-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.user-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.rseq-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.rt-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.rd-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.wseq-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.wt-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.wd-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.self-
type:runtime.sliceInterfacePtr <UsedInIface> -> type:.namedata.*runtime.sliceInterfacePtr-
type:runtime.sliceInterfacePtr <UsedInIface> -> type:*runtime.sliceInterfacePtr <UsedInIface>
type:runtime.stringInterfacePtr <UsedInIface> -> type:.namedata.*runtime.stringInterfacePtr-
type:runtime.stringInterfacePtr <UsedInIface> -> type:*runtime.stringInterfacePtr <UsedInIface>
type:runtime.uint16InterfacePtr <UsedInIface> -> type:.namedata.*runtime.uint16InterfacePtr-
type:runtime.uint16InterfacePtr <UsedInIface> -> type:*runtime.uint16InterfacePtr <UsedInIface>
type:runtime.uint32InterfacePtr <UsedInIface> -> type:.namedata.*runtime.uint32InterfacePtr-
type:runtime.uint32InterfacePtr <UsedInIface> -> type:*runtime.uint32InterfacePtr <UsedInIface>
type:runtime.uint64InterfacePtr <UsedInIface> -> type:.namedata.*runtime.uint64InterfacePtr-
type:runtime.uint64InterfacePtr <UsedInIface> -> type:*runtime.uint64InterfacePtr <UsedInIface>
io/fs..inittask -> io/fs.init
io/fs.init -> internal/oserror.ErrInvalid
io/fs.init -> internal/oserror.ErrPermission
io/fs.init -> internal/oserror.ErrExist
io/fs.init -> internal/oserror.ErrNotExist
io/fs.init -> internal/oserror.ErrClosed
io/fs.init -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
internal/syscall/windows.UTF16PtrToString -> go:sehuw.12.AQoCBQoDB1AAAAAA
internal/syscall/windows.GetModuleFileName -> internal/syscall/windows.procGetModuleFileNameW
internal/syscall/windows.GetModuleFileName -> syscall.(*LazyProc).Find
internal/syscall/windows.GetModuleFileName -> syscall.Syscall
internal/syscall/windows.GetModuleFileName -> internal/syscall/windows.errERROR_EINVAL
internal/syscall/windows.GetModuleFileName -> internal/syscall/windows.errERROR_IO_PENDING
internal/syscall/windows.GetModuleFileName -> runtime.convT64
internal/syscall/windows.GetModuleFileName -> go:itab.syscall.Errno,error
internal/syscall/windows.GetModuleFileName -> gclocals·f0GxeGpCpc4Z7VHLawnzvw==
internal/syscall/windows.GetModuleFileName -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
internal/syscall/windows..inittask -> internal/syscall/windows.init
internal/syscall/windows.init -> internal/syscall/windows/sysdll.IsSystemDLL
internal/syscall/windows.init -> go:string."advapi32.dll"
internal/syscall/windows.init -> type:syscall.LazyDLL
internal/syscall/windows.init -> internal/syscall/windows.modadvapi32
internal/syscall/windows.init -> go:string."iphlpapi.dll"
internal/syscall/windows.init -> internal/syscall/windows.modiphlpapi
internal/syscall/windows.init -> go:string."kernel32.dll"
internal/syscall/windows.init -> internal/syscall/windows.modkernel32
internal/syscall/windows.init -> go:string."netapi32.dll"
internal/syscall/windows.init -> internal/syscall/windows.modnetapi32
internal/syscall/windows.init -> go:string."psapi.dll"
internal/syscall/windows.init -> internal/syscall/windows.modpsapi
internal/syscall/windows.init -> go:string."userenv.dll"
internal/syscall/windows.init -> internal/syscall/windows.moduserenv
internal/syscall/windows.init -> go:string."ws2_32.dll"
internal/syscall/windows.init -> internal/syscall/windows.modws2_32
internal/syscall/windows.init -> internal/syscall/windows..stmp_2
internal/syscall/windows.init -> internal/syscall/windows..stmp_3
internal/syscall/windows.init -> internal/syscall/windows..stmp_4
internal/syscall/windows.init -> internal/syscall/windows..stmp_5
internal/syscall/windows.init -> internal/syscall/windows..stmp_6
internal/syscall/windows.init -> internal/syscall/windows..stmp_7
internal/syscall/windows.init -> internal/syscall/windows..stmp_8
internal/syscall/windows.init -> internal/syscall/windows..stmp_9
internal/syscall/windows.init -> internal/syscall/windows..stmp_10
internal/syscall/windows.init -> internal/syscall/windows..stmp_11
internal/syscall/windows.init -> internal/syscall/windows..stmp_12
internal/syscall/windows.init -> internal/syscall/windows..stmp_13
internal/syscall/windows.init -> internal/syscall/windows..stmp_14
internal/syscall/windows.init -> internal/syscall/windows..stmp_15
internal/syscall/windows.init -> internal/syscall/windows..stmp_16
internal/syscall/windows.init -> internal/syscall/windows..stmp_17
internal/syscall/windows.init -> internal/syscall/windows..stmp_18
internal/syscall/windows.init -> internal/syscall/windows..stmp_19
internal/syscall/windows.init -> internal/syscall/windows..stmp_20
internal/syscall/windows.init -> internal/syscall/windows..stmp_21
internal/syscall/windows.init -> internal/syscall/windows..stmp_22
internal/syscall/windows.init -> internal/syscall/windows..stmp_23
internal/syscall/windows.init -> internal/syscall/windows..stmp_24
internal/syscall/windows.init -> internal/syscall/windows..stmp_25
internal/syscall/windows.init -> internal/syscall/windows..stmp_26
internal/syscall/windows.init -> internal/syscall/windows..stmp_27
internal/syscall/windows.init -> internal/syscall/windows..stmp_28
internal/syscall/windows.init -> internal/syscall/windows..stmp_29
internal/syscall/windows.init -> internal/syscall/windows..stmp_30
internal/syscall/windows.init -> internal/syscall/windows..stmp_31
internal/syscall/windows.init -> internal/syscall/windows..stmp_32
internal/syscall/windows.init -> internal/syscall/windows..stmp_33
internal/syscall/windows.init -> internal/syscall/windows..stmp_34
internal/syscall/windows.init -> internal/syscall/windows..stmp_35
internal/syscall/windows.init -> internal/syscall/windows..stmp_36
internal/syscall/windows.init -> internal/syscall/windows..stmp_37
internal/syscall/windows.init -> internal/syscall/windows..stmp_38
internal/syscall/windows.errERROR_IO_PENDING -> internal/syscall/windows..stmp_0
internal/syscall/windows.errERROR_EINVAL -> internal/syscall/windows..stmp_1
 -> go:info.*syscall.LazyDLL
 -> go:info.*syscall.LazyProc
internal/syscall/windows..stmp_2 -> go:string."AdjustTokenPrivileges"
internal/syscall/windows..stmp_3 -> go:string."DuplicateTokenEx"
internal/syscall/windows..stmp_4 -> go:string."ImpersonateSelf"
internal/syscall/windows..stmp_5 -> go:string."LookupPrivilegeValueW"
internal/syscall/windows..stmp_6 -> go:string."OpenThreadToken"
internal/syscall/windows..stmp_7 -> go:string."RevertToSelf"
internal/syscall/windows..stmp_8 -> go:string."SetTokenInformation"
internal/syscall/windows..stmp_9 -> go:string."SystemFunction036"
internal/syscall/windows..stmp_10 -> go:string."GetAdaptersAddresses"
internal/syscall/windows..stmp_11 -> go:string."CreateEventW"
internal/syscall/windows..stmp_12 -> go:string."GetACP"
internal/syscall/windows..stmp_13 -> go:string."GetComputerNameExW"
internal/syscall/windows..stmp_14 -> go:string."GetConsoleCP"
internal/syscall/windows..stmp_15 -> go:string."GetCurrentThread"
internal/syscall/windows..stmp_16 -> go:string."GetFileInformationByHandleEx"
internal/syscall/windows..stmp_17 -> go:string."GetFinalPathNameByHandleW"
internal/syscall/windows..stmp_18 -> go:string."GetModuleFileNameW"
internal/syscall/windows..stmp_19 -> go:string."GetTempPath2W"
internal/syscall/windows..stmp_20 -> go:string."GetVolumeInformationByHandleW"
internal/syscall/windows..stmp_21 -> go:string."LockFileEx"
internal/syscall/windows..stmp_22 -> go:string."Module32FirstW"
internal/syscall/windows..stmp_23 -> go:string."Module32NextW"
internal/syscall/windows..stmp_24 -> go:string."MoveFileExW"
internal/syscall/windows..stmp_25 -> go:string."MultiByteToWideChar"
internal/syscall/windows..stmp_26 -> go:string."RtlLookupFunctionEntry"
internal/syscall/windows..stmp_27 -> go:string."RtlVirtualUnwind"
internal/syscall/windows..stmp_28 -> go:string."SetFileInformationByHandle"
internal/syscall/windows..stmp_29 -> go:string."UnlockFileEx"
internal/syscall/windows..stmp_30 -> go:string."VirtualQuery"
internal/syscall/windows..stmp_31 -> go:string."NetShareAdd"
internal/syscall/windows..stmp_32 -> go:string."NetShareDel"
internal/syscall/windows..stmp_33 -> go:string."NetUserGetLocalGroups"
internal/syscall/windows..stmp_34 -> go:string."GetProcessMemoryInfo"
internal/syscall/windows..stmp_35 -> go:string."CreateEnvironmentBlock"
internal/syscall/windows..stmp_36 -> go:string."DestroyEnvironmentBlock"
internal/syscall/windows..stmp_37 -> go:string."GetProfilesDirectoryW"
internal/syscall/windows..stmp_38 -> go:string."WSASocketW"
 -> go:info.syscall.Errno
 -> go:info.syscall.(*LazyProc).Addr$abstract
 -> go:info.syscall.(*LazyProc).mustFind$abstract
 -> go:info.syscall.(*Proc).Addr$abstract
 -> go:info.internal/syscall/windows.errnoErr$abstract
 -> go:info.internal/syscall/windows/sysdll.Add$abstract
 -> go:info.syscall.NewLazyDLL$abstract
syscall.(*LazyProc).Find -> syscall.(*LazyProc).Find.func1
syscall.(*LazyProc).Find -> syscall.(*LazyDLL).Load
syscall.(*LazyProc).Find -> syscall.(*DLL).FindProc
syscall.(*LazyProc).Find -> gclocals·ojICP8I3CQ4jV7d263PSTQ==
syscall.(*LazyProc).Find -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
syscall.(*DLL).FindProc -> syscall.ByteSliceFromString
syscall.(*DLL).FindProc -> syscall.getprocaddress
syscall.(*DLL).FindProc -> syscall.Errno.Error
syscall.(*DLL).FindProc -> type:syscall.DLLError
syscall.(*DLL).FindProc -> go:string."Failed to find "
syscall.(*DLL).FindProc -> go:string." procedure in "
syscall.(*DLL).FindProc -> go:itab.*syscall.DLLError,error
syscall.(*DLL).FindProc -> type:syscall.Proc
syscall.(*DLL).FindProc -> gclocals·zhHBtK+inPF1jiv0+LUcCA==
syscall.(*DLL).FindProc -> gclocals·nmydgk/BPsSWpRhaWvfy7w==
syscall.(*DLL).FindProc -> runtime.(*TypeAssertionError).Error.stkobj
syscall.(*DLL).FindProc -> go:sehuw.12.ARMCBRMDEFAAAAAA
syscall.(*LazyDLL).Load -> syscall.(*LazyDLL).Load.func1
syscall.(*LazyDLL).Load -> syscall.LoadDLL
syscall.LoadDLL -> syscall.UTF16FromString
syscall.LoadDLL -> syscall.loadsystemlibrary
syscall.LoadDLL -> syscall.loadlibrary
syscall.LoadDLL -> go:string."Failed to load "
syscall.LoadDLL -> type:syscall.DLL
syscall.LoadDLL -> gclocals·vzoPexl5Vwvr6JTs1wqjRQ==
syscall.(*LazyDLL).Load.func1 -> go:sehuw.12.AQoCBQoDB1AAAAAA
syscall.ByteSliceFromString -> os..stmp_7
syscall.UTF16FromString -> syscall.encodeWTF16
syscall.UTF16ToString -> syscall.decodeWTF16
syscall.Errno.Error -> syscall.formatMessage
syscall.Errno.Error -> internal/itoa.Itoa
syscall.Errno.Error -> go:string."winapi error #"
syscall.Errno.Error -> syscall.errors
syscall.Errno.Error -> go:sehuw.12.ARYCBRYDE1AAAAAA
internal/itoa.Itoa -> go:string."0"
internal/itoa.Itoa -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
 -> go:info.internal/itoa.Uitoa$abstract
syscall.encodeWTF16 -> gclocals·vK+vs0a3g9FAwMMfjFVdug==
syscall.formatMessage -> syscall.procFormatMessageW
syscall.formatMessage -> syscall.Syscall9
syscall.formatMessage -> syscall.errERROR_EINVAL
syscall.formatMessage -> syscall.errERROR_IO_PENDING
syscall.formatMessage -> gclocals·VE8Xej8YiufA0YAPer2zgw==
syscall.formatMessage -> gclocals·NOx/+OJJdSd/CQVs7aY5wg==
syscall.formatMessage -> internal/syscall/windows.DuplicateTokenEx.stkobj
syscall.formatMessage -> syscall.formatMessage.arginfo1
syscall.formatMessage -> syscall.formatMessage.argliveinfo
syscall.GetCommandLine -> syscall.procGetCommandLineW
syscall.GetConsoleMode -> syscall.procGetConsoleMode
syscall.GetFileType -> syscall.procGetFileType
type:syscall.DLLError -> type:.eqfunc.syscall.DLLError
type:syscall.DLLError -> type:.namedata.*syscall.DLLError.
type:syscall.DLLError -> type:*syscall.DLLError <UsedInIface>
type:syscall.DLLError -> type:.namedata.Err.
type:syscall.DLLError -> type:.namedata.ObjName.
type:syscall.DLLError -> type:.namedata.Msg.
type:*syscall.DLLError <UsedInIface> -> type:syscall.DLLError <UsedInIface>
type:*syscall.DLLError <UsedInIface> -> type:.namedata.Unwrap.
syscall..inittask -> syscall.init
syscall.init -> syscall.modadvapi32
syscall.init -> go:string."crypt32.dll"
syscall.init -> syscall.modcrypt32
syscall.init -> go:string."dnsapi.dll"
syscall.init -> syscall.moddnsapi
syscall.init -> syscall.modiphlpapi
syscall.init -> syscall.modkernel32
syscall.init -> syscall..stmp_2
syscall.init -> go:string."mswsock.dll"
syscall.init -> syscall.modmswsock
syscall.init -> syscall.modnetapi32
syscall.init -> go:string."ntdll.dll"
syscall.init -> syscall.modntdll
syscall.init -> go:string."secur32.dll"
syscall.init -> syscall.modsecur32
syscall.init -> go:string."shell32.dll"
syscall.init -> syscall.modshell32
syscall.init -> syscall.moduserenv
syscall.init -> syscall.modws2_32
syscall.init -> syscall..stmp_3
syscall.init -> syscall..stmp_4
syscall.init -> syscall..stmp_5
syscall.init -> syscall..stmp_6
syscall.init -> syscall..stmp_7
syscall.init -> syscall..stmp_8
syscall.init -> syscall..stmp_9
syscall.init -> syscall..stmp_10
syscall.init -> syscall..stmp_11
syscall.init -> syscall..stmp_12
syscall.init -> syscall..stmp_13
syscall.init -> syscall..stmp_14
syscall.init -> syscall..stmp_15
syscall.init -> syscall..stmp_16
syscall.init -> syscall..stmp_17
syscall.init -> syscall..stmp_18
syscall.init -> syscall..stmp_19
syscall.init -> syscall..stmp_20
syscall.init -> syscall..stmp_21
syscall.init -> syscall..stmp_22
syscall.init -> syscall..stmp_23
syscall.init -> syscall..stmp_24
syscall.init -> syscall..stmp_25
syscall.init -> syscall..stmp_26
syscall.init -> syscall..stmp_27
syscall.init -> syscall..stmp_28
syscall.init -> syscall..stmp_29
syscall.init -> syscall..stmp_30
syscall.init -> syscall..stmp_31
syscall.init -> syscall..stmp_32
syscall.init -> syscall..stmp_33
syscall.init -> syscall..stmp_34
syscall.init -> syscall..stmp_35
syscall.init -> syscall..stmp_36
syscall.init -> syscall..stmp_37
syscall.init -> syscall..stmp_38
syscall.init -> syscall..stmp_39
syscall.init -> syscall..stmp_40
syscall.init -> syscall..stmp_41
syscall.init -> syscall..stmp_42
syscall.init -> syscall..stmp_43
syscall.init -> syscall..stmp_44
syscall.init -> syscall..stmp_45
syscall.init -> syscall..stmp_46
syscall.init -> syscall..stmp_47
syscall.init -> syscall..stmp_48
syscall.init -> syscall..stmp_49
syscall.init -> syscall..stmp_50
syscall.init -> syscall..stmp_51
syscall.init -> syscall..stmp_52
syscall.init -> syscall..stmp_53
syscall.init -> syscall..stmp_54
syscall.init -> syscall..stmp_55
syscall.init -> syscall..stmp_56
syscall.init -> syscall..stmp_57
syscall.init -> syscall..stmp_58
syscall.init -> syscall..stmp_59
syscall.init -> syscall..stmp_60
syscall.init -> syscall..stmp_61
syscall.init -> syscall..stmp_62
syscall.init -> syscall..stmp_63
syscall.init -> syscall..stmp_64
syscall.init -> syscall..stmp_65
syscall.init -> syscall..stmp_66
syscall.init -> syscall..stmp_67
syscall.init -> syscall..stmp_68
syscall.init -> syscall..stmp_69
syscall.init -> syscall..stmp_70
syscall.init -> syscall..stmp_71
syscall.init -> syscall..stmp_72
syscall.init -> syscall..stmp_73
syscall.init -> syscall..stmp_74
syscall.init -> syscall..stmp_75
syscall.init -> syscall..stmp_76
syscall.init -> syscall..stmp_77
syscall.init -> syscall..stmp_78
syscall.init -> syscall..stmp_79
syscall.init -> syscall..stmp_80
syscall.init -> syscall..stmp_81
syscall.init -> syscall..stmp_82
syscall.init -> syscall.GetStdHandle
syscall.init -> syscall..stmp_83
syscall.init -> syscall..stmp_84
syscall.init -> syscall..stmp_85
syscall.init -> syscall..stmp_86
syscall.init -> syscall..stmp_87
syscall.init -> syscall..stmp_88
syscall.init -> syscall..stmp_89
syscall.init -> syscall..stmp_90
syscall.init -> syscall..stmp_91
syscall.init -> syscall..stmp_92
syscall.init -> syscall..stmp_93
syscall.init -> syscall..stmp_94
syscall.init -> syscall..stmp_95
syscall.init -> syscall..stmp_96
syscall.init -> syscall..stmp_97
syscall.init -> syscall..stmp_98
syscall.init -> syscall..stmp_99
syscall.init -> syscall..stmp_100
syscall.init -> syscall..stmp_101
syscall.init -> syscall..stmp_102
syscall.init -> syscall..stmp_103
syscall.init -> syscall..stmp_104
syscall.init -> syscall..stmp_105
syscall.init -> syscall..stmp_106
syscall.init -> syscall..stmp_107
syscall.init -> syscall..stmp_108
syscall.init -> syscall..stmp_109
syscall.init -> syscall..stmp_110
syscall.init -> syscall..stmp_111
syscall.init -> syscall..stmp_112
syscall.init -> syscall..stmp_113
syscall.init -> syscall..stmp_114
syscall.init -> syscall..stmp_115
syscall.init -> syscall..stmp_116
syscall.init -> syscall..stmp_117
syscall.init -> syscall..stmp_118
syscall.init -> syscall..stmp_119
syscall.init -> syscall..stmp_120
syscall.init -> syscall..stmp_121
syscall.init -> syscall..stmp_122
syscall.init -> syscall..stmp_123
syscall.init -> syscall..stmp_124
syscall.init -> syscall..stmp_125
syscall.init -> syscall..stmp_126
syscall.init -> syscall..stmp_127
syscall.init -> syscall..stmp_128
syscall.init -> syscall..stmp_129
syscall.init -> syscall..stmp_130
syscall.init -> syscall..stmp_131
syscall.init -> syscall..stmp_132
syscall.init -> syscall..stmp_133
syscall.init -> syscall..stmp_134
syscall.init -> syscall..stmp_135
syscall.init -> syscall..stmp_136
syscall.init -> syscall..stmp_137
syscall.init -> syscall..stmp_138
syscall.init -> syscall..stmp_139
syscall.init -> syscall..stmp_140
syscall.init -> syscall..stmp_141
syscall.init -> syscall..stmp_142
syscall.init -> syscall..stmp_143
syscall.init -> syscall..stmp_144
syscall.init -> syscall..stmp_145
syscall.init -> syscall..stmp_146
syscall.init -> syscall..stmp_147
syscall.init -> syscall..stmp_148
syscall.init -> syscall..stmp_149
syscall.init -> syscall..stmp_150
syscall.GetStdHandle -> syscall.procGetStdHandle
syscall.errors -> go:string."argument list too long"
syscall.errors -> go:string."permission denied"
syscall.errors -> go:string."address already in use"
syscall.errors -> go:string."cannot assign requested address"
syscall.errors -> go:string."advertise error"
syscall.errors -> go:string."address family not supported by protocol"
syscall.errors -> go:string."resource temporarily unavailable"
syscall.errors -> go:string."operation already in progress"
syscall.errors -> go:string."invalid exchange"
syscall.errors -> go:string."bad file descriptor"
syscall.errors -> go:string."file descriptor in bad state"
syscall.errors -> go:string."bad message"
syscall.errors -> go:string."invalid request descriptor"
syscall.errors -> go:string."invalid request code"
syscall.errors -> go:string."invalid slot"
syscall.errors -> go:string."bad font file format"
syscall.errors -> go:string."device or resource busy"
syscall.errors -> go:string."operation canceled"
syscall.errors -> go:string."no child processes"
syscall.errors -> go:string."channel number out of range"
syscall.errors -> go:string."communication error on send"
syscall.errors -> go:string."software caused connection abort"
syscall.errors -> go:string."connection refused"
syscall.errors -> go:string."connection reset by peer"
syscall.errors -> go:string."resource deadlock avoided"
syscall.errors -> go:string."destination address required"
syscall.errors -> go:string."numerical argument out of domain"
syscall.errors -> go:string."RFS specific error"
syscall.errors -> go:string."disk quota exceeded"
syscall.errors -> go:string."file exists"
syscall.errors -> go:string."bad address"
syscall.errors -> go:string."file too large"
syscall.errors -> go:string."host is down"
syscall.errors -> go:string."no route to host"
syscall.errors -> go:string."identifier removed"
syscall.errors -> go:string."invalid or incomplete multibyte or wide character"
syscall.errors -> go:string."operation now in progress"
syscall.errors -> go:string."interrupted system call"
syscall.errors -> go:string."invalid argument"
syscall.errors -> go:string."input/output error"
syscall.errors -> go:string."transport endpoint is already connected"
syscall.errors -> go:string."is a directory"
syscall.errors -> go:string."is a named type file"
syscall.errors -> go:string."key has expired"
syscall.errors -> go:string."key was rejected by service"
syscall.errors -> go:string."key has been revoked"
syscall.errors -> go:string."level 2 halted"
syscall.errors -> go:string."level 2 not synchronized"
syscall.errors -> go:string."level 3 halted"
syscall.errors -> go:string."level 3 reset"
syscall.errors -> go:string."can not access a needed shared library"
syscall.errors -> go:string."accessing a corrupted shared library"
syscall.errors -> go:string."cannot exec a shared library directly"
syscall.errors -> go:string."attempting to link in too many shared libraries"
syscall.errors -> go:string.".lib section in a.out corrupted"
syscall.errors -> go:string."link number out of range"
syscall.errors -> go:string."too many levels of symbolic links"
syscall.errors -> go:string."wrong medium type"
syscall.errors -> go:string."too many open files"
syscall.errors -> go:string."too many links"
syscall.errors -> go:string."message too long"
syscall.errors -> go:string."multihop attempted"
syscall.errors -> go:string."file name too long"
syscall.errors -> go:string."no XENIX semaphores available"
syscall.errors -> go:string."network is down"
syscall.errors -> go:string."network dropped connection on reset"
syscall.errors -> go:string."network is unreachable"
syscall.errors -> go:string."too many open files in system"
syscall.errors -> go:string."no anode"
syscall.errors -> go:string."no buffer space available"
syscall.errors -> go:string."no CSI structure available"
syscall.errors -> go:string."no data available"
syscall.errors -> go:string."no such device"
syscall.errors -> go:string."exec format error"
syscall.errors -> go:string."required key not available"
syscall.errors -> go:string."no locks available"
syscall.errors -> go:string."link has been severed"
syscall.errors -> go:string."no medium found"
syscall.errors -> go:string."cannot allocate memory"
syscall.errors -> go:string."no message of desired type"
syscall.errors -> go:string."machine is not on the network"
syscall.errors -> go:string."package not installed"
syscall.errors -> go:string."protocol not available"
syscall.errors -> go:string."no space left on device"
syscall.errors -> go:string."out of streams resources"
syscall.errors -> go:string."device not a stream"
syscall.errors -> go:string."function not implemented"
syscall.errors -> go:string."block device required"
syscall.errors -> go:string."transport endpoint is not connected"
syscall.errors -> go:string."directory not empty"
syscall.errors -> go:string."not a XENIX named type file"
syscall.errors -> go:string."state not recoverable"
syscall.errors -> go:string."socket operation on non-socket"
syscall.errors -> go:string."operation not supported"
syscall.errors -> go:string."inappropriate ioctl for device"
syscall.errors -> go:string."name not unique on network"
syscall.errors -> go:string."no such device or address"
syscall.errors -> go:string."value too large for defined data type"
syscall.errors -> go:string."owner died"
syscall.errors -> go:string."operation not permitted"
syscall.errors -> go:string."protocol family not supported"
syscall.errors -> go:string."broken pipe"
syscall.errors -> go:string."protocol error"
syscall.errors -> go:string."protocol not supported"
syscall.errors -> go:string."protocol wrong type for socket"
syscall.errors -> go:string."numerical result out of range"
syscall.errors -> go:string."remote address changed"
syscall.errors -> go:string."object is remote"
syscall.errors -> go:string."remote I/O error"
syscall.errors -> go:string."interrupted system call should be restarted"
syscall.errors -> go:string."read-only file system"
syscall.errors -> go:string."cannot send after transport endpoint shutdown"
syscall.errors -> go:string."socket type not supported"
syscall.errors -> go:string."illegal seek"
syscall.errors -> go:string."no such process"
syscall.errors -> go:string."srmount error"
syscall.errors -> go:string."stale NFS file handle"
syscall.errors -> go:string."streams pipe error"
syscall.errors -> go:string."timer expired"
syscall.errors -> go:string."connection timed out"
syscall.errors -> go:string."too many references: cannot splice"
syscall.errors -> go:string."text file busy"
syscall.errors -> go:string."structure needs cleaning"
syscall.errors -> go:string."protocol driver not attached"
syscall.errors -> go:string."too many users"
syscall.errors -> go:string."invalid cross-device link"
syscall.errors -> go:string."exchange full"
syscall.errors -> go:string."not supported by windows"
 -> go:info.[131]string
syscall.errERROR_IO_PENDING -> syscall..stmp_0
syscall.errERROR_EINVAL -> syscall..stmp_1
syscall..stmp_2 -> go:string."SetFilePointerEx"
syscall..stmp_3 -> go:string."ConvertSidToStringSidW"
syscall..stmp_4 -> go:string."ConvertStringSidToSidW"
syscall..stmp_5 -> go:string."CopySid"
syscall..stmp_6 -> go:string."CreateProcessAsUserW"
syscall..stmp_7 -> go:string."CryptAcquireContextW"
syscall..stmp_8 -> go:string."CryptGenRandom"
syscall..stmp_9 -> go:string."CryptReleaseContext"
syscall..stmp_10 -> go:string."GetLengthSid"
syscall..stmp_11 -> go:string."GetTokenInformation"
syscall..stmp_12 -> go:string."LookupAccountNameW"
syscall..stmp_13 -> go:string."LookupAccountSidW"
syscall..stmp_14 -> go:string."OpenProcessToken"
syscall..stmp_15 -> go:string."RegCloseKey"
syscall..stmp_16 -> go:string."RegEnumKeyExW"
syscall..stmp_17 -> go:string."RegOpenKeyExW"
syscall..stmp_18 -> go:string."RegQueryInfoKeyW"
syscall..stmp_19 -> go:string."RegQueryValueExW"
syscall..stmp_20 -> go:string."CertAddCertificateContextToStore"
syscall..stmp_21 -> go:string."CertCloseStore"
syscall..stmp_22 -> go:string."CertCreateCertificateContext"
syscall..stmp_23 -> go:string."CertEnumCertificatesInStore"
syscall..stmp_24 -> go:string."CertFreeCertificateChain"
syscall..stmp_25 -> go:string."CertFreeCertificateContext"
syscall..stmp_26 -> go:string."CertGetCertificateChain"
syscall..stmp_27 -> go:string."CertOpenStore"
syscall..stmp_28 -> go:string."CertOpenSystemStoreW"
syscall..stmp_29 -> go:string."CertVerifyCertificateChainPolicy"
syscall..stmp_30 -> go:string."DnsNameCompare_W"
syscall..stmp_31 -> go:string."DnsQuery_W"
syscall..stmp_32 -> go:string."DnsRecordListFree"
syscall..stmp_33 -> go:string."GetAdaptersInfo"
syscall..stmp_34 -> go:string."GetIfEntry"
syscall..stmp_35 -> go:string."CancelIo"
syscall..stmp_36 -> go:string."CancelIoEx"
syscall..stmp_37 -> go:string."CloseHandle"
syscall..stmp_38 -> go:string."CreateDirectoryW"
syscall..stmp_39 -> go:string."CreateFileMappingW"
syscall..stmp_40 -> go:string."CreateFileW"
syscall..stmp_41 -> go:string."CreateHardLinkW"
syscall..stmp_42 -> go:string."CreateIoCompletionPort"
syscall..stmp_43 -> go:string."CreatePipe"
syscall..stmp_44 -> go:string."CreateProcessW"
syscall..stmp_45 -> go:string."CreateSymbolicLinkW"
syscall..stmp_46 -> go:string."CreateToolhelp32Snapshot"
syscall..stmp_47 -> go:string."DeleteFileW"
syscall..stmp_48 -> go:string."DeleteProcThreadAttributeList"
syscall..stmp_49 -> go:string."DeviceIoControl"
syscall..stmp_50 -> go:string."DuplicateHandle"
syscall..stmp_51 -> go:string."ExitProcess"
syscall..stmp_52 -> go:string."FindClose"
syscall..stmp_53 -> go:string."FindFirstFileW"
syscall..stmp_54 -> go:string."FindNextFileW"
syscall..stmp_55 -> go:string."FlushFileBuffers"
syscall..stmp_56 -> go:string."FlushViewOfFile"
syscall..stmp_57 -> go:string."FormatMessageW"
syscall..stmp_58 -> go:string."FreeEnvironmentStringsW"
syscall..stmp_59 -> go:string."FreeLibrary"
syscall..stmp_60 -> go:string."GetCommandLineW"
syscall..stmp_61 -> go:string."GetComputerNameW"
syscall..stmp_62 -> go:string."GetConsoleMode"
syscall..stmp_63 -> go:string."GetCurrentDirectoryW"
syscall..stmp_64 -> go:string."GetCurrentProcess"
syscall..stmp_65 -> go:string."GetCurrentProcessId"
syscall..stmp_66 -> go:string."GetEnvironmentStringsW"
syscall..stmp_67 -> go:string."GetEnvironmentVariableW"
syscall..stmp_68 -> go:string."GetExitCodeProcess"
syscall..stmp_69 -> go:string."GetFileAttributesExW"
syscall..stmp_70 -> go:string."GetFileAttributesW"
syscall..stmp_71 -> go:string."GetFileInformationByHandle"
syscall..stmp_72 -> go:string."GetFileType"
syscall..stmp_74 -> go:string."GetFullPathNameW"
syscall..stmp_75 -> go:string."GetLastError"
syscall..stmp_76 -> go:string."GetLongPathNameW"
syscall..stmp_77 -> go:string."GetProcAddress"
syscall..stmp_78 -> go:string."GetProcessTimes"
syscall..stmp_79 -> go:string."GetQueuedCompletionStatus"
syscall..stmp_80 -> go:string."GetShortPathNameW"
syscall..stmp_81 -> go:string."GetStartupInfoW"
syscall..stmp_82 -> go:string."GetStdHandle"
syscall..stmp_83 -> go:string."GetSystemTimeAsFileTime"
syscall..stmp_84 -> go:string."GetTempPathW"
syscall..stmp_85 -> go:string."GetTimeZoneInformation"
syscall..stmp_86 -> go:string."GetVersion"
syscall..stmp_87 -> go:string."InitializeProcThreadAttributeList"
syscall..stmp_88 -> go:string."LoadLibraryW"
syscall..stmp_89 -> go:string."LocalFree"
syscall..stmp_90 -> go:string."MapViewOfFile"
syscall..stmp_91 -> go:string."MoveFileW"
syscall..stmp_92 -> go:string."OpenProcess"
syscall..stmp_93 -> go:string."PostQueuedCompletionStatus"
syscall..stmp_94 -> go:string."Process32FirstW"
syscall..stmp_95 -> go:string."Process32NextW"
syscall..stmp_96 -> go:string."ReadConsoleW"
syscall..stmp_97 -> go:string."ReadDirectoryChangesW"
syscall..stmp_98 -> go:string."ReadFile"
syscall..stmp_99 -> go:string."RemoveDirectoryW"
syscall..stmp_100 -> go:string."SetCurrentDirectoryW"
syscall..stmp_101 -> go:string."SetEndOfFile"
syscall..stmp_102 -> go:string."SetEnvironmentVariableW"
syscall..stmp_103 -> go:string."SetFileAttributesW"
syscall..stmp_104 -> go:string."SetFileCompletionNotificationModes"
syscall..stmp_105 -> go:string."SetFilePointer"
syscall..stmp_106 -> go:string."SetFileTime"
syscall..stmp_107 -> go:string."SetHandleInformation"
syscall..stmp_108 -> go:string."TerminateProcess"
syscall..stmp_109 -> go:string."UnmapViewOfFile"
syscall..stmp_110 -> go:string."UpdateProcThreadAttribute"
syscall..stmp_111 -> go:string."VirtualLock"
syscall..stmp_112 -> go:string."VirtualUnlock"
syscall..stmp_113 -> go:string."WaitForSingleObject"
syscall..stmp_114 -> go:string."WriteConsoleW"
syscall..stmp_115 -> go:string."WriteFile"
syscall..stmp_116 -> go:string."AcceptEx"
syscall..stmp_117 -> go:string."GetAcceptExSockaddrs"
syscall..stmp_118 -> go:string."TransmitFile"
syscall..stmp_119 -> go:string."NetApiBufferFree"
syscall..stmp_120 -> go:string."NetGetJoinInformation"
syscall..stmp_121 -> go:string."NetUserGetInfo"
syscall..stmp_122 -> go:string."RtlGetNtVersionNumbers"
syscall..stmp_123 -> go:string."GetUserNameExW"
syscall..stmp_124 -> go:string."TranslateNameW"
syscall..stmp_125 -> go:string."CommandLineToArgvW"
syscall..stmp_126 -> go:string."GetUserProfileDirectoryW"
syscall..stmp_127 -> go:string."FreeAddrInfoW"
syscall..stmp_128 -> go:string."GetAddrInfoW"
syscall..stmp_129 -> go:string."WSACleanup"
syscall..stmp_130 -> go:string."WSAEnumProtocolsW"
syscall..stmp_131 -> go:string."WSAIoctl"
syscall..stmp_132 -> go:string."WSARecv"
syscall..stmp_133 -> go:string."WSARecvFrom"
syscall..stmp_134 -> go:string."WSASend"
syscall..stmp_135 -> go:string."WSASendTo"
syscall..stmp_136 -> go:string."WSAStartup"
syscall..stmp_137 -> go:string."bind"
syscall..stmp_138 -> go:string."closesocket"
syscall..stmp_139 -> go:string."connect"
syscall..stmp_140 -> go:string."gethostbyname"
syscall..stmp_141 -> go:string."getpeername"
syscall..stmp_142 -> go:string."getprotobyname"
syscall..stmp_143 -> go:string."getservbyname"
syscall..stmp_144 -> go:string."getsockname"
syscall..stmp_145 -> go:string."getsockopt"
syscall..stmp_146 -> go:string."listen"
syscall..stmp_147 -> go:string."ntohs"
syscall..stmp_148 -> go:string."setsockopt"
syscall..stmp_149 -> go:string."shutdown"
syscall..stmp_150 -> go:string."socket"
type:syscall.Proc -> type:.eqfunc.syscall.Proc
type:syscall.Proc -> type:.namedata.*syscall.Proc.
type:syscall.Proc -> type:*syscall.Proc
type:syscall.Proc -> type:.namedata.Dll.
type:syscall.Proc -> type:*syscall.DLL
type:*syscall.DLL -> type:.namedata.*syscall.DLL.
type:*syscall.DLL -> type:.namedata.FindProc.
type:*syscall.DLL -> type:.namedata.MustFindProc.
type:*syscall.DLL -> type:.namedata.Release.
type:syscall.DLL -> type:.eqfunc.syscall.DLL
type:syscall.DLL -> type:.namedata.Handle.
type:syscall.LazyDLL -> type:.eqfunc.syscall.LazyDLL
type:syscall.LazyDLL -> type:.namedata.*syscall.LazyDLL.
type:syscall.LazyDLL -> type:*syscall.LazyDLL
type:syscall.LazyDLL -> type:.namedata.mu-
type:syscall.LazyDLL -> type:.namedata.dll-
type:*syscall.LazyDLL -> type:.namedata.NewProc.
type:*syscall.LazyDLL -> type:.namedata.mustLoad-
 -> go:info.*syscall.DLL
 -> go:info.syscall.UTF16PtrFromString$abstract
 -> go:info.*syscall.Proc
 -> go:info.syscall.BytePtrFromString$abstract
 -> go:info.unicode/utf16.AppendRune$abstract
 -> go:info.unicode/utf16.EncodeRune$abstract
 -> go:info.unicode/utf16.DecodeRune$abstract
 -> go:info.syscall.errnoErr$abstract
 -> go:info.syscall.getStdHandle$abstract
internal/poll.(*FD).Init -> internal/poll.initErr
internal/poll.(*FD).Init -> internal/poll.(*pollDesc).init
internal/poll.(*FD).Init -> internal/poll.logInitFD
internal/poll.(*FD).Init -> internal/poll.useSetFileCompletionNotificationModes
internal/poll.(*FD).Init -> syscall.SetFileCompletionNotificationModes
internal/poll.(*FD).Init -> syscall.WSAIoctl
internal/poll.(*FD).Init -> go:string."wsaioctl"
internal/poll.(*FD).Init -> go:string."internal error: unknown network type "
internal/poll.(*FD).Init -> type:errors.errorString
internal/poll.(*FD).Init -> go:itab.*errors.errorString,error
internal/poll.(*FD).Init -> gclocals·DXAKAKT0nPH+DeBPOeAb7w==
internal/poll.(*FD).Init -> gclocals·1kRPT33UFFD3LB7JZpxYNA==
internal/poll.(*FD).Init -> fmt.(*ss).consume.arginfo1
internal/poll.(*FD).Init -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
type:errors.errorString -> type:.namedata.*errors.errorString-
type:errors.errorString -> type:*errors.errorString <UsedInIface>
type:errors.errorString -> type:.importpath.errors.
type:*errors.errorString <UsedInIface> -> type:errors.errorString <UsedInIface>
syscall.SetFileCompletionNotificationModes -> syscall.procSetFileCompletionNotificationModes
syscall.WSAIoctl -> syscall.procWSAIoctl
syscall.WSAIoctl -> gclocals·BCEpQUfn5Gxz9FRFBCaRpw==
syscall.WSAIoctl -> gclocals·113EhXzSKJvBCykfHoGnvA==
syscall.WSAIoctl -> internal/syscall/windows.WSASendMsg.stkobj
syscall.WSAIoctl -> syscall.WSAIoctl.arginfo1
syscall.WSAIoctl -> syscall.WSAIoctl.argliveinfo
 -> go:info.*syscall.Overlapped
internal/poll.(*pollDesc).init -> internal/poll.serverInit
internal/poll.(*pollDesc).init -> internal/poll.runtime_pollServerInit·f
internal/poll.(*pollDesc).init -> sync.(*Once).doSlow
internal/poll.(*pollDesc).init -> internal/poll.runtime_pollOpen
internal/poll.(*pollDesc).init -> internal/poll.errERROR_IO_PENDING
sync.(*Once).doSlow -> sync.(*Once).doSlow.func1
sync.(*Once).doSlow -> sync.(*Once).doSlow.func2
sync.(*Once).doSlow -> gclocals·h/pkaeCJVtF61d0LtRKFIw==
sync.(*Once).doSlow -> sync.(*Once).doSlow.stkobj
sync.(*Once).doSlow -> sync.(*Once).doSlow.opendefer
sync.(*Once).doSlow.func2 -> sync/atomic.StoreUint32.wrapinfo
 -> go:info.*sync.Once
internal/poll..inittask -> internal/poll.init.0
internal/poll.init.0 -> syscall.WSAStartup
internal/poll.init.0 -> internal/poll.checkSetFileCompletionNotificationModes
internal/poll.init.0 -> gclocals·nUEUNOz08/ULnbq2PkIGhw==
internal/poll.init.0 -> internal/poll.init.0.stkobj
internal/poll.init.0 -> go:sehuw.12.ARICBRIDD1AAAAAA
syscall.WSAStartup -> syscall.procWSAStartup
 -> go:info.*syscall.WSAData
internal/poll.checkSetFileCompletionNotificationModes -> syscall.WSAEnumProtocols
internal/poll.checkSetFileCompletionNotificationModes -> go:sehuw.12.AR4CBR4DG1AAAAAA
syscall.WSAEnumProtocols -> syscall.procWSAEnumProtocolsW
syscall.WSAEnumProtocols -> gclocals·606KhilzCaaEqjGTsQfiIA==
syscall.WSAEnumProtocols -> internal/syscall/windows.adjustTokenPrivileges.stkobj
 -> go:info.*syscall.WSAProtocolInfo
internal/poll.errERROR_IO_PENDING -> internal/poll..stmp_0
internal/poll.ErrNoDeadline -> internal/poll..stmp_2
internal/poll.ErrDeadlineExceeded -> go:itab.*internal/poll.DeadlineExceededError,error
internal/poll.ErrDeadlineExceeded -> internal/poll..stmp_3
 -> go:info.sync.Once
 -> go:info.func(string, *internal/poll.FD, error)
internal/poll..stmp_2 -> go:string."file type does not support deadline"
 -> go:info.*internal/poll.pollDesc
 -> go:info.*internal/poll.FD
 -> go:info.sync.(*Once).Do$abstract
 -> go:info.internal/poll.errnoErr$abstract
 -> go:info.[32]syscall.WSAProtocolInfo
 -> go:info.[2]int32
 -> go:info.syscall.LoadSetFileCompletionNotificationModes$abstract
 -> go:info.syscall.WSAData
 -> go:info.errors.New$abstract
time..inittask -> time.init
time.init -> runtime.nanotime
time.init -> time.startNano
time.init -> go:sehuw.12.AQoCBQoDB1AAAAAA
type:runtime/internal/atomic.Uintptr <UsedInIface> -> type:.namedata.*atomic.Uintptr.
type:runtime/internal/atomic.Uintptr <UsedInIface> -> type:*runtime/internal/atomic.Uintptr <UsedInIface>
type:runtime/internal/sys.NotInHeap <UsedInIface> -> type:*runtime/internal/sys.NotInHeap <UsedInIface>
type:runtime/internal/sys.NotInHeap <UsedInIface> -> type:runtime/internal/sys.nih <UsedInIface>
type:runtime/internal/sys.nih <UsedInIface> -> type:*runtime/internal/sys.nih <UsedInIface>
internal/oserror.ErrInvalid -> internal/oserror..stmp_0
internal/oserror.ErrPermission -> internal/oserror..stmp_1
internal/oserror.ErrExist -> internal/oserror..stmp_2
internal/oserror.ErrNotExist -> internal/oserror..stmp_3
internal/oserror.ErrClosed -> internal/oserror..stmp_4
internal/oserror..stmp_2 -> go:string."file already exists"
internal/oserror..stmp_3 -> go:string."file does not exist"
internal/oserror..stmp_4 -> go:string."file already closed"
internal/syscall/windows/sysdll..inittask -> internal/syscall/windows/sysdll.init
internal/syscall/windows/sysdll.init -> go:sehuw.12.AQoCBQoDB1AAAAAA
internal/syscall/windows/registry..inittask -> internal/syscall/windows/registry.init
internal/syscall/windows/registry.init -> internal/syscall/windows/registry.modadvapi32
internal/syscall/windows/registry.init -> internal/syscall/windows/registry.modkernel32
internal/syscall/windows/registry.init -> internal/syscall/windows/registry..stmp_3
internal/syscall/windows/registry.init -> internal/syscall/windows/registry..stmp_4
internal/syscall/windows/registry.init -> internal/syscall/windows/registry..stmp_5
internal/syscall/windows/registry.init -> internal/syscall/windows/registry..stmp_6
internal/syscall/windows/registry.init -> internal/syscall/windows/registry..stmp_7
internal/syscall/windows/registry.init -> internal/syscall/windows/registry..stmp_8
internal/syscall/windows/registry.init -> internal/syscall/windows/registry..stmp_9
internal/syscall/windows/registry.init -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
internal/syscall/windows/registry..stmp_3 -> go:string."RegCreateKeyExW"
internal/syscall/windows/registry..stmp_4 -> go:string."RegDeleteKeyW"
internal/syscall/windows/registry..stmp_5 -> go:string."RegDeleteValueW"
internal/syscall/windows/registry..stmp_6 -> go:string."RegEnumValueW"
internal/syscall/windows/registry..stmp_7 -> go:string."RegLoadMUIStringW"
internal/syscall/windows/registry..stmp_8 -> go:string."RegSetValueExW"
internal/syscall/windows/registry..stmp_9 -> go:string."ExpandEnvironmentStringsW"
go:itab.internal/reflectlite.rtype,internal/reflectlite.Type -> type:internal/reflectlite.Type
go:itab.internal/reflectlite.rtype,internal/reflectlite.Type -> type:internal/reflectlite.rtype <UsedInIface>
type:internal/reflectlite.Type -> type:.namedata.*reflectlite.Type.
type:internal/reflectlite.Type -> type:*internal/reflectlite.Type
type:internal/reflectlite.Type -> type:.importpath.internal/reflectlite.
type:internal/reflectlite.Type -> type:func(internal/reflectlite.Type) bool
type:internal/reflectlite.Type -> type:func() internal/reflectlite.Type
type:internal/reflectlite.Type -> type:func() internal/abi.Kind <UsedInIface>
type:internal/reflectlite.rtype <UsedInIface> -> type:.namedata.*reflectlite.rtype-
type:internal/reflectlite.rtype <UsedInIface> -> type:*internal/reflectlite.rtype <UsedInIface>
type:internal/reflectlite.rtype <UsedInIface> -> type:func(internal/reflectlite.Type) bool <UsedInIface>
type:internal/reflectlite.rtype <UsedInIface> -> type:func() internal/reflectlite.Type <UsedInIface>
type:func() internal/abi.Kind <UsedInIface> -> type:.namedata.*func() abi.Kind-
type:func() internal/abi.Kind <UsedInIface> -> type:internal/abi.Kind <UsedInIface>
type:internal/abi.Kind <UsedInIface> -> type:.namedata.*abi.Kind.
type:internal/abi.Kind <UsedInIface> -> type:*internal/abi.Kind <UsedInIface>
go:info.internal/reflectlite.TypeOf$abstract -> go:info.internal/reflectlite.emptyInterface
go:itab.syscall.Errno,error -> type:syscall.Errno <UsedInIface>
type:syscall.Errno <UsedInIface> -> type:.namedata.*syscall.Errno.
type:syscall.Errno <UsedInIface> -> type:*syscall.Errno <UsedInIface>
type:syscall.Errno <UsedInIface> -> type:.namedata.Is.
type:syscall.Errno <UsedInIface> -> type:.namedata.Temporary.
type:syscall.Errno <UsedInIface> -> type:.namedata.Timeout.
type:func(*os.file) error <UsedInIface> -> type:.namedata.*func(*os.file) error-
go:info.internal/itoa.Uitoa$abstract -> go:info.[20]uint8
type:[1]string -> type:.namedata.*[1]string-
os.(*file).close·f -> os.(*file).close
os.(*file).close -> os.dirBufPool
os.(*file).close -> internal/poll.(*FD).Close
os.(*file).close -> internal/poll.ErrFileClosing
os.(*file).close -> type:io/fs.PathError
os.(*file).close -> go:string."close"
os.(*file).close -> go:itab.*io/fs.PathError,error
os.(*file).close -> gclocals·xRcvuIOxpzKaUmhdAfzWhw==
os.dirBufPool -> os.glob..func1·f
 -> go:info.*os.file
 -> go:info.os.(*dirInfo).close$abstract
type:io/fs.PathError -> type:.eqfunc.io/fs.PathError
type:io/fs.PathError -> type:.namedata.*fs.PathError.
type:io/fs.PathError -> type:*io/fs.PathError <UsedInIface>
type:io/fs.PathError -> type:.importpath.io/fs.
type:io/fs.PathError -> type:.namedata.Op.
type:io/fs.PathError -> type:.namedata.Path.
type:*io/fs.PathError <UsedInIface> -> type:io/fs.PathError <UsedInIface>
internal/poll.(*FD).Close -> internal/poll.(*fdMutex).increfAndClose
internal/poll.(*FD).Close -> syscall.CancelIoEx
internal/poll.(*FD).Close -> internal/poll.runtime_pollUnblock
internal/poll.(*FD).Close -> internal/poll.(*FD).decref
internal/poll.(*FD).Close -> internal/poll.runtime_Semacquire
internal/poll.(*FD).Close -> go:itab.internal/poll.errNetClosing,error
syscall.CancelIoEx -> syscall.procCancelIoEx
internal/poll.(*fdMutex).increfAndClose -> internal/poll.runtime_Semrelease
internal/poll.(*fdMutex).increfAndClose -> internal/poll..stmp_5
internal/poll.(*FD).decref -> internal/poll.(*FD).destroy
internal/poll.(*FD).decref -> internal/poll..stmp_8
internal/poll.(*FD).decref -> go:sehuw.12.AQoCBQoDB1AAAAAA
internal/poll.(*FD).destroy -> internal/poll.runtime_pollClose
internal/poll.(*FD).destroy -> internal/poll.CloseFunc
internal/poll.(*FD).destroy -> syscall.CloseHandle
syscall.CloseHandle -> syscall.procCloseHandle
internal/poll.ErrFileClosing -> internal/poll..stmp_1
internal/poll.CloseFunc -> syscall.Closesocket·f
 -> go:info.func(syscall.Handle) error
internal/poll..stmp_1 -> go:string."use of closed file"
 -> go:info.*internal/poll.fdMutex
 -> go:info.internal/poll.(*fdMutex).decref$abstract
 -> go:info.internal/poll.(*pollDesc).close$abstract
 -> go:info.internal/poll.(*pollDesc).evict$abstract
 -> go:info.internal/poll.errClosing$abstract
os.glob..func1·f -> os.glob..func1
 -> go:info.*[]uint8
sync/atomic.StoreUint32.wrapinfo -> sync/atomic.StoreUint32
sync.poolCleanup·f -> sync.poolCleanup
sync.poolCleanup -> sync.oldPools
type:map[string]*unicode.RangeTable -> type:.namedata.*map[string]*unicode.RangeTable-
type:map[string]*unicode.RangeTable -> type:*unicode.RangeTable
type:map[string]*unicode.RangeTable -> type:noalg.map.bucket[string]*unicode.RangeTable
type:*unicode.RangeTable -> type:.namedata.*unicode.RangeTable.
type:*unicode.RangeTable -> type:unicode.RangeTable
type:unicode.RangeTable -> type:.importpath.unicode.
type:unicode.RangeTable -> type:.namedata.R16.
type:unicode.RangeTable -> type:[]unicode.Range16
type:unicode.RangeTable -> type:.namedata.R32.
type:unicode.RangeTable -> type:[]unicode.Range32
type:unicode.RangeTable -> type:.namedata.LatinOffset.
type:[]unicode.Range16 -> type:.namedata.*[]unicode.Range16-
type:[]unicode.Range16 -> type:unicode.Range16
type:unicode.Range16 -> type:.eqfunc6
type:unicode.Range16 -> type:.namedata.*unicode.Range16.
type:unicode.Range16 -> type:*unicode.Range16
type:unicode.Range16 -> type:.namedata.Lo.
type:unicode.Range16 -> type:.namedata.Hi.
type:unicode.Range16 -> type:.namedata.Stride.
type:[]unicode.Range32 -> type:.namedata.*[]unicode.Range32-
type:[]unicode.Range32 -> type:unicode.Range32
type:unicode.Range32 -> type:.eqfunc12
type:unicode.Range32 -> type:.namedata.*unicode.Range32.
type:unicode.Range32 -> type:*unicode.Range32
type:noalg.map.bucket[string]*unicode.RangeTable -> runtime.gcbits.aaaafe0300000000
type:noalg.map.bucket[string]*unicode.RangeTable -> type:.namedata.*map.bucket[string]*unicode.RangeTable-
type:noalg.map.bucket[string]*unicode.RangeTable -> type:noalg.[8]*unicode.RangeTable
type:noalg.[8]*unicode.RangeTable -> type:.namedata.*[8]*unicode.RangeTable-
type:noalg.[8]*unicode.RangeTable -> type:[]*unicode.RangeTable
type:[]*unicode.RangeTable -> type:.namedata.*[]*unicode.RangeTable-
runtime.SetFinalizer.stkobj -> runtime.gcbits.3600000000000000
internal/poll.runtime_pollOpen -> runtime.pollcache
internal/poll.runtime_pollOpen -> runtime.(*pollCache).alloc
internal/poll.runtime_pollOpen -> runtime.(*pollDesc).setEventErr
internal/poll.runtime_pollOpen -> runtime.(*pollDesc).publishInfo
internal/poll.runtime_pollOpen -> runtime.netpollopen
internal/poll.runtime_pollOpen -> runtime.(*pollCache).free
internal/poll.runtime_pollOpen -> go:string."runtime: blocked read on free polldesc"
internal/poll.runtime_pollOpen -> go:string."runtime: blocked write on free polldesc"
 -> go:info.runtime.pollCache
 -> go:info.*runtime.pollCache
internal/poll.runtime_pollClose -> go:string."runtime: blocked read on closing polldesc"
internal/poll.runtime_pollClose -> go:string."runtime: blocked write on closing polldesc"
internal/poll.runtime_pollClose -> go:string."runtime: close polldesc w/o unblock"
internal/poll.runtime_pollUnblock -> runtime.netpollgoready
internal/poll.runtime_pollUnblock -> go:string."runtime: unblock on closing polldesc"
internal/poll.runtime_pollUnblock -> gclocals·ObbMMIpVrAxUpCnzYk+HQQ==
runtime.netpollgoready -> runtime.netpollgoready.func1
sync.runtime_notifyListCheck -> go:string."runtime: bad notifyList size - sync="
sync.runtime_notifyListCheck -> go:string." runtime="
sync.runtime_notifyListCheck -> go:string."bad notifyList size"
syscall.Syscall -> syscall.SyscallN
syscall.Syscall9 -> syscall.Syscall9.arginfo1
syscall.SyscallN -> runtime..stmp_145
syscall.SyscallN -> gclocals·TiGXBTFBYtQ3/ac6Hp0oWQ==
syscall.SyscallN -> gclocals·f7pzLyBNqoUcrlyzhT3gtQ==
syscall.SyscallN -> os.(*Process).signal.opendefer
 -> go:info.*runtime.libcall
runtime..stmp_145 -> go:string."runtime: SyscallN has too many arguments"
syscall.loadsystemlibrary -> syscall.loadsystemlibrary
 -> go:info.struct { runtime.lpFileName *uint16; runtime.hFile uintptr; runtime.flags uint32 }
 -> go:info.runtime.getLoadLibraryEx$abstract
syscall.loadlibrary -> syscall.loadlibrary
syscall.loadlibrary -> runtime._LoadLibraryW
syscall.loadlibrary -> gclocals·sBt7dvzi6XMoVD++Efqbqg==
 -> go:info.runtime.getLoadLibrary$abstract
syscall.getprocaddress -> syscall.getprocaddress
syscall.getprocaddress -> syscall.getprocaddress.opendefer
 -> go:info.runtime.getGetProcAddress$abstract
runtime.forcegchelper·f -> runtime.forcegchelper
runtime.forcegchelper -> go:string."GC forced\n"
runtime.forcegchelper -> go:string."forcegc: phase error"
runtime.runfinq·f -> runtime.runfinq
runtime.runfinq -> runtime.finalizercommit·f
runtime.runfinq -> go:string."bad kind in runfinq"
runtime.runfinq -> go:string."missing type in runfinq"
runtime.runfinq -> gclocals·vLW9Z1Pssnh5rZ/Jz13uOA==
 -> go:info.runtime/internal/atomic.(*Uint32).And$abstract
runtime.finalizercommit·f -> runtime.finalizercommit
type:func(internal/reflectlite.Type) bool <UsedInIface> -> type:.namedata.*func(reflectlite.Type) bool-
type:func(internal/reflectlite.Type) bool <UsedInIface> -> type:internal/reflectlite.Type <UsedInIface>
type:internal/reflectlite.Type <UsedInIface> -> type:*internal/reflectlite.Type <UsedInIface>
type:func() internal/reflectlite.Type <UsedInIface> -> type:.namedata.*func() reflectlite.Type-
type:.eqfunc.io/fs.PathError -> type:.eq.io/fs.PathError
 -> go:info.*io/fs.PathError
type:.eqfunc.syscall.DLLError -> type:.eq.syscall.DLLError
 -> go:info.*syscall.DLLError
type:.eqfunc.syscall.DLL -> type:.eq.syscall.DLL
type:.eqfunc.syscall.Proc -> type:.eq.syscall.Proc
type:.eqfunc.syscall.LazyDLL -> type:.eq.syscall.LazyDLL
go:itab.internal/poll.errNetClosing,error -> type:internal/poll.errNetClosing <UsedInIface>
type:internal/poll.errNetClosing <UsedInIface> -> type:.namedata.*poll.errNetClosing-
type:internal/poll.errNetClosing <UsedInIface> -> type:*internal/poll.errNetClosing <UsedInIface>
go:itab.*internal/poll.DeadlineExceededError,error -> type:*internal/poll.DeadlineExceededError <UsedInIface>
type:*internal/poll.DeadlineExceededError <UsedInIface> -> type:.namedata.*poll.DeadlineExceededError.
type:*internal/poll.DeadlineExceededError <UsedInIface> -> type:internal/poll.DeadlineExceededError <UsedInIface>
internal/poll..stmp_5 -> go:string."too many concurrent operations on a single file or socket (max 1048575)"
internal/poll..stmp_8 -> go:string."inconsistent poll.fdMutex"
internal/poll.runtime_pollServerInit·f -> internal/poll.runtime_pollServerInit
syscall.Closesocket·f -> syscall.Closesocket
syscall.Closesocket -> syscall.procclosesocket
type:runtime.errorString <UsedInIface> -> runtime.(*errorString).Error
type:runtime.errorString <UsedInIface> -> runtime.errorString.Error
type:runtime.errorString <UsedInIface> -> runtime.(*errorString).RuntimeError
type:runtime.errorString <UsedInIface> -> runtime.errorString.RuntimeError
type:*runtime.PanicNilError <UsedInIface> -> runtime.(*PanicNilError).Error
type:*runtime.PanicNilError <UsedInIface> -> runtime.(*PanicNilError).RuntimeError
type:*runtime.TypeAssertionError <UsedInIface> -> runtime.(*TypeAssertionError).Error
type:*runtime.TypeAssertionError <UsedInIface> -> runtime.(*TypeAssertionError).RuntimeError
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Align
type:*internal/abi.Type <UsedInIface> -> type:func() *internal/abi.ArrayType <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).ArrayType
type:*internal/abi.Type <UsedInIface> -> type:func() internal/abi.ChanDir <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).ChanDir
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Common
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Elem
type:*internal/abi.Type <UsedInIface> -> type:func() []internal/abi.Method <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).FieldAlign
type:*internal/abi.Type <UsedInIface> -> type:func() *internal/abi.FuncType <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).FuncType
type:*internal/abi.Type <UsedInIface> -> type:func(uintptr, uintptr) []uint8 <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).GcSlice
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).HasName
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).IfaceIndir
type:*internal/abi.Type <UsedInIface> -> type:func() *internal/abi.InterfaceType <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).InterfaceType
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).IsDirectIface
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Key
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Kind
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Len
type:*internal/abi.Type <UsedInIface> -> type:func() *internal/abi.MapType <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).MapType
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Pointers
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Size
type:*internal/abi.Type <UsedInIface> -> type:func() *internal/abi.StructType <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).StructType
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Uncommon
type:runtime.waitReason <UsedInIface> -> runtime.(*waitReason).String
type:runtime.waitReason <UsedInIface> -> runtime.waitReason.String
type:*runtime.goroutineProfileStateHolder <UsedInIface> -> type:func(runtime.goroutineProfileState, runtime.goroutineProfileState) bool <UsedInIface>
type:*runtime.goroutineProfileStateHolder <UsedInIface> -> runtime.(*goroutineProfileStateHolder).CompareAndSwap
type:*runtime.goroutineProfileStateHolder <UsedInIface> -> type:func() runtime.goroutineProfileState <UsedInIface>
type:*runtime.goroutineProfileStateHolder <UsedInIface> -> runtime.(*goroutineProfileStateHolder).Load
type:*runtime.goroutineProfileStateHolder <UsedInIface> -> type:func(runtime.goroutineProfileState) <UsedInIface>
type:*runtime.goroutineProfileStateHolder <UsedInIface> -> runtime.(*goroutineProfileStateHolder).Store
type:*runtime/internal/atomic.noCopy <UsedInIface> -> runtime/internal/atomic.(*noCopy).Lock
type:*runtime/internal/atomic.noCopy <UsedInIface> -> runtime/internal/atomic.(*noCopy).Unlock
type:*runtime/internal/atomic.Uint8 <UsedInIface> -> type:func(uint8) <UsedInIface>
type:*runtime/internal/atomic.Uint8 <UsedInIface> -> runtime/internal/atomic.(*Uint8).And
type:*runtime/internal/atomic.Uint8 <UsedInIface> -> type:func() uint8 <UsedInIface>
type:*runtime/internal/atomic.Uint8 <UsedInIface> -> runtime/internal/atomic.(*Uint8).Load
type:*runtime/internal/atomic.Uint8 <UsedInIface> -> runtime/internal/atomic.(*Uint8).Or
type:*runtime/internal/atomic.Uint8 <UsedInIface> -> runtime/internal/atomic.(*Uint8).Store
type:*runtime/internal/atomic.Bool <UsedInIface> -> runtime/internal/atomic.(*Bool).Load
type:*runtime/internal/atomic.Bool <UsedInIface> -> type:func(bool) <UsedInIface>
type:*runtime/internal/atomic.Bool <UsedInIface> -> runtime/internal/atomic.(*Bool).Store
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> type:func(int32) uint32 <UsedInIface>
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).Add
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> type:func(uint32) <UsedInIface>
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).And
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> type:func(uint32, uint32) bool <UsedInIface>
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).CompareAndSwap
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).CompareAndSwapRelease
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> type:func() uint32 <UsedInIface>
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).Load
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).LoadAcquire
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).Or
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).Store
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).StoreRelease
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> type:func(uint32) uint32 <UsedInIface>
type:*runtime/internal/atomic.Uint32 <UsedInIface> -> runtime/internal/atomic.(*Uint32).Swap
type:runtime.lockRank <UsedInIface> -> runtime.(*lockRank).String
type:runtime.lockRank <UsedInIface> -> runtime.lockRank.String
type:runtime.boundsError <UsedInIface> -> runtime.(*boundsError).Error
type:runtime.boundsError <UsedInIface> -> runtime.boundsError.Error
type:runtime.boundsError <UsedInIface> -> runtime.(*boundsError).RuntimeError
type:runtime.boundsError <UsedInIface> -> runtime.boundsError.RuntimeError
type:*internal/abi.IntArgRegBitmap <UsedInIface> -> internal/abi.(*IntArgRegBitmap).Get
type:*internal/abi.IntArgRegBitmap <UsedInIface> -> type:func(int) <UsedInIface>
type:*internal/abi.IntArgRegBitmap <UsedInIface> -> internal/abi.(*IntArgRegBitmap).Set
type:*internal/abi.RegArgs <UsedInIface> -> internal/abi.(*RegArgs).Dump
type:*internal/abi.RegArgs <UsedInIface> -> type:func(int, uintptr) unsafe.Pointer <UsedInIface>
type:*internal/abi.RegArgs <UsedInIface> -> internal/abi.(*RegArgs).IntRegArgAddr
type:runtime.plainError <UsedInIface> -> runtime.(*plainError).Error
type:runtime.plainError <UsedInIface> -> runtime.plainError.Error
type:runtime.plainError <UsedInIface> -> runtime.(*plainError).RuntimeError
type:runtime.plainError <UsedInIface> -> runtime.plainError.RuntimeError
type:*fmt.pp <UsedInIface> -> fmt.(*pp).Flag
type:*fmt.pp <UsedInIface> -> fmt.(*pp).Precision
type:*fmt.pp <UsedInIface> -> fmt.(*pp).Width
type:*fmt.pp <UsedInIface> -> fmt.(*pp).Write
type:*fmt.pp <UsedInIface> -> type:func(string) (int, error) <UsedInIface>
type:*fmt.pp <UsedInIface> -> fmt.(*pp).WriteString
type:reflect.Value <UsedInIface> -> type:func() reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Addr
type:reflect.Value <UsedInIface> -> reflect.(*Value).Bool
type:reflect.Value <UsedInIface> -> reflect.Value.Bool
type:reflect.Value <UsedInIface> -> type:func() []uint8 <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Bytes
type:reflect.Value <UsedInIface> -> reflect.Value.Bytes
type:reflect.Value <UsedInIface> -> reflect.(*Value).Call
type:reflect.Value <UsedInIface> -> reflect.(*Value).CallSlice
type:reflect.Value <UsedInIface> -> reflect.Value.CallSlice
type:reflect.Value <UsedInIface> -> reflect.(*Value).CanAddr
type:reflect.Value <UsedInIface> -> reflect.Value.CanAddr
type:reflect.Value <UsedInIface> -> reflect.(*Value).CanComplex
type:reflect.Value <UsedInIface> -> reflect.Value.CanComplex
type:reflect.Value <UsedInIface> -> reflect.(*Value).CanConvert
type:reflect.Value <UsedInIface> -> reflect.Value.CanConvert
type:reflect.Value <UsedInIface> -> reflect.(*Value).CanFloat
type:reflect.Value <UsedInIface> -> reflect.Value.CanFloat
type:reflect.Value <UsedInIface> -> reflect.(*Value).CanInt
type:reflect.Value <UsedInIface> -> reflect.Value.CanInt
type:reflect.Value <UsedInIface> -> reflect.(*Value).CanInterface
type:reflect.Value <UsedInIface> -> reflect.Value.CanInterface
type:reflect.Value <UsedInIface> -> reflect.(*Value).CanSet
type:reflect.Value <UsedInIface> -> reflect.Value.CanSet
type:reflect.Value <UsedInIface> -> reflect.(*Value).CanUint
type:reflect.Value <UsedInIface> -> reflect.Value.CanUint
type:reflect.Value <UsedInIface> -> reflect.(*Value).Cap
type:reflect.Value <UsedInIface> -> reflect.Value.Cap
type:reflect.Value <UsedInIface> -> reflect.(*Value).Clear
type:reflect.Value <UsedInIface> -> reflect.Value.Clear
type:reflect.Value <UsedInIface> -> reflect.(*Value).Close
type:reflect.Value <UsedInIface> -> reflect.Value.Close
type:reflect.Value <UsedInIface> -> reflect.(*Value).Comparable
type:reflect.Value <UsedInIface> -> reflect.Value.Comparable
type:reflect.Value <UsedInIface> -> type:func() complex128 <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Complex
type:reflect.Value <UsedInIface> -> reflect.Value.Complex
type:reflect.Value <UsedInIface> -> type:func(reflect.Type) reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Convert
type:reflect.Value <UsedInIface> -> reflect.Value.Convert
type:reflect.Value <UsedInIface> -> reflect.(*Value).Elem
type:reflect.Value <UsedInIface> -> type:func(reflect.Value) bool <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Equal
type:reflect.Value <UsedInIface> -> reflect.Value.Equal
type:reflect.Value <UsedInIface> -> type:func(int) reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Field
type:reflect.Value <UsedInIface> -> type:func([]int) reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).FieldByIndex
type:reflect.Value <UsedInIface> -> reflect.Value.FieldByIndex
type:reflect.Value <UsedInIface> -> type:func([]int) (reflect.Value, error) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).FieldByIndexErr
type:reflect.Value <UsedInIface> -> reflect.Value.FieldByIndexErr
type:reflect.Value <UsedInIface> -> type:func(string) reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).FieldByName
type:reflect.Value <UsedInIface> -> reflect.Value.FieldByName
type:reflect.Value <UsedInIface> -> type:func(func(string) bool) reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).FieldByNameFunc
type:reflect.Value <UsedInIface> -> reflect.Value.FieldByNameFunc
type:reflect.Value <UsedInIface> -> type:func() float64 <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Float
type:reflect.Value <UsedInIface> -> reflect.Value.Float
type:reflect.Value <UsedInIface> -> reflect.(*Value).Grow
type:reflect.Value <UsedInIface> -> reflect.Value.Grow
type:reflect.Value <UsedInIface> -> reflect.(*Value).Index
type:reflect.Value <UsedInIface> -> type:func() int64 <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Int
type:reflect.Value <UsedInIface> -> reflect.Value.Int
type:reflect.Value <UsedInIface> -> reflect.(*Value).Interface
type:reflect.Value <UsedInIface> -> reflect.Value.Interface
type:reflect.Value <UsedInIface> -> type:func() [2]uintptr <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).InterfaceData
type:reflect.Value <UsedInIface> -> reflect.Value.InterfaceData
type:reflect.Value <UsedInIface> -> reflect.(*Value).IsNil
type:reflect.Value <UsedInIface> -> reflect.Value.IsNil
type:reflect.Value <UsedInIface> -> reflect.(*Value).IsValid
type:reflect.Value <UsedInIface> -> reflect.Value.IsValid
type:reflect.Value <UsedInIface> -> reflect.(*Value).IsZero
type:reflect.Value <UsedInIface> -> reflect.Value.IsZero
type:reflect.Value <UsedInIface> -> reflect.(*Value).Kind
type:reflect.Value <UsedInIface> -> reflect.Value.Kind
type:reflect.Value <UsedInIface> -> reflect.(*Value).Len
type:reflect.Value <UsedInIface> -> reflect.Value.Len
type:reflect.Value <UsedInIface> -> type:func(reflect.Value) reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).MapIndex
type:reflect.Value <UsedInIface> -> reflect.Value.MapIndex
type:reflect.Value <UsedInIface> -> type:func() []reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).MapKeys
type:reflect.Value <UsedInIface> -> reflect.Value.MapKeys
type:reflect.Value <UsedInIface> -> type:func() *reflect.MapIter <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).MapRange
type:reflect.Value <UsedInIface> -> reflect.Value.MapRange
type:reflect.Value <UsedInIface> -> reflect.(*Value).Method
type:reflect.Value <UsedInIface> -> reflect.(*Value).MethodByName
type:reflect.Value <UsedInIface> -> reflect.(*Value).NumField
type:reflect.Value <UsedInIface> -> reflect.(*Value).NumMethod
type:reflect.Value <UsedInIface> -> type:func(complex128) bool <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).OverflowComplex
type:reflect.Value <UsedInIface> -> reflect.Value.OverflowComplex
type:reflect.Value <UsedInIface> -> type:func(float64) bool <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).OverflowFloat
type:reflect.Value <UsedInIface> -> reflect.Value.OverflowFloat
type:reflect.Value <UsedInIface> -> type:func(int64) bool <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).OverflowInt
type:reflect.Value <UsedInIface> -> reflect.Value.OverflowInt
type:reflect.Value <UsedInIface> -> type:func(uint64) bool <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).OverflowUint
type:reflect.Value <UsedInIface> -> reflect.Value.OverflowUint
type:reflect.Value <UsedInIface> -> reflect.(*Value).Pointer
type:reflect.Value <UsedInIface> -> type:func() (reflect.Value, bool) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Recv
type:reflect.Value <UsedInIface> -> reflect.Value.Recv
type:reflect.Value <UsedInIface> -> type:func(reflect.Value) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Send
type:reflect.Value <UsedInIface> -> reflect.Value.Send
type:reflect.Value <UsedInIface> -> reflect.(*Value).Set
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetBool
type:reflect.Value <UsedInIface> -> reflect.Value.SetBool
type:reflect.Value <UsedInIface> -> type:func([]uint8) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetBytes
type:reflect.Value <UsedInIface> -> reflect.Value.SetBytes
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetCap
type:reflect.Value <UsedInIface> -> reflect.Value.SetCap
type:reflect.Value <UsedInIface> -> type:func(complex128) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetComplex
type:reflect.Value <UsedInIface> -> reflect.Value.SetComplex
type:reflect.Value <UsedInIface> -> type:func(float64) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetFloat
type:reflect.Value <UsedInIface> -> reflect.Value.SetFloat
type:reflect.Value <UsedInIface> -> type:func(int64) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetInt
type:reflect.Value <UsedInIface> -> reflect.Value.SetInt
type:reflect.Value <UsedInIface> -> type:func(*reflect.MapIter) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetIterKey
type:reflect.Value <UsedInIface> -> reflect.Value.SetIterKey
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetIterValue
type:reflect.Value <UsedInIface> -> reflect.Value.SetIterValue
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetLen
type:reflect.Value <UsedInIface> -> reflect.Value.SetLen
type:reflect.Value <UsedInIface> -> type:func(reflect.Value, reflect.Value) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetMapIndex
type:reflect.Value <UsedInIface> -> reflect.Value.SetMapIndex
type:reflect.Value <UsedInIface> -> type:func(unsafe.Pointer) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetPointer
type:reflect.Value <UsedInIface> -> reflect.Value.SetPointer
type:reflect.Value <UsedInIface> -> type:func(string) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetString
type:reflect.Value <UsedInIface> -> reflect.Value.SetString
type:reflect.Value <UsedInIface> -> type:func(uint64) <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetUint
type:reflect.Value <UsedInIface> -> reflect.Value.SetUint
type:reflect.Value <UsedInIface> -> reflect.(*Value).SetZero
type:reflect.Value <UsedInIface> -> reflect.Value.SetZero
type:reflect.Value <UsedInIface> -> type:func(int, int) reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Slice
type:reflect.Value <UsedInIface> -> type:func(int, int, int) reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Slice3
type:reflect.Value <UsedInIface> -> reflect.Value.Slice3
type:reflect.Value <UsedInIface> -> reflect.(*Value).String
type:reflect.Value <UsedInIface> -> reflect.Value.String
type:reflect.Value <UsedInIface> -> reflect.(*Value).TryRecv
type:reflect.Value <UsedInIface> -> reflect.Value.TryRecv
type:reflect.Value <UsedInIface> -> reflect.(*Value).TrySend
type:reflect.Value <UsedInIface> -> reflect.Value.TrySend
type:reflect.Value <UsedInIface> -> reflect.(*Value).Type
type:reflect.Value <UsedInIface> -> reflect.Value.Type
type:reflect.Value <UsedInIface> -> type:func() uint64 <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).Uint
type:reflect.Value <UsedInIface> -> reflect.Value.Uint
type:reflect.Value <UsedInIface> -> reflect.(*Value).UnsafeAddr
type:reflect.Value <UsedInIface> -> reflect.Value.UnsafeAddr
type:reflect.Value <UsedInIface> -> type:func() unsafe.Pointer <UsedInIface>
type:reflect.Value <UsedInIface> -> reflect.(*Value).UnsafePointer
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Align
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).AssignableTo
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Bits
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).ChanDir
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Comparable
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).ConvertibleTo
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Elem
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Field
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).FieldAlign
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).FieldByIndex
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).FieldByName
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).FieldByNameFunc
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Implements
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).In
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).IsVariadic
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Key
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Kind
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Len
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).NumField
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).NumIn
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).NumOut
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Out
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Size
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).common
type:*reflect.ValueError <UsedInIface> -> reflect.(*ValueError).Error
type:reflect.Kind <UsedInIface> -> reflect.(*Kind).String
type:reflect.Kind <UsedInIface> -> reflect.Kind.String
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Align
type:*reflect.structType <UsedInIface> -> reflect.(*structType).ArrayType
type:*reflect.structType <UsedInIface> -> reflect.(*structType).ChanDir
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Common
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Elem
type:*reflect.structType <UsedInIface> -> reflect.(*structType).ExportedMethods
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Field
type:*reflect.structType <UsedInIface> -> reflect.(*structType).FieldAlign
type:*reflect.structType <UsedInIface> -> reflect.(*structType).FieldByIndex
type:*reflect.structType <UsedInIface> -> reflect.(*structType).FieldByName
type:*reflect.structType <UsedInIface> -> reflect.(*structType).FieldByNameFunc
type:*reflect.structType <UsedInIface> -> reflect.(*structType).FuncType
type:*reflect.structType <UsedInIface> -> reflect.(*structType).GcSlice
type:*reflect.structType <UsedInIface> -> reflect.(*structType).HasName
type:*reflect.structType <UsedInIface> -> reflect.(*structType).IfaceIndir
type:*reflect.structType <UsedInIface> -> reflect.(*structType).InterfaceType
type:*reflect.structType <UsedInIface> -> reflect.(*structType).IsDirectIface
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Key
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Kind
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Len
type:*reflect.structType <UsedInIface> -> reflect.(*structType).MapType
type:*reflect.structType <UsedInIface> -> reflect.(*structType).NumMethod
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Pointers
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Size
type:*reflect.structType <UsedInIface> -> reflect.(*structType).Uncommon
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).Align
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).ArrayType
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).ChanDir
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).Common
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).ExportedMethods
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).FieldAlign
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).FuncType
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).GcSlice
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).HasName
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).IfaceIndir
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).InterfaceType
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).IsDirectIface
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).Key
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).Kind
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).Len
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).MapType
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).NumMethod
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).Pointers
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).Size
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).StructType
type:*reflect.ptrType <UsedInIface> -> reflect.(*ptrType).Uncommon
type:*internal/fmtsort.SortedMap <UsedInIface> -> internal/fmtsort.(*SortedMap).Len
type:*internal/fmtsort.SortedMap <UsedInIface> -> internal/fmtsort.(*SortedMap).Less
type:*internal/fmtsort.SortedMap <UsedInIface> -> internal/fmtsort.(*SortedMap).Swap
type:*sync.Pool <UsedInIface> -> type:func(interface {}) <UsedInIface>
type:*sync.noCopy <UsedInIface> -> sync.(*noCopy).Lock
type:*sync.noCopy <UsedInIface> -> sync.(*noCopy).Unlock
type:internal/abi.Name <UsedInIface> -> type:func(int) *uint8 <UsedInIface>
type:internal/abi.Name <UsedInIface> -> internal/abi.Name.Data
type:internal/abi.Name <UsedInIface> -> type:func(int, string) *uint8 <UsedInIface>
type:internal/abi.Name <UsedInIface> -> internal/abi.Name.DataChecked
type:internal/abi.Name <UsedInIface> -> internal/abi.Name.HasTag
type:internal/abi.Name <UsedInIface> -> internal/abi.Name.IsEmbedded
type:internal/abi.Name <UsedInIface> -> internal/abi.Name.IsExported
type:internal/abi.Name <UsedInIface> -> type:func(int) (int, int) <UsedInIface>
type:internal/abi.Name <UsedInIface> -> internal/abi.Name.ReadVarint
type:*internal/abi.Name <UsedInIface> -> internal/abi.(*Name).Data
type:*internal/abi.Name <UsedInIface> -> internal/abi.(*Name).DataChecked
type:*internal/abi.Name <UsedInIface> -> internal/abi.(*Name).HasTag
type:*internal/abi.Name <UsedInIface> -> internal/abi.(*Name).IsBlank
type:*internal/abi.Name <UsedInIface> -> internal/abi.(*Name).IsEmbedded
type:*internal/abi.Name <UsedInIface> -> internal/abi.(*Name).IsExported
type:*internal/abi.Name <UsedInIface> -> internal/abi.(*Name).Name
type:*internal/abi.Name <UsedInIface> -> internal/abi.(*Name).ReadVarint
type:*internal/abi.Name <UsedInIface> -> internal/abi.(*Name).Tag
type:*internal/abi.UncommonType <UsedInIface> -> internal/abi.(*UncommonType).ExportedMethods
type:*internal/abi.UncommonType <UsedInIface> -> internal/abi.(*UncommonType).Methods
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).Align
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).ArrayType
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).ChanDir
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).Common
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).Elem
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).ExportedMethods
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).FieldAlign
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).FuncType
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).GcSlice
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).HasName
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).IfaceIndir
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).InterfaceType
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).IsDirectIface
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).Key
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).Kind
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).Len
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).MapType
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).NumMethod
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).Pointers
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).Size
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).StructType
type:*internal/abi.StructType <UsedInIface> -> internal/abi.(*StructType).Uncommon
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Align
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).ArrayType
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).ChanDir
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Common
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Elem
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).ExportedMethods
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).FieldAlign
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).FuncType
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).GcSlice
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).HasName
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).IfaceIndir
type:*internal/abi.FuncType <UsedInIface> -> type:func(int) *internal/abi.Type <UsedInIface>
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).In
type:*internal/abi.FuncType <UsedInIface> -> type:func() []*internal/abi.Type <UsedInIface>
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).InSlice
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).InterfaceType
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).IsDirectIface
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).IsVariadic
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Key
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Kind
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Len
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).MapType
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).NumIn
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).NumMethod
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).NumOut
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Out
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).OutSlice
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Pointers
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Size
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).StructType
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Uncommon
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).Align
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).ArrayType
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).ChanDir
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).Common
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).ExportedMethods
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).FieldAlign
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).FuncType
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).GcSlice
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).HasName
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).IfaceIndir
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).InterfaceType
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).IsDirectIface
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).Key
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).Kind
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).Len
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).MapType
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).NumMethod
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).Pointers
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).Size
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).StructType
type:*internal/abi.PtrType <UsedInIface> -> internal/abi.(*PtrType).Uncommon
type:*os.File <UsedInIface> -> type:func() error <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).Chdir
type:*os.File <UsedInIface> -> type:func(io/fs.FileMode) error <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).Chmod
type:*os.File <UsedInIface> -> type:func(int, int) error <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).Chown
type:*os.File <UsedInIface> -> os.(*File).Close
type:*os.File <UsedInIface> -> os.(*File).Fd
type:*os.File <UsedInIface> -> os.(*File).Name
type:*os.File <UsedInIface> -> os.(*File).Read
type:*os.File <UsedInIface> -> type:func([]uint8, int64) (int, error) <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).ReadAt
type:*os.File <UsedInIface> -> type:func(int) ([]io/fs.DirEntry, error) <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).ReadDir
type:*os.File <UsedInIface> -> type:func(io.Reader) (int64, error) <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).ReadFrom
type:*os.File <UsedInIface> -> type:func(int) ([]io/fs.FileInfo, error) <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).Readdir
type:*os.File <UsedInIface> -> type:func(int) ([]string, error) <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).Readdirnames
type:*os.File <UsedInIface> -> type:func(int64, int) (int64, error) <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).Seek
type:*os.File <UsedInIface> -> type:func(time.Time) error <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).SetDeadline
type:*os.File <UsedInIface> -> os.(*File).SetReadDeadline
type:*os.File <UsedInIface> -> os.(*File).SetWriteDeadline
type:*os.File <UsedInIface> -> type:func() (io/fs.FileInfo, error) <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).Stat
type:*os.File <UsedInIface> -> os.(*File).Sync
type:*os.File <UsedInIface> -> type:func() (syscall.RawConn, error) <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).SyscallConn
type:*os.File <UsedInIface> -> type:func(int64) error <UsedInIface>
type:*os.File <UsedInIface> -> os.(*File).Truncate
type:*os.File <UsedInIface> -> os.(*File).Write
type:*os.File <UsedInIface> -> os.(*File).WriteAt
type:*os.File <UsedInIface> -> os.(*File).WriteString
type:*sync.Mutex <UsedInIface> -> sync.(*Mutex).Lock
type:*sync.Mutex <UsedInIface> -> sync.(*Mutex).TryLock
type:*internal/poll.FD <UsedInIface> -> type:func(func() (syscall.Handle, error)) (syscall.Handle, []syscall.RawSockaddrAny, uint32, string, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Accept
type:*internal/poll.FD <UsedInIface> -> type:func(syscall.Sockaddr) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).ConnectEx
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Fchdir
type:*internal/poll.FD <UsedInIface> -> type:func(uint32) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Fchmod
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Fchown
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Fsync
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Ftruncate
type:*internal/poll.FD <UsedInIface> -> type:func(*syscall.ByHandleFileInformation) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).GetFileInformationByHandle
type:*internal/poll.FD <UsedInIface> -> type:func() (uint32, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).GetFileType
type:*internal/poll.FD <UsedInIface> -> type:func(int, int) (int, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).GetsockoptInt
type:*internal/poll.FD <UsedInIface> -> type:func(string, bool) (string, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Pread
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Pwrite
type:*internal/poll.FD <UsedInIface> -> type:func(func(uintptr)) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).RawControl
type:*internal/poll.FD <UsedInIface> -> type:func(func(uintptr) bool) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).RawRead
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).RawWrite
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Read
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8) (int, syscall.Sockaddr, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).ReadFrom
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8, *syscall.SockaddrInet4) (int, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).ReadFromInet4
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8, *syscall.SockaddrInet6) (int, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).ReadFromInet6
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8, []uint8, int) (int, int, int, syscall.Sockaddr, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).ReadMsg
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8, []uint8, int, *syscall.SockaddrInet4) (int, int, int, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).ReadMsgInet4
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8, []uint8, int, *syscall.SockaddrInet6) (int, int, int, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).ReadMsgInet6
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Seek
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).SetDeadline
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).SetReadDeadline
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).SetWriteDeadline
type:*internal/poll.FD <UsedInIface> -> type:func(int32, int32, *uint8, int32) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Setsockopt
type:*internal/poll.FD <UsedInIface> -> type:func(int, int, *syscall.IPMreq) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).SetsockoptIPMreq
type:*internal/poll.FD <UsedInIface> -> type:func(int, int, *syscall.IPv6Mreq) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).SetsockoptIPv6Mreq
type:*internal/poll.FD <UsedInIface> -> type:func(int, int, [4]uint8) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).SetsockoptInet4Addr
type:*internal/poll.FD <UsedInIface> -> type:func(int, int, int) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).SetsockoptInt
type:*internal/poll.FD <UsedInIface> -> type:func(int, int, *syscall.Linger) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).SetsockoptLinger
type:*internal/poll.FD <UsedInIface> -> type:func(int) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Shutdown
type:*internal/poll.FD <UsedInIface> -> type:func(uint32, *uint8, uint32, *uint8, uint32, *uint32, *syscall.Overlapped, uintptr) error <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).WSAIoctl
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Write
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8, []uint8, syscall.Sockaddr) (int, int, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).WriteMsg
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8, []uint8, *syscall.SockaddrInet4) (int, int, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).WriteMsgInet4
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8, []uint8, *syscall.SockaddrInet6) (int, int, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).WriteMsgInet6
type:*internal/poll.FD <UsedInIface> -> type:func([]uint8, syscall.Sockaddr) (int, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).WriteTo
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).WriteToInet4
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).WriteToInet6
type:*internal/poll.FD <UsedInIface> -> type:func(*[][]uint8) (int64, error) <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Writev
type:*syscall.RawSockaddrAny <UsedInIface> -> type:func() (syscall.Sockaddr, error) <UsedInIface>
type:*syscall.RawSockaddrAny <UsedInIface> -> syscall.(*RawSockaddrAny).Sockaddr
type:*internal/poll.operation <UsedInIface> -> internal/poll.(*operation).ClearBufs
type:*internal/poll.operation <UsedInIface> -> internal/poll.(*operation).InitBuf
type:*internal/poll.operation <UsedInIface> -> type:func(*[][]uint8) <UsedInIface>
type:*internal/poll.operation <UsedInIface> -> internal/poll.(*operation).InitBufs
type:*internal/poll.operation <UsedInIface> -> type:func([]uint8, []uint8) <UsedInIface>
type:*internal/poll.operation <UsedInIface> -> internal/poll.(*operation).InitMsg
type:reflect.ChanDir <UsedInIface> -> reflect.(*ChanDir).String
type:reflect.ChanDir <UsedInIface> -> reflect.ChanDir.String
type:reflect.StructField <UsedInIface> -> reflect.(*StructField).IsExported
type:reflect.StructField <UsedInIface> -> reflect.StructField.IsExported
type:reflect.StructTag <UsedInIface> -> type:func(string) string <UsedInIface>
type:reflect.StructTag <UsedInIface> -> reflect.(*StructTag).Get
type:reflect.StructTag <UsedInIface> -> reflect.StructTag.Get
type:reflect.StructTag <UsedInIface> -> type:func(string) (string, bool) <UsedInIface>
type:reflect.StructTag <UsedInIface> -> reflect.(*StructTag).Lookup
type:reflect.StructTag <UsedInIface> -> reflect.StructTag.Lookup
type:reflect.Method <UsedInIface> -> reflect.(*Method).IsExported
type:reflect.Method <UsedInIface> -> reflect.Method.IsExported
type:*internal/abi.StructField <UsedInIface> -> internal/abi.(*StructField).Embedded
type:runtime.errorAddressString <UsedInIface> -> runtime.(*errorAddressString).Addr
type:runtime.errorAddressString <UsedInIface> -> runtime.errorAddressString.Addr
type:runtime.errorAddressString <UsedInIface> -> runtime.(*errorAddressString).Error
type:runtime.errorAddressString <UsedInIface> -> runtime.errorAddressString.Error
type:runtime.errorAddressString <UsedInIface> -> runtime.(*errorAddressString).RuntimeError
type:runtime.errorAddressString <UsedInIface> -> runtime.errorAddressString.RuntimeError
type:*syscall.DLLError <UsedInIface> -> syscall.(*DLLError).Error
type:*syscall.DLLError <UsedInIface> -> syscall.(*DLLError).Unwrap
type:*errors.errorString <UsedInIface> -> errors.(*errorString).Error
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> type:func(uintptr) uintptr <UsedInIface>
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> runtime/internal/atomic.(*Uintptr).Add
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> type:func(uintptr, uintptr) bool <UsedInIface>
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> runtime/internal/atomic.(*Uintptr).CompareAndSwap
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> runtime/internal/atomic.(*Uintptr).Load
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> runtime/internal/atomic.(*Uintptr).LoadAcquire
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> type:func(uintptr) <UsedInIface>
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> runtime/internal/atomic.(*Uintptr).Store
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> runtime/internal/atomic.(*Uintptr).StoreRelease
type:*runtime/internal/atomic.Uintptr <UsedInIface> -> runtime/internal/atomic.(*Uintptr).Swap
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Align
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.ArrayType
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.AssignableTo
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.ChanDir
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Common
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Comparable
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Elem
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.ExportedMethods
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.FieldAlign
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.FuncType
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.GcSlice
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.HasName
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.IfaceIndir
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Implements
type:internal/reflectlite.rtype <UsedInIface> -> type:func(int) internal/reflectlite.Type <UsedInIface>
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.In
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.InterfaceType
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.IsDirectIface
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Key
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Kind
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Len
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.MapType
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Name
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.NumField
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.NumIn
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.NumMethod
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.NumOut
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Out
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.PkgPath
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Pointers
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Size
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.String
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.StructType
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Uncommon
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.common
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Align
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).ArrayType
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).AssignableTo
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).ChanDir
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Common
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Comparable
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Elem
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).ExportedMethods
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).FieldAlign
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).FuncType
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).GcSlice
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).HasName
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).IfaceIndir
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Implements
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).In
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).InterfaceType
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).IsDirectIface
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Key
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Kind
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Len
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).MapType
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Name
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).NumField
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).NumIn
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).NumMethod
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).NumOut
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Out
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).PkgPath
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Pointers
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Size
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).String
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).StructType
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Uncommon
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).common
type:internal/abi.Kind <UsedInIface> -> internal/abi.(*Kind).String
type:internal/abi.Kind <UsedInIface> -> internal/abi.Kind.String
type:syscall.Errno <UsedInIface> -> syscall.(*Errno).Error
type:syscall.Errno <UsedInIface> -> type:func(error) bool <UsedInIface>
type:syscall.Errno <UsedInIface> -> syscall.(*Errno).Is
type:syscall.Errno <UsedInIface> -> syscall.Errno.Is
type:syscall.Errno <UsedInIface> -> syscall.(*Errno).Temporary
type:syscall.Errno <UsedInIface> -> syscall.Errno.Temporary
type:syscall.Errno <UsedInIface> -> syscall.(*Errno).Timeout
type:syscall.Errno <UsedInIface> -> syscall.Errno.Timeout
type:*io/fs.PathError <UsedInIface> -> io/fs.(*PathError).Error
type:*io/fs.PathError <UsedInIface> -> io/fs.(*PathError).Timeout
type:*io/fs.PathError <UsedInIface> -> io/fs.(*PathError).Unwrap
type:internal/poll.errNetClosing <UsedInIface> -> internal/poll.(*errNetClosing).Error
type:internal/poll.errNetClosing <UsedInIface> -> internal/poll.errNetClosing.Error
type:internal/poll.errNetClosing <UsedInIface> -> internal/poll.(*errNetClosing).Temporary
type:internal/poll.errNetClosing <UsedInIface> -> internal/poll.errNetClosing.Temporary
type:internal/poll.errNetClosing <UsedInIface> -> internal/poll.(*errNetClosing).Timeout
type:internal/poll.errNetClosing <UsedInIface> -> internal/poll.errNetClosing.Timeout
type:*internal/poll.DeadlineExceededError <UsedInIface> -> internal/poll.(*DeadlineExceededError).Error
type:*internal/poll.DeadlineExceededError <UsedInIface> -> internal/poll.(*DeadlineExceededError).Temporary
type:*internal/poll.DeadlineExceededError <UsedInIface> -> internal/poll.(*DeadlineExceededError).Timeout
fmt.(*pp).Write -> fmt.(*pp).Write.argliveinfo
reflect.Method.IsExported -> gclocals·Tp1t57buqZE58Vw6rmiEKQ==
reflect.Method.IsExported -> reflect.Method.IsExported.arginfo1
reflect.Kind.String -> reflect.kindNames
reflect.Kind.String -> go:string."kind"
reflect.(*rtype).Bits -> go:string."reflect: Bits of non-arithmetic Type "
reflect.(*rtype).Bits -> reflect..stmp_19
reflect.(*rtype).ChanDir -> go:string."reflect: ChanDir of non-chan type "
reflect.(*rtype).Field -> go:string."reflect: Field of non-struct type "
reflect.(*rtype).Field -> gclocals·kPN+rskHSbX2T0yozFmULA==
reflect.(*rtype).Field -> gclocals·GG075s6mNZRufjxoNa6w/A==
reflect.(*rtype).Field -> reflect.(*rtype).Field.arginfo1
reflect.(*rtype).Field -> reflect.(*rtype).Field.argliveinfo
reflect.(*rtype).FieldByIndex -> go:string."reflect: FieldByIndex of non-struct type "
reflect.(*rtype).FieldByIndex -> gclocals·xKtMtWO/dQkFxySuORsWDA==
reflect.(*rtype).FieldByIndex -> reflect.(*rtype).FieldByIndex.arginfo1
reflect.(*rtype).FieldByName -> go:string."reflect: FieldByName of non-struct type "
reflect.(*rtype).FieldByName -> reflect.(*rtype).FieldByName.arginfo1
reflect.(*rtype).FieldByNameFunc -> go:string."reflect: FieldByNameFunc of non-struct type "
reflect.(*rtype).Key -> go:string."reflect: Key of non-map type "
reflect.(*rtype).Len -> go:string."reflect: Len of non-array type "
reflect.(*rtype).NumField -> go:string."reflect: NumField of non-struct type "
reflect.(*rtype).In -> go:string."reflect: In of non-func type "
reflect.(*rtype).NumIn -> go:string."reflect: NumIn of non-func type "
reflect.(*rtype).NumOut -> go:string."reflect: NumOut of non-func type "
reflect.(*rtype).Out -> go:string."reflect: Out of non-func type "
reflect.(*rtype).IsVariadic -> go:string."reflect: IsVariadic of non-func type "
reflect.ChanDir.String -> go:string."chan"
reflect.ChanDir.String -> go:string."ChanDir"
reflect.ChanDir.String -> go:string."chan<-"
reflect.ChanDir.String -> go:string."<-chan"
reflect.StructField.IsExported -> gclocals·ug6kwuJINt+oAK9woQfnSQ==
reflect.StructTag.Lookup -> strconv.Unquote
reflect.(*structType).Field -> type:[1]int
reflect.(*structType).Field -> reflect..stmp_21
reflect.(*structType).Field -> gclocals·UqUUURq9HOSTycFsoejJQQ==
reflect.(*structType).Field -> gclocals·wMKsMSm8vf2VTD01jix48g==
reflect.(*structType).FieldByIndex -> gclocals·sFo39JkP93VJVVy7NTBzeg==
reflect.(*structType).FieldByIndex -> gclocals·k3h0KJhoA1MX3BCHBk6x0Q==
reflect.(*structType).FieldByIndex -> reflect.(*structType).FieldByIndex.argliveinfo
reflect.(*structType).FieldByNameFunc -> type:map[*reflect.structType]bool
reflect.(*structType).FieldByNameFunc -> runtime.mapaccess1_fast64
reflect.(*structType).FieldByNameFunc -> type:map[*reflect.structType]int
reflect.(*structType).FieldByNameFunc -> type:reflect.fieldScan
reflect.(*structType).FieldByNameFunc -> gclocals·bq83Xgy3XUTAoJ1TESpm1A==
reflect.(*structType).FieldByNameFunc -> gclocals·JsjD72Is608QyPGtwwWDbg==
reflect.(*structType).FieldByNameFunc -> reflect.(*structType).FieldByNameFunc.stkobj
reflect.(*structType).FieldByNameFunc -> reflect.(*structType).FieldByNameFunc.argliveinfo
reflect.(*structType).FieldByName -> reflect.(*structType).FieldByName.func1
reflect.(*structType).FieldByName -> gclocals·RNpvyaHd+Mr7T+qG4XaOTQ==
reflect.(*structType).FieldByName -> gclocals·Uy5exLTiXtZK7+T4DCwhmw==
reflect.(*structType).FieldByName -> reflect.(*structType).FieldByName.stkobj
reflect.(*rtype).Implements -> reflect..stmp_23
reflect.(*rtype).Implements -> reflect..stmp_22
reflect.(*rtype).AssignableTo -> reflect..stmp_24
reflect.(*rtype).ConvertibleTo -> reflect.convertOp
reflect.(*rtype).ConvertibleTo -> reflect..stmp_25
reflect.(*ValueError).Error -> go:string." Value"
reflect.(*ValueError).Error -> go:string."reflect: call of "
reflect.(*ValueError).Error -> go:string." on "
reflect.(*ValueError).Error -> go:string." on zero Value"
reflect.Value.Bool -> reflect.Value.panicNotBool
reflect.Value.CallSlice -> go:string."CallSlice"
reflect.Value.Cap -> reflect.Value.capNonSlice
reflect.Value.capNonSlice -> reflect.chancap
reflect.Value.capNonSlice -> reflect..stmp_91
reflect.Value.capNonSlice -> go:string."reflect.Value.Cap"
reflect.Value.Close -> reflect.chanclose
reflect.Value.Complex -> go:string."reflect.Value.Complex"
reflect.Value.FieldByIndex -> reflect..stmp_95
reflect.Value.FieldByIndex -> gclocals·3cKdRWSXKNgAxQIrnrKpSw==
reflect.Value.FieldByIndex -> gclocals·XdF65Vin57up1W/QwODy4w==
reflect.Value.FieldByIndexErr -> go:string."reflect: indirection through nil pointer to embedded struct field "
reflect.Value.FieldByIndexErr -> gclocals·8wWhwRKvhjvsf0yaKp+jpQ==
reflect.Value.FieldByIndexErr -> gclocals·5oUyK5ZFU8lY5d9IHla5iA==
reflect.Value.FieldByName -> gclocals·WY1FxagnKnSxcQ5g1aHsng==
reflect.Value.FieldByName -> gclocals·gcypoRG/H6ZhNQ2dPuX6DQ==
reflect.Value.FieldByNameFunc -> gclocals·O7/QEU5i1jj+n3RR8huWqg==
reflect.Value.Float -> go:string."reflect.Value.Float"
reflect.Value.CanInterface -> go:string."reflect.Value.CanInterface"
reflect.Value.InterfaceData -> gclocals·bgVMTrvDhYp81iY7HZhpyg==
reflect.Value.InterfaceData -> reflect.Value.InterfaceData.arginfo1
reflect.Value.InterfaceData -> fmt.Sscan.argliveinfo
reflect.Value.IsZero -> reflect.Value.IsZero.jump4
reflect.Value.IsZero -> go:string."reflect.Value.IsZero"
reflect.Value.SetZero -> reflect.Value.SetZero.jump9
reflect.Value.SetZero -> type:[2]unsafe.Pointer
reflect.Value.SetZero -> go:string."reflect.Value.SetZero"
reflect.Value.MapIndex -> reflect.mapaccess_faststr
reflect.Value.MapIndex -> go:string."reflect.Value.MapIndex"
reflect.Value.MapIndex -> reflect.mapaccess
reflect.Value.MapIndex -> gclocals·Rn1n2w5HaEl2AtPYXlNgWw==
reflect.Value.MapIndex -> gclocals·BvrhBr6Qez/6h8kln0WsBA==
reflect.Value.MapIndex -> reflect.Value.MapIndex.stkobj
reflect.Value.MapIndex -> reflect.Value.MapIndex.argliveinfo
reflect.Value.MapKeys -> gclocals·RkDlnkxLzwVuJIwOquCmoQ==
reflect.Value.MapKeys -> reflect.Value.MapKeys.stkobj
reflect.Value.SetIterKey -> go:string."reflect.MapIter.SetKey"
reflect.Value.SetIterKey -> reflect..stmp_109
reflect.Value.SetIterKey -> reflect..stmp_108
reflect.Value.SetIterKey -> gclocals·E3/rMdQ3bq220dCfl7TXdw==
reflect.Value.SetIterKey -> gclocals·ZKNZLrS17tuK5WdC0nLpBg==
reflect.Value.SetIterValue -> go:string."reflect.MapIter.SetValue"
reflect.Value.SetIterValue -> reflect..stmp_113
reflect.Value.SetIterValue -> reflect..stmp_112
reflect.Value.MapRange -> type:reflect.MapIter
reflect.Value.OverflowComplex -> $f64.47efffffe0000000
reflect.Value.OverflowComplex -> $f64.7fefffffffffffff
reflect.Value.OverflowComplex -> go:string."reflect.Value.OverflowComplex"
reflect.Value.OverflowFloat -> go:string."reflect.Value.OverflowFloat"
reflect.Value.OverflowInt -> go:string."reflect.Value.OverflowInt"
reflect.Value.OverflowUint -> go:string."reflect.Value.OverflowUint"
reflect.Value.Recv -> reflect.Value.recv
reflect.Value.recv -> reflect.chanrecv
reflect.Value.recv -> reflect..stmp_122
reflect.Value.recv -> gclocals·gWkmILAvoNsrzI/5Bn9pzA==
reflect.Value.recv -> gclocals·riGUhE6nQ8FPAVKs7LrMWg==
reflect.Value.Send -> reflect.Value.send
reflect.Value.Send -> gclocals·E721G/B1+5nwikO5Qrs+mg==
reflect.Value.send -> go:string."reflect.Value.Send"
reflect.Value.send -> reflect.chansend0
reflect.Value.send -> reflect..stmp_124
reflect.Value.send -> gclocals·FFqPWsGlG+9QULQPse6djA==
reflect.Value.send -> gclocals·MxE50+gBhVYFoJEAYNWjKg==
reflect.Value.SetBytes -> reflect..stmp_126
reflect.Value.SetBytes -> gclocals·WDeynuIEbPamG4iPa++61Q==
reflect.Value.SetBytes -> gclocals·VMOLbrMCWMVfYSO7xEqmGg==
reflect.Value.SetComplex -> go:string."reflect.Value.SetComplex"
reflect.Value.SetFloat -> go:string."reflect.Value.SetFloat"
reflect.Value.SetInt -> go:string."reflect.Value.SetInt"
reflect.Value.SetLen -> reflect..stmp_128
reflect.Value.SetCap -> reflect..stmp_129
reflect.Value.SetMapIndex -> reflect.mapdelete_faststr
reflect.Value.SetMapIndex -> go:string."reflect.Value.SetMapIndex"
reflect.Value.SetMapIndex -> reflect.mapassign_faststr
reflect.Value.SetMapIndex -> reflect.mapdelete
reflect.Value.SetMapIndex -> reflect.mapassign
reflect.Value.SetMapIndex -> gclocals·LJXPcLdaPUuier6alSVbxw==
reflect.Value.SetMapIndex -> gclocals·fPVC8Qbo/IlQKWIMQlK7ww==
reflect.Value.SetMapIndex -> reflect.Value.SetMapIndex.stkobj
reflect.Value.SetMapIndex -> reflect.Value.SetMapIndex.arginfo1
reflect.Value.SetMapIndex -> reflect.Value.SetMapIndex.argliveinfo
reflect.Value.SetUint -> go:string."reflect.Value.SetUint"
reflect.Value.Slice3 -> reflect..stmp_138
reflect.Value.Slice3 -> go:string."reflect.Value.Slice3"
reflect.Value.Slice3 -> reflect..stmp_137
reflect.Value.String -> reflect.Value.stringNonString
reflect.Value.stringNonString -> go:string." Value>"
reflect.Value.stringNonString -> go:string."<invalid Value>"
reflect.Value.UnsafeAddr -> reflect..stmp_141
reflect.Value.UnsafeAddr -> go:string."reflect.Value.UnsafeAddr"
reflect.Value.Grow -> reflect.Value.grow
reflect.Value.grow -> reflect.growslice
reflect.Value.grow -> reflect..stmp_146
reflect.Value.grow -> reflect..stmp_145
reflect.Value.Clear -> reflect.mapclear
reflect.Value.Clear -> reflect.typedarrayclear
reflect.Value.Clear -> go:string."reflect.Value.Clear"
reflect.Value.Convert -> go:string."Convert"
reflect.Value.Convert -> go:string." cannot be converted to type "
reflect.Value.Convert -> go:string."reflect.Value.Convert: value of type "
reflect.Value.Convert -> gclocals·i+ZediOBVgMVPAX71CbYLw==
reflect.Value.Convert -> gclocals·J6RPrFcVG6WuRczDqe02RA==
reflect.Value.CanConvert -> gclocals·FS/D2cNe/ke7CRSgkEdPDg==
reflect.Value.Equal -> reflect.Value.Equal.jump43
reflect.Value.Equal -> go:string." are not comparable"
reflect.Value.Equal -> go:string."reflect.Value.Equal: values of type "
reflect.Value.Equal -> reflect..stmp_170
reflect.Value.Equal -> gclocals·c2oEc7izQtpbx9TY4QoLDQ==
reflect.Value.Equal -> gclocals·NqS4Ab1RORUMpjKHiDGhjQ==
reflect.convertOp -> reflect.cvtIntString·f
reflect.convertOp -> reflect.cvtIntFloat·f
reflect.convertOp -> reflect.cvtInt·f
reflect.convertOp -> reflect.cvtUintString·f
reflect.convertOp -> reflect.cvtUintFloat·f
reflect.convertOp -> reflect.cvtUint·f
reflect.convertOp -> reflect.cvtFloat·f
reflect.convertOp -> reflect.cvtFloatUint·f
reflect.convertOp -> reflect.cvtFloatInt·f
reflect.convertOp -> reflect.cvtComplex·f
reflect.convertOp -> reflect.cvtDirect·f
reflect.convertOp -> reflect.cvtBytesString·f
reflect.convertOp -> reflect.cvtRunesString·f
reflect.convertOp -> reflect.cvtSliceArrayPtr·f
reflect.convertOp -> reflect.cvtSliceArray·f
reflect.convertOp -> reflect.cvtStringBytes·f
reflect.convertOp -> reflect.cvtStringRunes·f
reflect.convertOp -> reflect.cvtI2I·f
reflect.convertOp -> reflect.cvtT2I·f
reflect.convertOp -> gclocals·/ApVR8zVEIU215V4X/4E1w==
reflect.mapassign -> reflect.mapassign0
reflect.mapassign_faststr -> reflect.mapassign_faststr0
reflect.mapassign_faststr -> reflect.mapassign_faststr.arginfo1
type:reflect.MapIter -> type:.eqfunc.reflect.MapIter
type:reflect.MapIter -> type:.namedata.*reflect.MapIter.
type:reflect.MapIter -> type:*reflect.MapIter
type:reflect.MapIter -> type:.namedata.hiter-
type:reflect.MapIter -> type:reflect.hiter
type:reflect.hiter -> type:.eqfunc.reflect.hiter
type:reflect.hiter -> type:.namedata.*reflect.hiter-
type:reflect.hiter -> type:*reflect.hiter
type:reflect.hiter -> type:.namedata.h-
type:reflect.hiter -> type:.namedata.bptr-
type:reflect.hiter -> type:*[]unsafe.Pointer
type:reflect.hiter -> type:.namedata.startBucket-
type:reflect.hiter -> type:.namedata.wrapped-
type:reflect.hiter -> type:.namedata.i-
type:reflect.hiter -> type:.namedata.bucket-
type:reflect.hiter -> type:.namedata.checkBucket-
type:*reflect.hiter -> type:.namedata.initialized-
type:*reflect.MapIter -> type:.namedata.Reset.
reflect.kindNames -> reflect..stmp_0
reflect..stmp_0 -> go:string."invalid"
reflect..stmp_0 -> go:string."bool"
reflect..stmp_0 -> go:string."int"
reflect..stmp_0 -> go:string."int8"
reflect..stmp_0 -> go:string."int16"
reflect..stmp_0 -> go:string."int32"
reflect..stmp_0 -> go:string."int64"
reflect..stmp_0 -> go:string."uint"
reflect..stmp_0 -> go:string."uint8"
reflect..stmp_0 -> go:string."uint16"
reflect..stmp_0 -> go:string."uint32"
reflect..stmp_0 -> go:string."uint64"
reflect..stmp_0 -> go:string."uintptr"
reflect..stmp_0 -> go:string."float32"
reflect..stmp_0 -> go:string."float64"
reflect..stmp_0 -> go:string."complex64"
reflect..stmp_0 -> go:string."complex128"
reflect..stmp_0 -> go:string."array"
reflect..stmp_0 -> go:string."func"
reflect..stmp_0 -> go:string."interface"
reflect..stmp_0 -> go:string."map"
reflect..stmp_0 -> go:string."ptr"
reflect..stmp_0 -> go:string."slice"
reflect..stmp_0 -> go:string."string"
reflect..stmp_0 -> go:string."struct"
reflect..stmp_0 -> go:string."unsafe.Pointer"
type:reflect.fieldScan -> type:.namedata.*reflect.fieldScan-
type:reflect.fieldScan -> type:*reflect.fieldScan
type:reflect.fieldScan -> type:.namedata.index-
 -> go:info.reflect.Method.IsExported$abstract
 -> go:info.reflect.Kind.String$abstract
 -> go:info.reflect.ChanDir
 -> go:info.[]int
 -> go:info.func(string) bool
 -> go:info.*reflect.mapType
 -> go:info.reflect.StructTag.Get$abstract
 -> go:info.reflect.StructTag
 -> go:info.map[*reflect.structType]int
 -> go:info.map[*reflect.structType]bool
 -> go:info.[]reflect.fieldScan
 -> go:info.reflect.Value.CanSet$abstract
 -> go:info.reflect.Value.Cap$abstract
 -> go:info.reflect.Value.CanComplex$abstract
 -> go:info.reflect.Value.CanFloat$abstract
 -> go:info.reflect.Value.CanInt$abstract
 -> go:info.reflect.hiter
 -> go:info.reflect.Value.OverflowComplex$abstract
 -> go:info.reflect.overflowFloat32$abstract
 -> go:info.reflect.Value.OverflowFloat$abstract
 -> go:info.reflect.Value.OverflowInt$abstract
 -> go:info.reflect.Value.OverflowUint$abstract
 -> go:info.*reflect.Value
 -> go:info.reflect.chansend$abstract
 -> go:info.reflect.contentEscapes$abstract
 -> go:info.reflect.Value.CanUint$abstract
 -> go:info.reflect.Value.UnsafeAddr$abstract
 -> go:info.func(reflect.Value, reflect.Type) reflect.Value
 -> go:info.*errors.errorString
strconv.Unquote -> strconv.unquote
strconv.Unquote -> strconv.ErrSyntax
strconv.Unquote -> go:sehuw.12.AQoCBQoDB1AAAAAA
strconv.unquote -> unicode/utf8.ValidString
strconv.unquote -> strconv.UnquoteChar
strconv.unquote -> gclocals·cSS/VseaVV4dRtN7JC5GrA==
strconv.unquote -> gclocals·Mnrp/rLqAraLFWIGQvLk2Q==
strconv.ErrSyntax -> strconv..stmp_4
strconv..stmp_4 -> go:string."invalid syntax"
 -> go:info.strconv.unhex$abstract
 -> go:info.strconv.index$abstract
 -> go:info.strconv.contains$abstract
internal/fmtsort.(*SortedMap).Less -> internal/fmtsort.compare
internal/fmtsort.(*SortedMap).Less -> go:sehuw.12.AQoCBQoDB1AAAAAA
internal/fmtsort.(*SortedMap).Swap -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
internal/fmtsort.compare -> internal/fmtsort.compare.jump20
internal/fmtsort.compare -> internal/fmtsort.nilCompare
internal/fmtsort.compare -> go:string."bad type in compare: "
internal/fmtsort.compare -> gclocals·JUNxvMpjQNQGr4IkDegLuQ==
internal/fmtsort.compare -> gclocals·mUdSR61fodKakdfIFPJ2og==
 -> go:info.internal/fmtsort.floatCompare$abstract
 -> go:info.internal/fmtsort.isNaN$abstract
os.(*File).Readdir -> os.(*File).readdir
os.(*File).readdir -> internal/syscall/windows.GetVolumeInformationByHandle
os.(*File).readdir -> go:string."readdir"
os.(*File).readdir -> internal/syscall/windows.GetFileInformationByHandleEx
os.(*File).readdir -> io.EOF
os.(*File).readdir -> go:itab.os.dirEntry,io/fs.DirEntry
os.(*File).readdir -> type:os.fileStat
os.(*File).readdir -> type:io/fs.DirEntry
os.(*File).readdir -> type:io/fs.FileInfo
os.(*File).readdir -> go:itab.*os.fileStat,io/fs.FileInfo
os.(*File).readdir -> gclocals·Q0Wb7EGkHtRLq4q4tQBpmg==
os.(*File).readdir -> gclocals·cHDD2zPdcw0oFtcLvIiCQg==
os.(*File).readdir -> os.(*File).readdir.arginfo1
os.(*File).readdir -> go:sehuw.12.ARYCBRYDE1AAAAAA
io.EOF -> io..stmp_3
io..stmp_3 -> go:string."EOF"
os.(*File).Read -> go:string."read"
os.(*File).Read -> os.(*File).wrapErr
os.(*File).ReadAt -> go:string."negative offset"
os.(*File).ReadAt -> go:string."readat"
os.(*File).ReadAt -> gclocals·VN+mEfXAe8NqrJCiwYNvng==
os.(*File).ReadFrom -> os.genericReadFrom
os.genericReadFrom -> go:itab.os.fileWithoutReadFrom,io.Writer
os.genericReadFrom -> io.copyBuffer
io.copyBuffer -> type:io.WriterTo
io.copyBuffer -> runtime.assertI2I2
io.copyBuffer -> type:io.ReaderFrom
io.copyBuffer -> go:itab.*io.LimitedReader,io.Reader
io.copyBuffer -> io.errInvalidWrite
io.copyBuffer -> io.ErrShortWrite
io.copyBuffer -> gclocals·z0+xqukCCfSQm8pufPymgA==
io.copyBuffer -> gclocals·xGmDpdOmPu4MY/gZ0miesQ==
io.copyBuffer -> fmt.Fprintf.arginfo1
io.copyBuffer -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
io.ErrShortWrite -> io..stmp_0
io.errInvalidWrite -> io..stmp_1
io..stmp_0 -> go:string."short write"
io..stmp_1 -> go:string."invalid write result"
type:io.ReaderFrom -> type:.namedata.*io.ReaderFrom.
type:io.ReaderFrom -> type:*io.ReaderFrom
type:io.WriterTo -> type:.namedata.*io.WriterTo.
type:io.WriterTo -> type:*io.WriterTo
type:io.WriterTo -> type:func(io.Writer) (int64, error)
 -> go:info.io.Reader
 -> go:info.io.WriterTo
 -> go:info.io.ReaderFrom
 -> go:info.*io.LimitedReader
os.(*File).Write -> go:string."write"
os.(*File).WriteAt -> go:string."writeat"
os.(*File).WriteAt -> os.errWriteAtInAppendMode
os.(*File).Seek -> os.(*File).seek
os.(*File).Seek -> os..stmp_11
os.(*File).Seek -> go:string."seek"
os.(*File).wrapErr -> os.checkWrapErr
os.(*File).wrapErr -> errors.Is
os.(*File).wrapErr -> go:string."unexpected error wrapping poll.ErrFileClosing: "
os.(*File).wrapErr -> gclocals·o5BbmPP8dP74f0b1Y5J7zA==
errors.Is -> type:interface { Is(error) bool }
errors.Is -> type:interface { Unwrap() error }
errors.Is -> runtime.assertI2I
errors.Is -> type:interface { Unwrap() []error }
errors.Is -> gclocals·ksKcmP3RvRfgeC/brl/+UQ==
errors.Is -> gclocals·EbpWvhZ8s52U4mvGf6HjTA==
errors.Is -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
 -> go:info.interface { Is(error) bool }
 -> go:info.interface { Unwrap() error }
 -> go:info.interface { Unwrap() []error }
os.(*File).Chmod -> os.(*File).chmod
os.(*File).SetDeadline -> os.(*File).setDeadline
os.(*File).SetReadDeadline -> os.(*File).setReadDeadline
os.(*File).SetWriteDeadline -> os.(*File).setWriteDeadline
os.(*File).SyscallConn -> type:os.rawConn
os.(*File).SyscallConn -> go:itab.*os.rawConn,syscall.RawConn
os.(*File).chmod -> go:string."chmod"
os.(*File).Chown -> go:string."chown"
os.(*File).Truncate -> go:string."truncate"
os.(*File).Sync -> go:string."sync"
os.(*File).Chdir -> go:string."chdir"
os.(*File).setDeadline -> internal/poll.setDeadlineImpl
os.(*File).Stat -> os.statHandle
os.statHandle -> os.basename
os.statHandle -> os.newFileStatFromGetFileInformationByHandle
os.statHandle -> gclocals·XTwJIGq7Cn6f/PgGkbaWCQ==
os.statHandle -> gclocals·2BQlZctc2lt+9WCVI0G/lQ==
os.basename -> go:string."."
os.basename -> go:sehuw.12.AQQCBQQDAVAAAAAA
os.newFileStatFromGetFileInformationByHandle -> syscall.GetFileInformationByHandle
os.newFileStatFromGetFileInformationByHandle -> gclocals·7A43dxBtsv3TPes3VmyPYQ==
os.newFileStatFromGetFileInformationByHandle -> go:sehuw.12.ARMCBRMDEFAAAAAA
type:os.fileStat -> type:.eqfunc.os.fileStat
type:os.fileStat -> runtime.gcbits.0102000000000000
type:os.fileStat -> type:.namedata.*os.fileStat-
type:os.fileStat -> type:*os.fileStat <UsedInIface>
type:os.fileStat -> type:.namedata.FileAttributes.
type:os.fileStat -> type:.namedata.CreationTime.
type:os.fileStat -> type:syscall.Filetime
type:os.fileStat -> type:.namedata.LastAccessTime.
type:os.fileStat -> type:.namedata.LastWriteTime.
type:os.fileStat -> type:.namedata.FileSizeHigh.
type:os.fileStat -> type:.namedata.FileSizeLow.
type:os.fileStat -> type:.namedata.ReparseTag.
type:os.fileStat -> type:.namedata.filetype-
type:os.fileStat -> type:.namedata.Mutex..embedded
type:os.fileStat -> type:.namedata.path-
type:os.fileStat -> type:.namedata.idxhi-
type:os.fileStat -> type:.namedata.idxlo-
type:*os.fileStat <UsedInIface> -> type:os.fileStat <UsedInIface>
type:*os.fileStat <UsedInIface> -> type:.namedata.IsDir.
type:*os.fileStat <UsedInIface> -> type:.namedata.ModTime.
type:*os.fileStat <UsedInIface> -> type:.namedata.Mode.
type:*os.fileStat <UsedInIface> -> type:.namedata.Sys.
type:*os.fileStat <UsedInIface> -> type:.namedata.isSymlink-
type:*os.fileStat <UsedInIface> -> type:.namedata.loadFileId-
type:*os.fileStat <UsedInIface> -> type:.namedata.reflect.0
type:*os.fileStat <UsedInIface> -> type:.namedata.saveInfoFromPath-
type:*os.fileStat <UsedInIface> -> type:.namedata.reflect.1
type:os.fileStat <UsedInIface> -> type:syscall.Filetime <UsedInIface>
type:os.rawConn -> type:.namedata.*os.rawConn-
type:os.rawConn -> type:*os.rawConn <UsedInIface>
type:*os.rawConn <UsedInIface> -> type:os.rawConn <UsedInIface>
os.errWriteAtInAppendMode -> os..stmp_3
os..stmp_3 -> go:string."os: invalid use of WriteAt on file opened with O_APPEND"
 -> go:info.[]io/fs.FileInfo
 -> go:info.[]io/fs.DirEntry
 -> go:info.os.readdirMode
 -> go:info.io/fs.FileInfo
 -> go:info.*os.fileStat
 -> go:info.os.newFileStatFromFileIDBothDirInfo$abstract
 -> go:info.os.(*File).Name$abstract
 -> go:info.os.(*File).checkValid$abstract
 -> go:info.os.(*File).read$abstract
 -> go:info.os.(*File).pread$abstract
 -> go:info.io.Copy$abstract
 -> go:info.os.(*File).write$abstract
 -> go:info.os.(*File).pwrite$abstract
 -> go:info.os.(*File).WriteString$abstract
 -> go:info.os.(*File).Chmod$abstract
 -> go:info.os.(*File).SetDeadline$abstract
 -> go:info.os.(*File).SetReadDeadline$abstract
 -> go:info.os.(*File).SetWriteDeadline$abstract
 -> go:info.os.(*File).SyscallConn$abstract
 -> go:info.syscall.RawConn
 -> go:info.os.newRawConn$abstract
 -> go:info.os.(*File).Close$abstract
 -> go:info.io/fs.FileMode
 -> go:info.os.syscallMode$abstract
 -> go:info.io/fs.FileMode.Perm$abstract
 -> go:info.time.Time
 -> go:info.internal/poll.(*FD).SetDeadline$abstract
 -> go:info.internal/poll.(*FD).SetReadDeadline$abstract
 -> go:info.internal/poll.(*FD).SetWriteDeadline$abstract
 -> go:info.os.(*File).Fd$abstract
 -> go:info.syscall.ByHandleFileInformation
 -> go:info.internal/syscall/windows.FILE_ATTRIBUTE_TAG_INFO
 -> go:info.sync.(*Mutex).TryLock$abstract
internal/abi.(*RegArgs).Dump -> go:string."Ints:"
internal/abi.(*RegArgs).Dump -> go:string."Floats:"
internal/abi.(*RegArgs).Dump -> go:string."Ptrs:"
internal/abi.(*RegArgs).Dump -> gclocals·zX3VqyhCTbPONdupNM+FXw==
internal/abi.(*RegArgs).Dump -> go:sehuw.12.ARYCBRYDE1AAAAAA
internal/abi.Kind.String -> internal/abi.kindNames
internal/abi.(*Type).Uncommon -> internal/abi.(*Type).Uncommon.jump6
internal/abi.Name.DataChecked -> internal/abi.Name.DataChecked.arginfo1
internal/abi.kindNames -> internal/abi..stmp_0
 -> go:info.internal/abi.Kind.String$abstract
 -> go:info.internal/abi.(*Type).IsDirectIface$abstract
 -> go:info.internal/abi.(*Type).Common$abstract
 -> go:info.internal/abi.ChanDir
 -> go:info.internal/abi.(*Type).StructType$abstract
 -> go:info.internal/abi.(*Type).MapType$abstract
 -> go:info.internal/abi.(*Type).ArrayType$abstract
 -> go:info.internal/abi.(*Type).FuncType$abstract
 -> go:info.internal/abi.(*Type).InterfaceType$abstract
 -> go:info.internal/abi.(*Type).FieldAlign$abstract
runtime.(*TypeAssertionError).Error -> go:string."interface conversion: "
runtime.(*TypeAssertionError).Error -> go:string." is "
runtime.(*TypeAssertionError).Error -> go:string.", not "
runtime.(*TypeAssertionError).Error -> runtime.rtype.pkgpath
runtime.(*TypeAssertionError).Error -> go:string." (types from different packages)"
runtime.(*TypeAssertionError).Error -> go:string." (types from different scopes)"
runtime.(*TypeAssertionError).Error -> go:string." is not "
runtime.(*TypeAssertionError).Error -> go:string.": missing method "
runtime.(*TypeAssertionError).Error -> go:string." is nil, not "
runtime.(*TypeAssertionError).Error -> gclocals·moM9VDCWT3RGVMLx5zFJhQ==
runtime.(*TypeAssertionError).Error -> gclocals·TvBahjg8QFllbt4WzXKGmg==
runtime.errorString.Error -> go:string."runtime error: "
runtime.errorAddressString.RuntimeError -> runtime.errorAddressString.RuntimeError.arginfo1
runtime.boundsError.RuntimeError -> runtime.boundsError.RuntimeError.arginfo1
runtime.boundsError.Error -> runtime.boundsErrorFmts
runtime.boundsError.Error -> runtime.boundsNegErrorFmts
runtime.lockRank.String -> runtime.lockNames
runtime.lockRank.String -> go:string."BAD RANK"
runtime.lockRank.String -> go:string."LEAF"
runtime.lockRank.String -> go:string."UNKNOWN"
runtime.(*PanicNilError).Error -> go:string."panic called with nil argument"
runtime.rtype.pkgpath -> runtime.rtype.pkgpath.jump7
runtime.boundsErrorFmts -> go:string."index out of range [%x] with length %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [:%x] with length %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [:%x] with capacity %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [%x:%y]"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [::%x] with length %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [::%x] with capacity %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [:%x:%y]"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [%x:%y:]"
runtime.boundsErrorFmts -> go:string."cannot convert slice with length %y to array or pointer to array with length %x"
 -> go:info.[9]string
runtime.boundsNegErrorFmts -> go:string."index out of range [%x]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [:%x]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [%x:]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [::%x]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [:%x:]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [%x::]"
 -> go:info.[8]string
runtime.lockNames -> runtime..stmp_5
runtime..stmp_5 -> go:string."sysmon"
runtime..stmp_5 -> go:string."scavenge"
runtime..stmp_5 -> go:string."forcegc"
runtime..stmp_5 -> go:string."defer"
runtime..stmp_5 -> go:string."sweepWaiters"
runtime..stmp_5 -> go:string."assistQueue"
runtime..stmp_5 -> go:string."sweep"
runtime..stmp_5 -> go:string."pollDesc"
runtime..stmp_5 -> go:string."cpuprof"
runtime..stmp_5 -> go:string."sched"
runtime..stmp_5 -> go:string."allg"
runtime..stmp_5 -> go:string."allp"
runtime..stmp_5 -> go:string."timers"
runtime..stmp_5 -> go:string."netpollInit"
runtime..stmp_5 -> go:string."hchan"
runtime..stmp_5 -> go:string."notifyList"
runtime..stmp_5 -> go:string."sudog"
runtime..stmp_5 -> go:string."rwmutexW"
runtime..stmp_5 -> go:string."rwmutexR"
runtime..stmp_5 -> go:string."root"
runtime..stmp_5 -> go:string."itab"
runtime..stmp_5 -> go:string."reflectOffs"
runtime..stmp_5 -> go:string."userArenaState"
runtime..stmp_5 -> go:string."traceBuf"
runtime..stmp_5 -> go:string."traceStrings"
runtime..stmp_5 -> go:string."fin"
runtime..stmp_5 -> go:string."gcBitsArenas"
runtime..stmp_5 -> go:string."mheapSpecial"
runtime..stmp_5 -> go:string."mspanSpecial"
runtime..stmp_5 -> go:string."spanSetSpine"
runtime..stmp_5 -> go:string."profInsert"
runtime..stmp_5 -> go:string."profBlock"
runtime..stmp_5 -> go:string."profMemActive"
runtime..stmp_5 -> go:string."profMemFuture"
runtime..stmp_5 -> go:string."gscan"
runtime..stmp_5 -> go:string."stackpool"
runtime..stmp_5 -> go:string."stackLarge"
runtime..stmp_5 -> go:string."hchanLeaf"
runtime..stmp_5 -> go:string."wbufSpans"
runtime..stmp_5 -> go:string."mheap"
runtime..stmp_5 -> go:string."globalAlloc"
runtime..stmp_5 -> go:string."trace"
runtime..stmp_5 -> go:string."traceStackTab"
runtime..stmp_5 -> go:string."deadlock"
runtime..stmp_5 -> go:string."raceFini"
 -> go:info.runtime.errorString.RuntimeError$abstract
 -> go:info.runtime.errorString.Error$abstract
 -> go:info.runtime.errorAddressString.RuntimeError$abstract
 -> go:info.runtime.errorAddressString.Error$abstract
 -> go:info.runtime.errorAddressString.Addr$abstract
 -> go:info.runtime.plainError.RuntimeError$abstract
 -> go:info.runtime.plainError.Error$abstract
 -> go:info.runtime.boundsError.RuntimeError$abstract
 -> go:info.runtime.boundsError
 -> go:info.runtime.appendIntStr$abstract
 -> go:info.runtime.lockRank.String$abstract
 -> go:info.runtime.rtype.uncommon$abstract
internal/reflectlite.rtype.String -> internal/reflectlite.resolveNameOff
internal/reflectlite.rtype.String -> go:sehuw.12.AQoCBQoDB1AAAAAA
internal/reflectlite.rtype.NumMethod -> internal/reflectlite.rtype.exportedMethods
internal/reflectlite.rtype.exportedMethods -> internal/reflectlite.rtype.exportedMethods.jump7
internal/reflectlite.rtype.exportedMethods -> go:sehuw.12.AQQCBQQDAVAAAAAA
internal/reflectlite.rtype.PkgPath -> internal/reflectlite.rtype.PkgPath.jump9
internal/reflectlite.rtype.PkgPath -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
internal/reflectlite.rtype.Elem -> internal/reflectlite.elem
internal/reflectlite.rtype.In -> internal/reflectlite..stmp_1
internal/reflectlite.rtype.Key -> internal/reflectlite..stmp_2
internal/reflectlite.rtype.Len -> internal/reflectlite..stmp_3
internal/reflectlite.rtype.NumField -> internal/reflectlite..stmp_4
internal/reflectlite.rtype.NumIn -> internal/reflectlite..stmp_5
internal/reflectlite.rtype.NumOut -> internal/reflectlite..stmp_6
internal/reflectlite.rtype.Out -> internal/reflectlite..stmp_7
internal/reflectlite.rtype.Implements -> internal/reflectlite.implements
internal/reflectlite.rtype.Implements -> gclocals·bdRGhTu3N4Ox9FV5PE/puw==
internal/reflectlite.rtype.Implements -> os.fileWithoutReadFrom.WriteString.arginfo1
internal/reflectlite.rtype.AssignableTo -> internal/reflectlite.directlyAssignable
internal/reflectlite.implements -> internal/reflectlite.implements.jump50
internal/reflectlite.implements -> internal/reflectlite.resolveTypeOff
internal/reflectlite.implements -> internal/reflectlite.pkgPath
internal/reflectlite.implements -> gclocals·yPAHB9AHKX8/8+cJ21DshA==
internal/reflectlite.implements -> gclocals·WSxmXbbJIfisSnU0fWue5g==
internal/reflectlite.implements -> go:sehuw.12.ARMCBRMDEFAAAAAA
internal/reflectlite.pkgPath -> internal/reflectlite.name.name
internal/reflectlite.directlyAssignable -> internal/reflectlite.haveIdenticalUnderlyingType
internal/reflectlite.haveIdenticalUnderlyingType -> internal/reflectlite.haveIdenticalType
 -> go:info.internal/reflectlite.name
 -> go:info.internal/reflectlite.name.readVarint$abstract
 -> go:info.internal/reflectlite.name.data$abstract
 -> go:info.internal/reflectlite.add$abstract
 -> go:info.internal/reflectlite.rtype
 -> go:info.internal/reflectlite.rtype.nameOff$abstract
 -> go:info.internal/reflectlite.rtype.common$abstract
 -> go:info.internal/reflectlite.rtype.uncommon$abstract
 -> go:info.internal/reflectlite.rtype.Key$abstract
 -> go:info.internal/reflectlite.rtype.Len$abstract
 -> go:info.internal/reflectlite.rtype.NumField$abstract
 -> go:info.internal/reflectlite.rtype.NumIn$abstract
 -> go:info.internal/reflectlite.rtype.NumOut$abstract
 -> go:info.internal/reflectlite.rtype.Comparable$abstract
 -> go:info.internal/reflectlite.rtype.typeOff$abstract
io/fs.(*PathError).Error -> go:sehuw.12.AQoCBQoDB1AAAAAA
io/fs.(*PathError).Timeout -> type:interface { Timeout() bool }
type:io/fs.FileInfo -> type:.namedata.*fs.FileInfo.
type:io/fs.FileInfo -> type:*io/fs.FileInfo
type:io/fs.FileInfo -> type:func() time.Time <UsedInIface>
type:io/fs.FileInfo -> type:func() io/fs.FileMode <UsedInIface>
type:io/fs.DirEntry -> type:.namedata.*fs.DirEntry.
type:io/fs.DirEntry -> type:*io/fs.DirEntry
type:io/fs.DirEntry -> type:.namedata.Info.
 -> go:info.interface { Timeout() bool }
internal/syscall/windows.GetFileInformationByHandleEx -> internal/syscall/windows.procGetFileInformationByHandleEx
internal/syscall/windows.GetFileInformationByHandleEx -> syscall.Syscall6
internal/syscall/windows.GetFileInformationByHandleEx -> gclocals·1wnfCjZB9FTq/0ANldgVNg==
internal/syscall/windows.GetFileInformationByHandleEx -> internal/syscall/windows.SetTokenInformation.arginfo1
internal/syscall/windows.GetVolumeInformationByHandle -> internal/syscall/windows.procGetVolumeInformationByHandleW
internal/syscall/windows.GetVolumeInformationByHandle -> gclocals·D8fTTaWbUbmBGbXZ85/xXw==
internal/syscall/windows.GetVolumeInformationByHandle -> gclocals·240QvqdiwsTRxLf+9zJtsg==
internal/syscall/windows.GetVolumeInformationByHandle -> internal/syscall/windows.GetVolumeInformationByHandle.stkobj
internal/syscall/windows.GetVolumeInformationByHandle -> internal/syscall/windows.GetVolumeInformationByHandle.arginfo1
internal/syscall/windows.GetVolumeInformationByHandle -> internal/syscall/windows.GetVolumeInformationByHandle.argliveinfo
internal/syscall/windows.GetVolumeInformationByHandle -> go:sehuw.12.ARMCBRMDEFAAAAAA
syscall.Errno.Is -> errors.ErrUnsupported
errors.ErrUnsupported -> errors..stmp_0
errors..stmp_0 -> go:string."unsupported operation"
syscall.(*RawSockaddrAny).Sockaddr -> type:syscall.SockaddrUnix
syscall.(*RawSockaddrAny).Sockaddr -> type:syscall.SockaddrInet6
syscall.(*RawSockaddrAny).Sockaddr -> go:itab.*syscall.SockaddrInet6,syscall.Sockaddr
syscall.(*RawSockaddrAny).Sockaddr -> syscall..stmp_184
syscall.(*RawSockaddrAny).Sockaddr -> type:syscall.SockaddrInet4
syscall.(*RawSockaddrAny).Sockaddr -> go:itab.*syscall.SockaddrInet4,syscall.Sockaddr
syscall.(*RawSockaddrAny).Sockaddr -> go:itab.*syscall.SockaddrUnix,syscall.Sockaddr
syscall.GetFileInformationByHandle -> syscall.procGetFileInformationByHandle
type:syscall.SockaddrUnix -> type:.eqfunc.syscall.SockaddrUnix
type:syscall.SockaddrUnix -> type:.namedata.*syscall.SockaddrUnix.
type:syscall.SockaddrUnix -> type:*syscall.SockaddrUnix <UsedInIface>
type:syscall.SockaddrUnix -> type:syscall.RawSockaddrUnix
type:syscall.RawSockaddrUnix -> type:.eqfunc110
type:syscall.RawSockaddrUnix -> type:.namedata.*syscall.RawSockaddrUnix.
type:syscall.RawSockaddrUnix -> type:*syscall.RawSockaddrUnix
type:syscall.RawSockaddrUnix -> type:[108]int8
type:*syscall.SockaddrUnix <UsedInIface> -> type:syscall.SockaddrUnix <UsedInIface>
type:syscall.SockaddrUnix <UsedInIface> -> type:syscall.RawSockaddrUnix <UsedInIface>
type:syscall.RawSockaddrUnix <UsedInIface> -> type:*syscall.RawSockaddrUnix <UsedInIface>
type:syscall.RawSockaddrUnix <UsedInIface> -> type:[108]int8 <UsedInIface>
type:syscall.SockaddrInet4 -> type:.eqfunc.syscall.SockaddrInet4
type:syscall.SockaddrInet4 -> type:.namedata.*syscall.SockaddrInet4.
type:syscall.SockaddrInet4 -> type:*syscall.SockaddrInet4 <UsedInIface>
type:syscall.SockaddrInet4 -> type:.namedata.Port.
type:syscall.SockaddrInet4 -> type:syscall.RawSockaddrInet4
type:syscall.RawSockaddrInet4 -> type:.namedata.*syscall.RawSockaddrInet4.
type:syscall.RawSockaddrInet4 -> type:*syscall.RawSockaddrInet4
type:syscall.RawSockaddrInet4 -> type:.namedata.Zero.
type:*syscall.SockaddrInet4 <UsedInIface> -> type:syscall.SockaddrInet4 <UsedInIface>
type:syscall.SockaddrInet4 <UsedInIface> -> type:[4]uint8 <UsedInIface>
type:syscall.SockaddrInet4 <UsedInIface> -> type:syscall.RawSockaddrInet4 <UsedInIface>
type:syscall.RawSockaddrInet4 <UsedInIface> -> type:*syscall.RawSockaddrInet4 <UsedInIface>
type:syscall.RawSockaddrInet4 <UsedInIface> -> type:[8]uint8 <UsedInIface>
type:syscall.SockaddrInet6 -> type:.namedata.*syscall.SockaddrInet6.
type:syscall.SockaddrInet6 -> type:*syscall.SockaddrInet6 <UsedInIface>
type:syscall.SockaddrInet6 -> type:.namedata.ZoneId.
type:syscall.SockaddrInet6 -> type:[16]uint8
type:syscall.SockaddrInet6 -> type:syscall.RawSockaddrInet6
type:syscall.RawSockaddrInet6 -> type:.eqfunc28
type:syscall.RawSockaddrInet6 -> type:.namedata.*syscall.RawSockaddrInet6.
type:syscall.RawSockaddrInet6 -> type:*syscall.RawSockaddrInet6
type:syscall.RawSockaddrInet6 -> type:.namedata.Flowinfo.
type:syscall.RawSockaddrInet6 -> type:.namedata.Scope_id.
type:*syscall.SockaddrInet6 <UsedInIface> -> type:syscall.SockaddrInet6 <UsedInIface>
type:syscall.SockaddrInet6 <UsedInIface> -> type:[16]uint8 <UsedInIface>
type:syscall.SockaddrInet6 <UsedInIface> -> type:syscall.RawSockaddrInet6 <UsedInIface>
type:syscall.RawSockaddrInet6 <UsedInIface> -> type:*syscall.RawSockaddrInet6 <UsedInIface>
type:syscall.Filetime <UsedInIface> -> type:.namedata.*syscall.Filetime.
type:syscall.Filetime <UsedInIface> -> type:*syscall.Filetime <UsedInIface>
type:syscall.Filetime <UsedInIface> -> type:.namedata.LowDateTime.
type:syscall.Filetime <UsedInIface> -> type:.namedata.HighDateTime.
type:*syscall.Filetime <UsedInIface> -> type:.namedata.Nanoseconds.
 -> go:info.syscall.Errno.Temporary$abstract
 -> go:info.syscall.Errno.Timeout$abstract
 -> go:info.*syscall.RawSockaddrAny
 -> go:info.syscall.Sockaddr
 -> go:info.*syscall.RawSockaddrUnix
 -> go:info.*syscall.SockaddrUnix
 -> go:info.*syscall.RawSockaddrInet4
 -> go:info.*syscall.SockaddrInet4
 -> go:info.*syscall.RawSockaddrInet6
 -> go:info.*syscall.SockaddrInet6
 -> go:info.*syscall.ByHandleFileInformation
internal/poll.errNetClosing.Error -> go:string."use of closed network connection"
internal/poll.errNetClosing.Error -> runtime.msigrestore.arginfo1
internal/poll.(*DeadlineExceededError).Error -> go:string."i/o timeout"
internal/poll.(*FD).Fsync -> internal/poll.(*FD).Fsync.func1
internal/poll.(*FD).Fsync -> syscall.FlushFileBuffers
internal/poll.(*FD).Fsync -> gclocals·Q62/kL4sFPQBFbah8rfC9g==
syscall.FlushFileBuffers -> syscall.procFlushFileBuffers
internal/poll.(*FD).Fsync.func1 -> internal/poll.(*FD).decref.wrapinfo
internal/poll.setDeadlineImpl -> time.Until
internal/poll.setDeadlineImpl -> internal/poll.setDeadlineImpl.func1
internal/poll.setDeadlineImpl -> internal/poll.runtime_pollSetDeadline
internal/poll.setDeadlineImpl -> gclocals·zm4hEqGHSGPvRsCyjT05Qw==
internal/poll.setDeadlineImpl -> internal/poll.setDeadlineImpl.stkobj
internal/poll.(*FD).Shutdown -> internal/poll.(*FD).Shutdown.func1
internal/poll.(*FD).Shutdown -> syscall.shutdown
syscall.shutdown -> syscall.procshutdown
internal/poll.(*FD).Fchown -> internal/poll.(*FD).Fchown.func2
internal/poll.(*FD).Fchown -> os..stmp_8
internal/poll.(*FD).Fchown -> os..stmp_12
internal/poll.(*FD).Ftruncate -> internal/poll.(*FD).Ftruncate.func2
internal/poll.(*FD).Ftruncate -> syscall.Ftruncate
internal/poll.(*FD).Ftruncate -> gclocals·jBpdOJ5nbO3h+OgbPSp5Ow==
syscall.Ftruncate -> syscall.Seek
syscall.Ftruncate -> syscall.Ftruncate.func1
syscall.Ftruncate -> syscall.SetEndOfFile
syscall.Ftruncate -> gclocals·R5SWaop7c7zB9DePkRuTgg==
syscall.Ftruncate -> syscall.StringToSid.opendefer
syscall.Seek -> syscall.setFilePointerEx
syscall.setFilePointerEx -> syscall.procSetFilePointerEx
syscall.Ftruncate.func1 -> syscall.Seek.wrapinfo
syscall.SetEndOfFile -> syscall.procSetEndOfFile
internal/poll.(*FD).RawControl -> internal/poll.(*FD).RawControl.func1
internal/poll.(*operation).InitMsg -> gclocals·rWjIF7y3DrTljMawkfzhcA==
internal/poll.(*operation).InitMsg -> reflect.(*Value).SetMapIndex.arginfo1
internal/poll.(*FD).Read -> internal/poll.(*fdMutex).rwlock
internal/poll.(*FD).Read -> internal/poll.(*FD).Read.func2
internal/poll.(*FD).Read -> internal/poll.(*FD).Read.func3
internal/poll.(*FD).Read -> internal/poll.(*FD).readConsole
internal/poll.(*FD).Read -> syscall.Read
internal/poll.(*FD).Read -> internal/poll..stmp_32
internal/poll.(*FD).Read -> internal/poll.(*FD).Read.func1·f
internal/poll.(*FD).Read -> internal/poll.execIO
internal/poll.(*FD).Read -> gclocals·fJ2fssT/loo5l9G+LIW3DQ==
internal/poll.(*FD).Read -> gclocals·3szfztO9PeArcU0HRiPyrQ==
internal/poll.(*FD).Read -> internal/poll.(*FD).Read.opendefer
internal/poll.(*FD).Read -> go:sehuw.12.ARMCBRMDEFAAAAAA
syscall.Read -> syscall.readFile
syscall.Read -> syscall..stmp_176
syscall.readFile -> syscall.procReadFile
syscall.readFile -> gclocals·DRzWvZ6nURNV2uTID/0tkw==
 -> go:info.syscall.ReadFile$abstract
internal/poll.execIO -> internal/poll.(*pollDesc).prepare
internal/poll.execIO -> internal/poll..stmp_28
internal/poll.execIO -> internal/poll.(*pollDesc).wait
internal/poll.execIO -> internal/poll..stmp_31
internal/poll.execIO -> internal/poll.runtime_pollWaitCanceled
internal/poll.execIO -> os..stmp_33
internal/poll.execIO -> internal/poll..stmp_30
internal/poll.execIO -> go:string."internal error: polling on unsupported descriptor type"
internal/poll.execIO -> go:string."unexpected runtime.netpoll error: "
internal/poll.execIO -> gclocals·pVhK5KKXVYtPsGS9j7U2Ng==
internal/poll.execIO -> gclocals·ro3E6oUma4doVA+ZghCPBw==
internal/poll.(*pollDesc).prepare -> internal/poll.runtime_pollReset
internal/poll.(*pollDesc).prepare -> internal/poll.ErrNotPollable
internal/poll.(*pollDesc).prepare -> go:string."unreachable:  "
internal/poll.(*pollDesc).prepare -> os..stmp_10
internal/poll.(*pollDesc).wait -> internal/poll.runtime_pollWait
internal/poll.(*pollDesc).wait -> go:string."waiting for unsupported file type"
internal/poll.(*FD).Read.func2 -> internal/poll.(*FD).readUnlock
internal/poll.(*FD).Read.func2 -> internal/poll.(*FD).readUnlock.wrapinfo
internal/poll.(*FD).readUnlock -> internal/poll.(*fdMutex).rwunlock
internal/poll.(*FD).readConsole -> internal/poll.ReadConsole
internal/poll.(*FD).readConsole -> gclocals·xazDy8522vSaZq7VTN98Ow==
internal/poll.(*FD).Pread -> internal/poll..stmp_35
internal/poll.(*FD).Pread -> internal/poll.(*FD).Pread.func1
internal/poll.(*FD).Pread -> internal/poll.(*FD).Pread.func2
internal/poll.(*FD).Pread -> internal/poll.(*FD).Pread.func3
internal/poll.(*FD).Pread -> internal/poll..stmp_37
internal/poll.(*FD).Pread -> gclocals·HK34pFzpFfWWlKX5uYqoDA==
internal/poll.(*FD).Pread -> gclocals·OD1yRrPHDbjXOM7u0nJuRA==
internal/poll.(*FD).Pread -> internal/poll.(*FD).Pread.stkobj
internal/poll.(*FD).Pread -> internal/poll.(*FD).Pread.opendefer
internal/poll.(*FD).Pread -> internal/syscall/windows.DuplicateTokenEx.argliveinfo
internal/poll.(*FD).ReadFrom -> internal/poll.(*FD).ReadFrom.func2
internal/poll.(*FD).ReadFrom -> internal/poll.(*FD).ReadFrom.func1·f
internal/poll.(*FD).ReadFrom -> gclocals·JlX6uNsOmmW7g77v09so6Q==
internal/poll.(*FD).ReadFrom -> internal/poll.(*FD).ReadFrom.opendefer
internal/poll.(*FD).ReadFromInet4 -> internal/poll.(*FD).ReadFromInet4.func2
internal/poll.(*FD).ReadFromInet4 -> internal/poll.(*FD).ReadFromInet4.func1·f
internal/poll.(*FD).ReadFromInet4 -> gclocals·12kyBB35oyf4s39G5O7jJw==
internal/poll.(*FD).ReadFromInet4 -> gclocals·7fG+bhMFkNCjolVFV0b7tQ==
internal/poll.(*FD).ReadFromInet4 -> internal/poll.(*FD).ReadFromInet4.argliveinfo
internal/poll.(*FD).ReadFromInet6 -> internal/poll.(*FD).ReadFromInet6.func2
internal/poll.(*FD).ReadFromInet6 -> internal/poll.(*FD).ReadFromInet6.func1·f
internal/poll.(*FD).Write -> internal/poll.(*FD).Write.func2
internal/poll.(*FD).Write -> internal/poll.(*FD).Write.func3
internal/poll.(*FD).Write -> internal/poll.(*FD).writeConsole
internal/poll.(*FD).Write -> syscall.Write
internal/poll.(*FD).Write -> internal/poll.(*FD).Write.func1·f
internal/poll.(*FD).Write -> gclocals·WCe8tWJVteAuS+RsojANWQ==
internal/poll.(*FD).Write -> internal/poll.(*FD).Write.opendefer
syscall.Write -> syscall.writeFile
syscall.writeFile -> syscall.procWriteFile
 -> go:info.syscall.WriteFile$abstract
internal/poll.(*FD).Write.func2 -> internal/poll.(*FD).writeUnlock
internal/poll.(*FD).Write.func2 -> internal/poll.(*FD).writeUnlock.wrapinfo
internal/poll.(*FD).writeConsole -> unicode/utf16.Encode
internal/poll.(*FD).writeConsole -> syscall.WriteConsole
internal/poll.(*FD).writeConsole -> gclocals·Lk/xCIw8kWDZUagayW3pdg==
internal/poll.(*FD).writeConsole -> gclocals·DU0ZQVf3+g3zAiH2WQnE7g==
internal/poll.(*FD).writeConsole -> go:sehuw.12.ARYCBRYDE1AAAAAA
syscall.WriteConsole -> syscall.procWriteConsoleW
syscall.WriteConsole -> gclocals·oiGMC7HcIj/RFC2t0reRjg==
syscall.WriteConsole -> syscall.ReadConsole.arginfo1
internal/poll.(*FD).Pwrite -> internal/poll.(*FD).Pwrite.func1
internal/poll.(*FD).Pwrite -> internal/poll.(*FD).Pwrite.func2
internal/poll.(*FD).Pwrite -> internal/poll.(*FD).Pwrite.func3
internal/poll.(*FD).Pwrite -> gclocals·2td5wIM9m40xk7T07bA/wA==
internal/poll.(*FD).Pwrite -> gclocals·TredKVQ6UnAaT/PxZXvS+A==
internal/poll.(*FD).Pwrite -> internal/poll.(*FD).Pwrite.opendefer
internal/poll.(*FD).Writev -> internal/poll.(*FD).Writev.func2
internal/poll.(*FD).Writev -> internal/poll.(*FD).Writev.func1·f
internal/poll.(*FD).Writev -> internal/poll.TestHookDidWritev
internal/poll.(*FD).Writev -> gclocals·S23utia/CgjsPXf9C+wyNA==
internal/poll.(*FD).Writev -> gclocals·7dJSFdgni+Kz1jUxzgvWNw==
internal/poll.(*FD).WriteTo -> internal/poll.(*FD).WriteTo.func3
internal/poll.(*FD).WriteTo -> internal/poll.(*FD).WriteTo.func1·f
internal/poll.(*FD).WriteTo -> internal/poll.(*FD).WriteTo.func2·f
internal/poll.(*FD).WriteTo -> gclocals·AS7n6ARLmcsuzi0v2pxgBQ==
internal/poll.(*FD).WriteTo -> gclocals·jErESF03juMAGywajQhUKg==
internal/poll.(*FD).WriteTo -> internal/poll.(*FD).WriteTo.opendefer
internal/poll.(*FD).WriteTo -> fmt.(*fmt).fmtBx.arginfo1
internal/poll.(*FD).WriteToInet4 -> internal/poll.(*FD).WriteToInet4.func3
internal/poll.(*FD).WriteToInet4 -> internal/poll.(*FD).WriteToInet4.func1
internal/poll.(*FD).WriteToInet4 -> internal/poll.(*FD).WriteToInet4.func2
internal/poll.(*FD).WriteToInet4 -> gclocals·zhX/bi5z5ZS/KemsFPrUQQ==
internal/poll.(*FD).WriteToInet4 -> gclocals·QVZPu7jMBY6HUuF59wtfXg==
internal/poll.(*FD).WriteToInet4 -> internal/poll.(*FD).WriteToInet4.opendefer
internal/poll.(*FD).WriteToInet4.func2 -> syscall.wsaSendtoInet4
syscall.wsaSendtoInet4 -> syscall.procWSASendTo
syscall.wsaSendtoInet4 -> gclocals·gSfXza59WuQzDN1SjdjJoA==
syscall.wsaSendtoInet4 -> gclocals·gEU4wZTE1mpc7GgcYYGLwQ==
syscall.wsaSendtoInet4 -> syscall.wsaSendtoInet4.arginfo1
syscall.wsaSendtoInet4 -> syscall.wsaSendtoInet4.argliveinfo
 -> go:info.syscall.(*SockaddrInet4).sockaddr$abstract
internal/poll.(*FD).WriteToInet6 -> internal/poll.(*FD).WriteToInet6.func3
internal/poll.(*FD).WriteToInet6 -> internal/poll.(*FD).WriteToInet6.func1
internal/poll.(*FD).WriteToInet6 -> internal/poll.(*FD).WriteToInet6.func2
internal/poll.(*FD).WriteToInet6.func2 -> syscall.wsaSendtoInet6
 -> go:info.syscall.(*SockaddrInet6).sockaddr$abstract
internal/poll.(*FD).ConnectEx -> internal/poll.(*FD).ConnectEx.func1·f
internal/poll.(*FD).Accept -> internal/poll.(*FD).Accept.func1
internal/poll.(*FD).Accept -> type:[2]syscall.RawSockaddrAny
internal/poll.(*FD).Accept -> internal/poll.(*FD).acceptOne
internal/poll.(*FD).Accept -> gclocals·JoM9C7dnKPD0hVLslvxc8A==
internal/poll.(*FD).Accept -> os.ReadFile.stkobj
internal/poll.(*FD).Accept -> fmt.(*ss).doScanf.opendefer
internal/poll.(*FD).acceptOne -> internal/poll.(*FD).acceptOne.func1
internal/poll.(*FD).acceptOne -> syscall.Setsockopt
internal/poll.(*FD).acceptOne -> go:string."acceptex"
internal/poll.(*FD).acceptOne -> gclocals·Iixq1E6SKLMsj/p5dBbWJQ==
internal/poll.(*FD).acceptOne -> gclocals·CxCFCDf+2zyvinpZnulj1g==
internal/poll.(*FD).acceptOne -> internal/poll.(*FD).acceptOne.arginfo1
syscall.Setsockopt -> syscall.procsetsockopt
syscall.Setsockopt -> syscall.Setsockopt.arginfo1
syscall.Setsockopt -> syscall.Setsockopt.argliveinfo
internal/poll.(*FD).acceptOne.func1 -> internal/poll.AcceptFunc
internal/poll.(*FD).Seek -> internal/poll.(*FD).Seek.func1
internal/poll.(*FD).Seek -> internal/poll.(*FD).Seek.func2
internal/poll.(*FD).Seek -> gclocals·n4BNELZNto2PVCEEq6kyBg==
internal/poll.(*FD).Seek -> internal/poll.(*FD).Seek.opendefer
internal/poll.(*FD).Fchmod -> internal/poll.(*FD).Fchmod.func1
internal/poll.(*FD).Fchmod -> internal/syscall/windows.SetFileInformationByHandle
internal/poll.(*FD).Fchmod -> gclocals·PWnzLfQnT/6P1H8n2hIlIw==
internal/poll.(*FD).Fchmod -> os.ReadDir.opendefer
internal/syscall/windows.SetFileInformationByHandle -> internal/syscall/windows.procSetFileInformationByHandle
internal/poll.(*FD).Fchdir -> internal/poll.(*FD).Fchdir.func1
internal/poll.(*FD).Fchdir -> syscall.Fchdir
syscall.Fchdir -> syscall.fdpath
syscall.Fchdir -> syscall.SetCurrentDirectory
syscall.fdpath -> syscall.getFinalPathNameByHandle
syscall.fdpath -> runtime.panicmakeslicelen
syscall.getFinalPathNameByHandle -> syscall.procGetFinalPathNameByHandleW
syscall.SetCurrentDirectory -> syscall.procSetCurrentDirectoryW
 -> go:info.[261]uint16
internal/poll.(*FD).GetFileType -> internal/poll.(*FD).GetFileType.func1
internal/poll.(*FD).GetFileType -> internal/poll.(*FD).GetFileType.opendefer
internal/poll.(*FD).GetFileInformationByHandle -> internal/poll.(*FD).GetFileInformationByHandle.func1
internal/poll.(*FD).RawRead -> internal/poll.(*FD).RawRead.func2
internal/poll.(*FD).RawRead -> internal/poll.(*FD).RawRead.func1·f
internal/poll.(*FD).RawRead -> gclocals·To5m0fMvf/F3d4bqxucFuw==
internal/poll.(*FD).RawWrite -> internal/poll.(*FD).RawWrite.func1
internal/poll.(*FD).ReadMsg -> internal/poll.(*FD).ReadMsg.func2
internal/poll.(*FD).ReadMsg -> internal/poll.(*FD).ReadMsg.func1·f
internal/poll.(*FD).ReadMsg -> gclocals·K4cKmh+XWyeD0hY+8iD5jg==
internal/poll.(*FD).ReadMsg -> gclocals·B7PlJhxyTGPd2OYPVrrexQ==
internal/poll.(*FD).ReadMsg -> internal/poll.(*FD).ReadMsg.arginfo1
internal/poll.(*FD).ReadMsgInet4 -> internal/poll.(*FD).ReadMsgInet4.func2
internal/poll.(*FD).ReadMsgInet4 -> internal/poll.(*FD).ReadMsgInet4.func1·f
internal/poll.(*FD).ReadMsgInet4 -> gclocals·6dgQbrX8dhwmkcu3H+6JvA==
internal/poll.(*FD).ReadMsgInet4 -> gclocals·msM3/im4SeZ47JImQJCNlg==
internal/poll.(*FD).ReadMsgInet4 -> internal/poll.(*FD).ReadMsgInet4.arginfo1
internal/poll.(*FD).ReadMsgInet6 -> internal/poll.(*FD).ReadMsgInet6.func2
internal/poll.(*FD).ReadMsgInet6 -> internal/poll.(*FD).ReadMsgInet6.func1·f
internal/poll.(*FD).WriteMsg -> internal/poll.(*FD).WriteMsg.func2
internal/poll.(*FD).WriteMsg -> internal/poll.sockaddrToRaw
internal/poll.(*FD).WriteMsg -> internal/poll.(*FD).WriteMsg.func1·f
internal/poll.(*FD).WriteMsg -> go:string."packet is too large (only 1GB is allowed)"
internal/poll.(*FD).WriteMsg -> gclocals·1d/h2ES9nWX8TSJqrOxiEw==
internal/poll.(*FD).WriteMsg -> gclocals·Y4DJYUH7S3fgOKAjGdceKQ==
internal/poll.(*FD).WriteMsg -> internal/poll.(*FD).WriteMsg.arginfo1
internal/poll.(*FD).WriteMsg -> internal/poll.(*FD).WriteMsg.argliveinfo
internal/poll.sockaddrToRaw -> go:sehuw.12.AQQCBQQDAVAAAAAA
internal/poll.(*FD).WriteMsgInet4 -> internal/poll.(*FD).WriteMsgInet4.func2
internal/poll.(*FD).WriteMsgInet4 -> internal/poll.(*FD).WriteMsgInet4.func1·f
internal/poll.(*FD).WriteMsgInet4 -> gclocals·UvuN7D62NTNbfKLOrdXVGw==
internal/poll.(*FD).WriteMsgInet6 -> internal/poll.(*FD).WriteMsgInet6.func2
internal/poll.(*FD).WriteMsgInet6 -> internal/poll.(*FD).WriteMsgInet6.func1·f
internal/poll.(*FD).SetsockoptInt -> internal/poll.(*FD).SetsockoptInt.func1
internal/poll.(*FD).SetsockoptInet4Addr -> internal/poll.(*FD).SetsockoptInet4Addr.func1
internal/poll.(*FD).SetsockoptInet4Addr -> syscall.SetsockoptInet4Addr.arginfo1
internal/poll.(*FD).SetsockoptInet4Addr -> runtime.int32Hash.argliveinfo
internal/poll.(*FD).SetsockoptLinger -> internal/poll.(*FD).SetsockoptLinger.func1
internal/poll.(*FD).SetsockoptLinger -> syscall.SetsockoptLinger
 -> go:info.*syscall.Linger
 -> go:info.syscall.sysLinger
internal/poll.(*FD).GetsockoptInt -> internal/poll.(*FD).GetsockoptInt.func1
internal/poll.(*FD).GetsockoptInt -> io.(*onceError).Load.opendefer
internal/poll.(*FD).Setsockopt -> internal/poll.(*FD).Setsockopt.func1
internal/poll.(*FD).WSAIoctl -> internal/poll.(*FD).WSAIoctl.func1
internal/poll.(*FD).WSAIoctl -> gclocals·2p2pzRetds3segystCVl9A==
internal/poll.(*FD).SetsockoptIPMreq -> internal/poll.(*FD).SetsockoptIPMreq.func1
internal/poll.(*FD).SetsockoptIPv6Mreq -> internal/poll.(*FD).SetsockoptIPv6Mreq.func1
internal/poll.(*FD).SetsockoptIPv6Mreq -> gclocals·aktTVspFr1s9kZETxmTTcQ==
internal/poll.ErrNotPollable -> internal/poll..stmp_4
internal/poll.TestHookDidWritev -> internal/poll.glob..func1·f
internal/poll.ReadConsole -> syscall.ReadConsole·f
 -> go:info.func(syscall.Handle, *uint16, uint32, *uint32, *uint8) error
internal/poll.AcceptFunc -> syscall.AcceptEx·f
 -> go:info.func(syscall.Handle, syscall.Handle, *uint8, uint32, uint32, uint32, *uint32, *syscall.Overlapped) error
internal/poll..stmp_4 -> go:string."not pollable"
 -> go:info.internal/poll.errNetClosing.Error$abstract
 -> go:info.internal/poll.errNetClosing.Timeout$abstract
 -> go:info.internal/poll.errNetClosing.Temporary$abstract
 -> go:info.*internal/poll.DeadlineExceededError
 -> go:info.internal/poll.(*FD).incref$abstract
 -> go:info.internal/poll.(*fdMutex).incref$abstract
 -> go:info.syscall.Fsync$abstract
 -> go:info.internal/poll.convertErr$abstract
 -> go:info.time.Time.IsZero$abstract
 -> go:info.time.(*Time).sec$abstract
 -> go:info.time.(*Time).nsec$abstract
 -> go:info.syscall.Shutdown$abstract
 -> go:info.internal/poll.ignoringEINTR$abstract
 -> go:info.internal/poll.(*FD).Ftruncate.func1$abstract
 -> go:info.func(uintptr)
 -> go:info.internal/poll.(*operation).InitBuf$abstract
 -> go:info.*internal/poll.operation
 -> go:info.*[][]uint8
 -> go:info.internal/poll.(*operation).ClearBufs$abstract
 -> go:info.func(*internal/poll.operation) error
 -> go:info.internal/poll.(*pollDesc).waitCanceled$abstract
 -> go:info.internal/poll.(*FD).readLock$abstract
 -> go:info.internal/poll.(*FD).eofError$abstract
 -> go:info.unicode/utf16.IsSurrogate$abstract
 -> go:info.syscall.Overlapped
 -> go:info.internal/poll.rawToSockaddrInet4$abstract
 -> go:info.internal/poll.rawToSockaddrInet6$abstract
 -> go:info.internal/poll.(*FD).writeLock$abstract
 -> go:info.unicode/utf8.FullRune$abstract
 -> go:info.internal/poll.consume$abstract
 -> go:info.[]syscall.RawSockaddrAny
 -> go:info.func() (syscall.Handle, error)
 -> go:info.*[2]syscall.RawSockaddrAny
 -> go:info.internal/syscall/windows.FILE_BASIC_INFO
 -> go:info.func(uintptr) bool
 -> go:info.internal/poll.sockaddrInet4ToRaw$abstract
 -> go:info.internal/poll.sockaddrInet6ToRaw$abstract
 -> go:info.syscall.SetsockoptInt$abstract
 -> go:info.syscall.SetsockoptInet4Addr$abstract
 -> go:info.*syscall.IPMreq
 -> go:info.syscall.SetsockoptIPMreq$abstract
 -> go:info.*syscall.IPv6Mreq
time.Until -> time.Now
time.Until -> time.Time.Sub
time.Time.Sub -> time.Time.Add
time.Time.Sub -> time.Time.Equal
time.Time.Sub -> time.Time.Before
time.Time.Sub -> gclocals·NK6bjktFb+rD2SRGwpXm7g==
time.Time.Sub -> time.Time.After.stkobj
time.Time.Sub -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
time.Time.Add -> time.(*Time).addSec
time.Time.Add -> time.Time.IsZero.stkobj
time.Time.Add -> runtime.bytesHash.argliveinfo
time.Now -> time.now
time.Now -> time.Local
time.Local -> time.localLoc
 -> go:info.*time.Location
 -> go:info.time.Location
 -> go:info.*time.Time
 -> go:info.time.(*Time).stripMono$abstract
 -> go:info.time.Duration
unicode/utf16.Encode -> go:sehuw.12.AQ4CBQ4DC1AAAAAA
type:func() error <UsedInIface> -> type:.namedata.*func() error-
type:func([]uint8) <UsedInIface> -> type:.namedata.*func([]uint8)-
type:func(uint8) <UsedInIface> -> type:.namedata.*func(uint8)-
type:func(string) <UsedInIface> -> type:.namedata.*func(string)-
type:func(bool) <UsedInIface> -> type:.namedata.*func(bool)-
type:func(uint64) <UsedInIface> -> type:.namedata.*func(uint64)-
type:func(string) string <UsedInIface> -> type:.namedata.*func(string) string-
type:func(int) <UsedInIface> -> type:.namedata.*func(int)-
type:func(string) (int, error) <UsedInIface> -> type:.namedata.*func(string) (int, error)-
type:func(reflect.Value) <UsedInIface> -> type:.namedata.*func(reflect.Value)-
go:info.unicode/utf8.FullRune$abstract -> go:info.unicode/utf8.acceptRange
type:[16]uint8 <UsedInIface> -> type:.namedata.*[16]uint8-
reflect..stmp_19 -> go:string."reflect: Bits of nil Type"
reflect..stmp_21 -> go:string."reflect: Field index out of bounds"
reflect..stmp_22 -> go:string."reflect: nil type passed to Type.Implements"
reflect..stmp_23 -> go:string."reflect: non-interface type passed to Type.Implements"
reflect..stmp_24 -> go:string."reflect: nil type passed to Type.AssignableTo"
reflect..stmp_25 -> go:string."reflect: nil type passed to Type.ConvertibleTo"
reflect..stmp_91 -> go:string."reflect: call of reflect.Value.Cap on ptr to non-array Value"
reflect..stmp_95 -> go:string."reflect: indirection through nil pointer to embedded struct"
reflect..stmp_108 -> go:string."reflect: Value.SetIterKey called before Next"
reflect..stmp_109 -> go:string."reflect: Value.SetIterKey called on exhausted iterator"
reflect..stmp_112 -> go:string."reflect: Value.SetIterValue called before Next"
reflect..stmp_113 -> go:string."reflect: Value.SetIterValue called on exhausted iterator"
reflect..stmp_122 -> go:string."reflect: recv on send-only channel"
reflect..stmp_124 -> go:string."reflect: send on recv-only channel"
reflect..stmp_126 -> go:string."reflect.Value.SetBytes of non-byte slice"
reflect..stmp_128 -> go:string."reflect: slice length out of range in SetLen"
reflect..stmp_129 -> go:string."reflect: slice capacity out of range in SetCap"
reflect..stmp_137 -> go:string."reflect.Value.Slice3: slice of unaddressable array"
reflect..stmp_138 -> go:string."reflect.Value.Slice3: slice index out of bounds"
reflect..stmp_141 -> go:string."reflect.Value.UnsafeAddr of unaddressable value"
reflect..stmp_145 -> go:string."reflect.Value.Grow: negative len"
reflect..stmp_146 -> go:string."reflect.Value.Grow: slice overflow"
reflect..stmp_170 -> go:string."reflect.Value.Equal: invalid Kind"
reflect.(*structType).FieldByNameFunc.stkobj -> runtime.gcbits.fe05000000000000
reflect.(*ChanDir).String -> runtime.panicwrap
runtime.panicwrap -> go:string."panicwrap: unexpected string after package name: "
runtime.panicwrap -> go:string."panicwrap: unexpected string after type name: "
runtime.panicwrap -> go:string."value method "
runtime.panicwrap -> go:string." called using nil *"
runtime.panicwrap -> go:string." pointer"
runtime.panicwrap -> go:string."panicwrap: no ) in "
runtime.panicwrap -> go:string."panicwrap: no ( in "
runtime.panicwrap -> gclocals·L5dy2NHL6v5bzqhZaRqYew==
runtime.panicwrap -> runtime.panicwrap.stkobj
reflect.(*Value).InterfaceData -> reflect.(*Value).InterfaceData.arginfo1
reflect.(*Value).SetMapIndex -> gclocals·pT/sOmx8d9SsaYF8WtDVog==
reflect.(*ptrType).Uncommon -> reflect.(*ptrType).Uncommon.jump7
reflect.(*structType).Uncommon -> reflect.(*structType).Uncommon.jump7
type:func(string) (string, bool) <UsedInIface> -> type:.namedata.*func(string) (string, bool)-
type:.eqfunc.reflect.hiter -> type:.eq.reflect.hiter
type:.eqfunc.reflect.MapIter -> type:.eq.reflect.MapIter
type:func() reflect.Value <UsedInIface> -> type:.namedata.*func() reflect.Value-
type:func() []uint8 <UsedInIface> -> type:.namedata.*func() []uint8-
type:func() complex128 <UsedInIface> -> type:.namedata.*func() complex128-
type:func() complex128 <UsedInIface> -> type:complex128 <UsedInIface>
type:complex128 <UsedInIface> -> type:*complex128 <UsedInIface>
type:func(reflect.Type) reflect.Value <UsedInIface> -> type:.namedata.*func(reflect.Type) reflect.Value-
type:func(reflect.Value) bool <UsedInIface> -> type:.namedata.*func(reflect.Value) bool-
type:func(int) reflect.Value <UsedInIface> -> type:.namedata.*func(int) reflect.Value-
type:func([]int) reflect.Value <UsedInIface> -> type:.namedata.*func([]int) reflect.Value-
type:func([]int) (reflect.Value, error) <UsedInIface> -> type:.namedata.*func([]int) (reflect.Value, error)-
type:func(string) reflect.Value <UsedInIface> -> type:.namedata.*func(string) reflect.Value-
type:func(func(string) bool) reflect.Value <UsedInIface> -> type:.namedata.*func(func(string) bool) reflect.Value-
type:func() float64 <UsedInIface> -> type:.namedata.*func() float64-
type:func() int64 <UsedInIface> -> type:.namedata.*func() int64-
type:func() [2]uintptr <UsedInIface> -> type:.namedata.*func() [2]uintptr-
type:func() [2]uintptr <UsedInIface> -> type:[2]uintptr <UsedInIface>
type:func(reflect.Value) reflect.Value <UsedInIface> -> type:.namedata.*func(reflect.Value) reflect.Value-
type:func() []reflect.Value <UsedInIface> -> type:.namedata.*func() []reflect.Value-
type:func() *reflect.MapIter <UsedInIface> -> type:.namedata.*func() *reflect.MapIter-
type:func() *reflect.MapIter <UsedInIface> -> type:*reflect.MapIter <UsedInIface>
type:*reflect.MapIter <UsedInIface> -> type:reflect.MapIter <UsedInIface>
type:reflect.MapIter <UsedInIface> -> type:reflect.hiter <UsedInIface>
type:reflect.hiter <UsedInIface> -> type:*reflect.hiter <UsedInIface>
type:reflect.hiter <UsedInIface> -> type:*[]unsafe.Pointer <UsedInIface>
type:func(complex128) bool <UsedInIface> -> type:.namedata.*func(complex128) bool-
type:func(float64) bool <UsedInIface> -> type:.namedata.*func(float64) bool-
type:func(int64) bool <UsedInIface> -> type:.namedata.*func(int64) bool-
type:func(uint64) bool <UsedInIface> -> type:.namedata.*func(uint64) bool-
type:func() (reflect.Value, bool) <UsedInIface> -> type:.namedata.*func() (reflect.Value, bool)-
type:func(complex128) <UsedInIface> -> type:.namedata.*func(complex128)-
type:func(float64) <UsedInIface> -> type:.namedata.*func(float64)-
type:func(int64) <UsedInIface> -> type:.namedata.*func(int64)-
type:func(*reflect.MapIter) <UsedInIface> -> type:.namedata.*func(*reflect.MapIter)-
type:func(reflect.Value, reflect.Value) <UsedInIface> -> type:.namedata.*func(reflect.Value, reflect.Value)-
type:func(unsafe.Pointer) <UsedInIface> -> type:.namedata.*func(unsafe.Pointer)-
type:func(int, int) reflect.Value <UsedInIface> -> type:.namedata.*func(int, int) reflect.Value-
type:func(int, int, int) reflect.Value <UsedInIface> -> type:.namedata.*func(int, int, int) reflect.Value-
type:func() uint64 <UsedInIface> -> type:.namedata.*func() uint64-
type:func() unsafe.Pointer <UsedInIface> -> type:.namedata.*func() unsafe.Pointer-
type:func() []internal/abi.Method <UsedInIface> -> type:.namedata.*func() []abi.Method-
type:func() []internal/abi.Method <UsedInIface> -> type:[]internal/abi.Method <UsedInIface>
type:func(uintptr, uintptr) []uint8 <UsedInIface> -> type:.namedata.*func(uintptr, uintptr) []uint8-
type:func() *internal/abi.ArrayType <UsedInIface> -> type:.namedata.*func() *abi.ArrayType-
type:func() *internal/abi.ArrayType <UsedInIface> -> type:*internal/abi.ArrayType <UsedInIface>
type:*internal/abi.ArrayType <UsedInIface> -> type:internal/abi.ArrayType <UsedInIface>
type:func() internal/abi.ChanDir <UsedInIface> -> type:.namedata.*func() abi.ChanDir-
type:func() internal/abi.ChanDir <UsedInIface> -> type:internal/abi.ChanDir <UsedInIface>
type:internal/abi.ChanDir <UsedInIface> -> type:.namedata.*abi.ChanDir.
type:internal/abi.ChanDir <UsedInIface> -> type:*internal/abi.ChanDir <UsedInIface>
type:func() *internal/abi.FuncType <UsedInIface> -> type:.namedata.*func() *abi.FuncType-
type:func() *internal/abi.InterfaceType <UsedInIface> -> type:.namedata.*func() *abi.InterfaceType-
type:func() *internal/abi.InterfaceType <UsedInIface> -> type:*internal/abi.InterfaceType <UsedInIface>
type:*internal/abi.InterfaceType <UsedInIface> -> type:internal/abi.InterfaceType <UsedInIface>
type:internal/abi.InterfaceType <UsedInIface> -> type:[]internal/abi.Imethod <UsedInIface>
type:func() *internal/abi.MapType <UsedInIface> -> type:.namedata.*func() *abi.MapType-
type:func() *internal/abi.MapType <UsedInIface> -> type:*internal/abi.MapType <UsedInIface>
type:*internal/abi.MapType <UsedInIface> -> type:.namedata.*abi.MapType.
type:*internal/abi.MapType <UsedInIface> -> type:internal/abi.MapType <UsedInIface>
type:*internal/abi.MapType <UsedInIface> -> type:.namedata.HashMightPanic.
type:*internal/abi.MapType <UsedInIface> -> type:.namedata.IndirectElem.
type:*internal/abi.MapType <UsedInIface> -> type:.namedata.IndirectKey.
type:*internal/abi.MapType <UsedInIface> -> type:.namedata.NeedKeyUpdate.
type:*internal/abi.MapType <UsedInIface> -> type:.namedata.ReflexiveKey.
type:internal/abi.MapType <UsedInIface> -> runtime.gcbits.d803000000000000
type:internal/abi.MapType <UsedInIface> -> type:.namedata.Bucket.
type:internal/abi.MapType <UsedInIface> -> type:.namedata.Hasher.
type:internal/abi.MapType <UsedInIface> -> type:func(unsafe.Pointer, uintptr) uintptr <UsedInIface>
type:internal/abi.MapType <UsedInIface> -> type:.namedata.KeySize.
type:internal/abi.MapType <UsedInIface> -> type:.namedata.ValueSize.
type:internal/abi.MapType <UsedInIface> -> type:.namedata.BucketSize.
type:func() *internal/abi.StructType <UsedInIface> -> type:.namedata.*func() *abi.StructType-
type:[2]unsafe.Pointer -> type:.namedata.*[2]unsafe.Pointer-
type:[1]int -> type:.namedata.*[1]int-
type:map[*reflect.structType]bool -> type:.namedata.*map[*reflect.structType]bool-
type:map[*reflect.structType]bool -> type:noalg.map.bucket[*reflect.structType]bool
type:noalg.map.bucket[*reflect.structType]bool -> type:.namedata.*map.bucket[*reflect.structType]bool-
type:noalg.map.bucket[*reflect.structType]bool -> type:noalg.[8]*reflect.structType
type:noalg.[8]*reflect.structType -> type:.namedata.*[8]*reflect.structType-
type:noalg.[8]*reflect.structType -> type:[]*reflect.structType
type:[]*reflect.structType -> type:.namedata.*[]*reflect.structType-
type:map[*reflect.structType]int -> type:.namedata.*map[*reflect.structType]int-
type:map[*reflect.structType]int -> type:noalg.map.bucket[*reflect.structType]int
type:noalg.map.bucket[*reflect.structType]int -> runtime.gcbits.fe01020000000000
type:noalg.map.bucket[*reflect.structType]int -> type:.namedata.*map.bucket[*reflect.structType]int-
reflect.cvtBytesString·f -> reflect.cvtBytesString
reflect.cvtBytesString -> reflect.makeString
reflect.cvtBytesString -> gclocals·i1ICPN6HH4mF8e0BpHcq7Q==
reflect.makeString -> gclocals·Vml4o4G4IuC8RVtlbgvhDQ==
reflect.makeString -> gclocals·UM9KnlqEDRhHs9Q0Hx30QQ==
reflect.cvtComplex·f -> reflect.cvtComplex
reflect.cvtComplex -> reflect.makeComplex
reflect.makeComplex -> gclocals·8YuTUWIn6s3pMRQQ+LmTfw==
reflect.cvtDirect·f -> reflect.cvtDirect
reflect.cvtDirect -> gclocals·y/9bnEN0Hwb8M82QKHUq+w==
reflect.cvtDirect -> gclocals·BJgmC5Te+4gbqvvyI4/T7Q==
reflect.cvtFloat·f -> reflect.cvtFloat
reflect.cvtFloat -> reflect.makeFloat
reflect.cvtFloat -> reflect.makeFloat32
reflect.makeFloat32 -> fmt.(*ss).scanOne.arginfo1
reflect.cvtFloatInt·f -> reflect.cvtFloatInt
reflect.cvtFloatInt -> reflect.makeInt
reflect.cvtFloatUint·f -> reflect.cvtFloatUint
reflect.cvtI2I·f -> reflect.cvtI2I
reflect.cvtI2I -> reflect.cvtT2I
reflect.cvtT2I -> gclocals·GRq7cWEAQc0OM3M+C327Pg==
reflect.cvtT2I -> gclocals·Rm+JZj8RH8lwpFbgtl5wxg==
reflect.cvtInt·f -> reflect.cvtInt
reflect.cvtIntFloat·f -> reflect.cvtIntFloat
reflect.cvtIntString·f -> reflect.cvtIntString
reflect.cvtIntString -> go:string."�"
reflect.cvtIntString -> runtime.intstring
reflect.cvtRunesString·f -> reflect.cvtRunesString
reflect.cvtRunesString -> reflect.Value.runes
reflect.cvtRunesString -> runtime.slicerunetostring
reflect.Value.runes -> reflect..stmp_54
runtime.slicerunetostring -> gclocals·Qt/nqQvMvXvYZsmY8FB4ww==
runtime.slicerunetostring -> gclocals·dJtlXlkLUITRziIVJWaQZw==
reflect..stmp_54 -> go:string."reflect.Value.Bytes of non-rune slice"
reflect.cvtSliceArray·f -> reflect.cvtSliceArray
reflect.cvtSliceArray -> go:string." to array with length "
reflect.cvtSliceArray -> go:string."reflect: cannot convert slice with length "
reflect.cvtSliceArray -> gclocals·FNB77wFDVXOCZHep3Mr2yA==
reflect.cvtSliceArray -> gclocals·9sRipOemQ3r3i+ZTIm/c8g==
reflect.cvtSliceArrayPtr·f -> reflect.cvtSliceArrayPtr
reflect.cvtSliceArrayPtr -> go:string." to pointer to array with length "
reflect.cvtSliceArrayPtr -> gclocals·fbZ24x8V15/Eb5Fyoy9PCw==
reflect.cvtStringBytes·f -> reflect.cvtStringBytes
reflect.cvtStringBytes -> reflect.makeBytes
reflect.makeBytes -> gclocals·MsQftmPDD3YzAnooaCNgOg==
reflect.makeBytes -> reflect.makeBytes.argliveinfo
reflect.cvtStringRunes·f -> reflect.cvtStringRunes
reflect.cvtStringRunes -> runtime.stringtoslicerune
reflect.cvtStringRunes -> reflect.makeRunes
reflect.makeRunes -> reflect.Value.setRunes
reflect.Value.setRunes -> reflect..stmp_127
runtime.stringtoslicerune -> runtime.rawruneslice
 -> go:info.*[32]int32
reflect..stmp_127 -> go:string."reflect.Value.setRunes of non-rune slice"
reflect.cvtUint·f -> reflect.cvtUint
reflect.cvtUintFloat·f -> reflect.cvtUintFloat
reflect.cvtUintString·f -> reflect.cvtUintString
type:func(error) bool <UsedInIface> -> type:.namedata.*func(error) bool-
type:interface { Is(error) bool } -> type:.namedata.*interface { Is(error) bool }-
type:interface { Unwrap() []error } -> type:.namedata.*interface { Unwrap() []error }-
type:interface { Unwrap() []error } -> type:func() []error
type:func() []error -> type:.namedata.*func() []error-
type:func() []error -> type:[]error
type:interface { Unwrap() error } -> type:.namedata.*interface { Unwrap() error }-
go:itab.*io.LimitedReader,io.Reader -> type:io.Reader
go:itab.*io.LimitedReader,io.Reader -> type:*io.LimitedReader
type:io.Reader -> type:.namedata.*io.Reader.
type:io.Reader -> type:*io.Reader
type:*io.LimitedReader -> type:.namedata.*io.LimitedReader.
type:*io.LimitedReader -> type:io.LimitedReader
type:io.LimitedReader -> type:.eqfunc.io.LimitedReader
type:io.LimitedReader -> type:.namedata.R.
type:io.LimitedReader -> type:.namedata.N.
type:func(io.Writer) (int64, error) -> type:.namedata.*func(io.Writer) (int64, error)-
type:.eqfunc.io.LimitedReader -> type:.eq.io.LimitedReader
type:.eq.io.LimitedReader -> go:sehuw.12.AQoCBQoDB1AAAAAA
type:func(io.Reader) (int64, error) <UsedInIface> -> type:.namedata.*func(io.Reader) (int64, error)-
type:func(io.Reader) (int64, error) <UsedInIface> -> type:io.Reader <UsedInIface>
type:io.Reader <UsedInIface> -> type:*io.Reader <UsedInIface>
type:func([]uint8, int64) (int, error) <UsedInIface> -> type:.namedata.*func([]uint8, int64) (int, error)-
type:func(int64, int) (int64, error) <UsedInIface> -> type:.namedata.*func(int64, int) (int64, error)-
go:itab.os.fileWithoutReadFrom,io.Writer -> type:os.fileWithoutReadFrom <UsedInIface>
type:os.fileWithoutReadFrom <UsedInIface> -> type:.namedata.*os.fileWithoutReadFrom-
type:os.fileWithoutReadFrom <UsedInIface> -> type:*os.fileWithoutReadFrom <UsedInIface>
type:os.fileWithoutReadFrom <UsedInIface> -> type:.namedata.File..embedded
go:itab.os.dirEntry,io/fs.DirEntry -> type:os.dirEntry <UsedInIface>
type:os.dirEntry <UsedInIface> -> type:.namedata.*os.dirEntry-
type:os.dirEntry <UsedInIface> -> type:*os.dirEntry <UsedInIface>
type:os.dirEntry <UsedInIface> -> type:.namedata.fs-
go:itab.*os.rawConn,syscall.RawConn -> type:syscall.RawConn
type:syscall.RawConn -> type:.namedata.*syscall.RawConn.
type:syscall.RawConn -> type:*syscall.RawConn
type:.eqfunc.os.fileStat -> type:.eq.os.fileStat
type:func() time.Time <UsedInIface> -> type:.namedata.*func() time.Time-
type:func() time.Time <UsedInIface> -> type:time.Time <UsedInIface>
type:time.Time <UsedInIface> -> type:.namedata.*time.Time.
type:time.Time <UsedInIface> -> type:*time.Time <UsedInIface>
type:time.Time <UsedInIface> -> type:.importpath.time.
type:time.Time <UsedInIface> -> type:.namedata.wall-
type:time.Time <UsedInIface> -> type:.namedata.ext-
type:time.Time <UsedInIface> -> type:.namedata.loc-
type:time.Time <UsedInIface> -> type:*time.Location <UsedInIface>
type:time.Time <UsedInIface> -> type:.namedata.AddDate.
type:time.Time <UsedInIface> -> type:.namedata.After.
type:time.Time <UsedInIface> -> type:.namedata.AppendFormat.
type:time.Time <UsedInIface> -> type:.namedata.Before.
type:time.Time <UsedInIface> -> type:.namedata.Clock.
type:time.Time <UsedInIface> -> type:.namedata.Compare.
type:time.Time <UsedInIface> -> type:.namedata.Date.
type:time.Time <UsedInIface> -> type:.namedata.Day.
type:time.Time <UsedInIface> -> type:.namedata.GobEncode.
type:time.Time <UsedInIface> -> type:.namedata.Hour.
type:time.Time <UsedInIface> -> type:.namedata.ISOWeek.
type:time.Time <UsedInIface> -> type:.namedata.IsDST.
type:time.Time <UsedInIface> -> type:.namedata.Local.
type:time.Time <UsedInIface> -> type:.namedata.Location.
type:time.Time <UsedInIface> -> type:.namedata.MarshalBinary.
type:time.Time <UsedInIface> -> type:.namedata.MarshalJSON.
type:time.Time <UsedInIface> -> type:.namedata.MarshalText.
type:time.Time <UsedInIface> -> type:.namedata.Minute.
type:time.Time <UsedInIface> -> type:.namedata.Month.
type:time.Time <UsedInIface> -> type:.namedata.Nanosecond.
type:time.Time <UsedInIface> -> type:.namedata.Round.
type:time.Time <UsedInIface> -> type:.namedata.Second.
type:time.Time <UsedInIface> -> type:.namedata.Sub.
type:time.Time <UsedInIface> -> type:.namedata.UTC.
type:time.Time <UsedInIface> -> type:.namedata.Unix.
type:time.Time <UsedInIface> -> type:.namedata.UnixMicro.
type:time.Time <UsedInIface> -> type:.namedata.UnixMilli.
type:time.Time <UsedInIface> -> type:.namedata.UnixNano.
type:time.Time <UsedInIface> -> type:.namedata.Weekday.
type:time.Time <UsedInIface> -> type:.namedata.Year.
type:time.Time <UsedInIface> -> type:.namedata.YearDay.
type:time.Time <UsedInIface> -> type:.namedata.Zone.
type:time.Time <UsedInIface> -> type:.namedata.ZoneBounds.
type:time.Time <UsedInIface> -> type:.namedata.abs-
type:time.Time <UsedInIface> -> type:.namedata.appendFormat-
type:time.Time <UsedInIface> -> type:.namedata.appendFormatRFC3339-
type:time.Time <UsedInIface> -> type:.namedata.appendStrictRFC3339-
type:time.Time <UsedInIface> -> type:.namedata.date-
type:time.Time <UsedInIface> -> type:.namedata.locabs-
type:*time.Location <UsedInIface> -> type:.namedata.*time.Location.
type:*time.Location <UsedInIface> -> type:time.Location <UsedInIface>
type:*time.Location <UsedInIface> -> type:.namedata.firstZoneUsed-
type:*time.Location <UsedInIface> -> type:.namedata.lookup-
type:*time.Location <UsedInIface> -> type:.namedata.lookupFirstZone-
type:*time.Location <UsedInIface> -> type:.namedata.lookupName-
type:time.Location <UsedInIface> -> runtime.gcbits.2511000000000000
type:time.Location <UsedInIface> -> type:.namedata.zone-
type:time.Location <UsedInIface> -> type:[]time.zone <UsedInIface>
type:time.Location <UsedInIface> -> type:.namedata.tx-
type:time.Location <UsedInIface> -> type:[]time.zoneTrans <UsedInIface>
type:time.Location <UsedInIface> -> type:.namedata.extend-
type:time.Location <UsedInIface> -> type:.namedata.cacheStart-
type:time.Location <UsedInIface> -> type:.namedata.cacheEnd-
type:time.Location <UsedInIface> -> type:.namedata.cacheZone-
type:time.Location <UsedInIface> -> type:*time.zone <UsedInIface>
type:*time.zone <UsedInIface> -> type:.namedata.*time.zone-
type:*time.zone <UsedInIface> -> type:time.zone <UsedInIface>
type:time.zone <UsedInIface> -> type:.eqfunc.time.zone
type:time.zone <UsedInIface> -> type:.namedata.isDST-
type:*time.Time <UsedInIface> -> type:.namedata.GobDecode.
type:*time.Time <UsedInIface> -> type:.namedata.UnmarshalBinary.
type:*time.Time <UsedInIface> -> type:.namedata.UnmarshalJSON.
type:*time.Time <UsedInIface> -> type:.namedata.UnmarshalText.
type:*time.Time <UsedInIface> -> type:.namedata.addSec-
type:*time.Time <UsedInIface> -> type:.namedata.mono-
type:*time.Time <UsedInIface> -> type:.namedata.nsec-
type:*time.Time <UsedInIface> -> type:.namedata.sec-
type:*time.Time <UsedInIface> -> type:.namedata.setLoc-
type:*time.Time <UsedInIface> -> type:.namedata.setMono-
type:*time.Time <UsedInIface> -> type:.namedata.stripMono-
type:*time.Time <UsedInIface> -> type:.namedata.unixSec-
type:func() io/fs.FileMode <UsedInIface> -> type:.namedata.*func() fs.FileMode-
type:func() io/fs.FileMode <UsedInIface> -> type:io/fs.FileMode <UsedInIface>
type:io/fs.FileMode <UsedInIface> -> type:.namedata.*fs.FileMode.
type:io/fs.FileMode <UsedInIface> -> type:*io/fs.FileMode <UsedInIface>
type:io/fs.FileMode <UsedInIface> -> type:.namedata.IsRegular.
type:io/fs.FileMode <UsedInIface> -> type:.namedata.Perm.
type:func(io/fs.FileMode) error <UsedInIface> -> type:.namedata.*func(fs.FileMode) error-
type:func(int, int) error <UsedInIface> -> type:.namedata.*func(int, int) error-
type:func(int) ([]io/fs.DirEntry, error) <UsedInIface> -> type:.namedata.*func(int) ([]fs.DirEntry, error)-
type:func(int) ([]io/fs.DirEntry, error) <UsedInIface> -> type:[]io/fs.DirEntry <UsedInIface>
type:[]io/fs.DirEntry <UsedInIface> -> type:.namedata.*[]fs.DirEntry-
type:[]io/fs.DirEntry <UsedInIface> -> type:io/fs.DirEntry <UsedInIface>
type:io/fs.DirEntry <UsedInIface> -> type:*io/fs.DirEntry <UsedInIface>
type:func(int) ([]io/fs.FileInfo, error) <UsedInIface> -> type:.namedata.*func(int) ([]fs.FileInfo, error)-
type:func(int) ([]io/fs.FileInfo, error) <UsedInIface> -> type:[]io/fs.FileInfo <UsedInIface>
type:[]io/fs.FileInfo <UsedInIface> -> type:.namedata.*[]fs.FileInfo-
type:[]io/fs.FileInfo <UsedInIface> -> type:io/fs.FileInfo <UsedInIface>
type:io/fs.FileInfo <UsedInIface> -> type:*io/fs.FileInfo <UsedInIface>
type:func(int) ([]string, error) <UsedInIface> -> type:.namedata.*func(int) ([]string, error)-
type:func(int) ([]string, error) <UsedInIface> -> type:[]string <UsedInIface>
type:func(time.Time) error <UsedInIface> -> type:.namedata.*func(time.Time) error-
type:func() (io/fs.FileInfo, error) <UsedInIface> -> type:.namedata.*func() (fs.FileInfo, error)-
type:func() (syscall.RawConn, error) <UsedInIface> -> type:.namedata.*func() (syscall.RawConn, error)-
type:func() (syscall.RawConn, error) <UsedInIface> -> type:syscall.RawConn <UsedInIface>
type:syscall.RawConn <UsedInIface> -> type:*syscall.RawConn <UsedInIface>
type:func(int64) error <UsedInIface> -> type:.namedata.*func(int64) error-
type:func(uintptr) <UsedInIface> -> type:.namedata.*func(uintptr)-
type:func(func(uintptr)) error <UsedInIface> -> type:.namedata.*func(func(uintptr)) error-
type:func(func(uintptr) bool) error <UsedInIface> -> type:.namedata.*func(func(uintptr) bool) error-
type:func(func(uintptr) bool) error <UsedInIface> -> type:func(uintptr) bool <UsedInIface>
type:func(uintptr) bool <UsedInIface> -> type:.namedata.*func(uintptr) bool-
go:info.os.newFileStatFromFileIDBothDirInfo$abstract -> go:info.*internal/syscall/windows.FILE_ID_BOTH_DIR_INFO
type:func(interface {}) <UsedInIface> -> type:.namedata.*func(interface {})-
internal/abi.(*StructType).Uncommon -> internal/abi.(*StructType).Uncommon.jump7
internal/abi.(*FuncType).Uncommon -> internal/abi.(*FuncType).Uncommon.jump7
internal/abi.(*PtrType).Uncommon -> internal/abi.(*PtrType).Uncommon.jump7
type:func(int) *uint8 <UsedInIface> -> type:.namedata.*func(int) *uint8-
type:func(int, string) *uint8 <UsedInIface> -> type:.namedata.*func(int, string) *uint8-
type:func(int) (int, int) <UsedInIface> -> type:.namedata.*func(int) (int, int)-
type:[]internal/abi.Imethod <UsedInIface> -> type:internal/abi.Imethod <UsedInIface>
type:internal/abi.Imethod <UsedInIface> -> type:*internal/abi.Imethod <UsedInIface>
type:func(unsafe.Pointer, uintptr) uintptr <UsedInIface> -> type:.namedata.*func(unsafe.Pointer, uintptr) uintptr-
type:func(int) *internal/abi.Type <UsedInIface> -> type:.namedata.*func(int) *abi.Type-
type:func() []*internal/abi.Type <UsedInIface> -> type:.namedata.*func() []*abi.Type-
type:func(int, uintptr) unsafe.Pointer <UsedInIface> -> type:.namedata.*func(int, uintptr) unsafe.Pointer-
runtime.panicwrap.stkobj -> runtime.gcbits.5555010000000000
reflect.mapassign0 -> gclocals·0mtr1qCHvEA4JjgxiM7b3g==
reflect.mapassign_faststr0 -> gclocals·ZweWwrNQXO/LW3PhoI5fJg==
reflect.mapdelete -> runtime.mapdelete
runtime.mapdelete -> gclocals·flGniCDECnZjPQx5CMkMgQ==
runtime.mapdelete -> gclocals·mvhZ+PphBF8tOd41PjFLyA==
reflect.mapdelete_faststr -> runtime.mapdelete_faststr
runtime.mapdelete_faststr -> gclocals·F+JxdlYevlv+VMRvg1ZX2Q==
runtime.mapdelete_faststr -> gclocals·90zaSVG0nCyHUWqT51HYnA==
reflect.mapclear -> runtime.mapclear
 -> go:info.runtime.mapclear.func1$abstract
 -> go:info.runtime.netpollcheckerr$abstract
 -> go:info.runtime.(*pollDesc).info$abstract
 -> go:info.runtime.pollInfo.closing$abstract
 -> go:info.runtime.pollInfo.expiredReadDeadline$abstract
 -> go:info.runtime.pollInfo.expiredWriteDeadline$abstract
 -> go:info.runtime.pollInfo.eventErr$abstract
internal/poll.runtime_pollWait -> runtime.netpollblock
runtime.netpollblock -> runtime.netpollblockcommit·f
runtime.netpollblock -> go:string."runtime: corrupted polldesc"
runtime.netpollblock -> go:string."runtime: double wait"
 -> go:info.runtime/internal/atomic.(*Uintptr).Swap$abstract
internal/poll.runtime_pollSetDeadline -> runtime.netpollReadDeadline·f
internal/poll.runtime_pollSetDeadline -> runtime.netpollDeadline·f
internal/poll.runtime_pollSetDeadline -> runtime.netpollWriteDeadline·f
internal/poll.runtime_pollSetDeadline -> gclocals·/etlmppiYk5FhRZpqalV8g==
internal/poll.runtime_pollSetDeadline -> internal/poll.runtime_pollSetDeadline.stkobj
 -> go:info.runtime.(*pollDesc).makeArg$abstract
go:info.runtime.pollInfo.closing$abstract -> go:info.runtime.pollInfo
go:info.runtime.errorString.Error$abstract -> go:info.runtime.errorString
go:info.runtime.errorAddressString.Addr$abstract -> go:info.runtime.errorAddressString
go:info.runtime.plainError.Error$abstract -> go:info.runtime.plainError
type:func(uintptr, uintptr) bool <UsedInIface> -> type:.namedata.*func(uintptr, uintptr) bool-
type:func(uintptr) uintptr <UsedInIface> -> type:.namedata.*func(uintptr) uintptr-
type:func() uint32 <UsedInIface> -> type:.namedata.*func() uint32-
type:func(runtime.goroutineProfileState, runtime.goroutineProfileState) bool <UsedInIface> -> type:.namedata.*func(runtime.goroutineProfileState, runtime.goroutineProfileState) bool-
type:func(runtime.goroutineProfileState, runtime.goroutineProfileState) bool <UsedInIface> -> type:runtime.goroutineProfileState <UsedInIface>
type:runtime.goroutineProfileState <UsedInIface> -> type:.namedata.*runtime.goroutineProfileState-
type:runtime.goroutineProfileState <UsedInIface> -> type:*runtime.goroutineProfileState <UsedInIface>
type:func() runtime.goroutineProfileState <UsedInIface> -> type:.namedata.*func() runtime.goroutineProfileState-
type:func(runtime.goroutineProfileState) <UsedInIface> -> type:.namedata.*func(runtime.goroutineProfileState)-
type:func(uint32) <UsedInIface> -> type:.namedata.*func(uint32)-
type:[]error -> type:.namedata.*[]error-
runtime.netpollDeadline·f -> runtime.netpollDeadline
runtime.netpollDeadline -> runtime.netpolldeadlineimpl
runtime.netpolldeadlineimpl -> go:string."runtime: inconsistent write deadline"
runtime.netpolldeadlineimpl -> go:string."runtime: inconsistent read deadline"
runtime.netpolldeadlineimpl -> gclocals·jELlFAuuZpzRzvJNrf9o2g==
runtime.netpollReadDeadline·f -> runtime.netpollReadDeadline
runtime.netpollWriteDeadline·f -> runtime.netpollWriteDeadline
runtime.netpollblockcommit·f -> runtime.netpollblockcommit
internal/reflectlite..stmp_1 -> go:string."reflect: In of non-func type"
internal/reflectlite..stmp_2 -> go:string."reflect: Key of non-map type"
internal/reflectlite..stmp_3 -> go:string."reflect: Len of non-array type"
internal/reflectlite..stmp_4 -> go:string."reflect: NumField of non-struct type"
internal/reflectlite..stmp_5 -> go:string."reflect: NumIn of non-func type"
internal/reflectlite..stmp_6 -> go:string."reflect: NumOut of non-func type"
internal/reflectlite..stmp_7 -> go:string."reflect: Out of non-func type"
internal/reflectlite.rtype.GcSlice -> os.fileWithoutReadFrom.Chown.arginfo1
internal/reflectlite.rtype.Uncommon -> internal/reflectlite.rtype.Uncommon.jump7
internal/reflectlite.(*rtype).Uncommon -> internal/reflectlite.(*rtype).Uncommon.jump7
type:func(int) internal/reflectlite.Type <UsedInIface> -> type:.namedata.*func(int) reflectlite.Type-
type:interface { Timeout() bool } -> type:.namedata.*interface { Timeout() bool }-
syscall.(*Errno).Temporary -> go:sehuw.12.AQQCBQQDAVAAAAAA
type:[108]int8 <UsedInIface> -> type:.eqfunc108
type:[108]int8 <UsedInIface> -> type:.namedata.*[108]int8-
type:.eqfunc.syscall.SockaddrUnix -> type:.eq.syscall.SockaddrUnix
type:.eqfunc.syscall.SockaddrInet4 -> type:.eq.syscall.SockaddrInet4
go:info.syscall.(*SockaddrInet4).sockaddr$abstract -> go:info.*[2]uint8
type:func() (syscall.Sockaddr, error) <UsedInIface> -> type:.namedata.*func() (syscall.Sockaddr, error)-
go:info.internal/poll.ignoringEINTR$abstract -> go:info.func() error
go:info.internal/poll.errNetClosing.Error$abstract -> go:info.internal/poll.errNetClosing
type:func(*[][]uint8) <UsedInIface> -> type:.namedata.*func(*[][]uint8)-
type:func(*[][]uint8) <UsedInIface> -> type:*[][]uint8 <UsedInIface>
type:*[][]uint8 <UsedInIface> -> type:.namedata.*[][]uint8-
type:*[][]uint8 <UsedInIface> -> type:[][]uint8 <UsedInIface>
type:func([]uint8, []uint8) <UsedInIface> -> type:.namedata.*func([]uint8, []uint8)-
type:func(func() (syscall.Handle, error)) (syscall.Handle, []syscall.RawSockaddrAny, uint32, string, error) <UsedInIface> -> type:.namedata.*func(func() (syscall.Handle, error)) (syscall.Handle, []syscall.RawSockaddrAny, uint32, string, error)-
type:func(func() (syscall.Handle, error)) (syscall.Handle, []syscall.RawSockaddrAny, uint32, string, error) <UsedInIface> -> type:func() (syscall.Handle, error) <UsedInIface>
type:func(func() (syscall.Handle, error)) (syscall.Handle, []syscall.RawSockaddrAny, uint32, string, error) <UsedInIface> -> type:[]syscall.RawSockaddrAny <UsedInIface>
type:func() (syscall.Handle, error) <UsedInIface> -> type:.namedata.*func() (syscall.Handle, error)-
type:[]syscall.RawSockaddrAny <UsedInIface> -> type:.namedata.*[]syscall.RawSockaddrAny-
type:func(syscall.Sockaddr) error <UsedInIface> -> type:.namedata.*func(syscall.Sockaddr) error-
type:func(uint32) error <UsedInIface> -> type:.namedata.*func(uint32) error-
type:func(*syscall.ByHandleFileInformation) error <UsedInIface> -> type:.namedata.*func(*syscall.ByHandleFileInformation) error-
type:func(*syscall.ByHandleFileInformation) error <UsedInIface> -> type:*syscall.ByHandleFileInformation <UsedInIface>
type:*syscall.ByHandleFileInformation <UsedInIface> -> type:.namedata.*syscall.ByHandleFileInformation.
type:*syscall.ByHandleFileInformation <UsedInIface> -> type:syscall.ByHandleFileInformation <UsedInIface>
type:syscall.ByHandleFileInformation <UsedInIface> -> type:.eqfunc52
type:syscall.ByHandleFileInformation <UsedInIface> -> type:.namedata.VolumeSerialNumber.
type:syscall.ByHandleFileInformation <UsedInIface> -> type:.namedata.NumberOfLinks.
type:syscall.ByHandleFileInformation <UsedInIface> -> type:.namedata.FileIndexHigh.
type:syscall.ByHandleFileInformation <UsedInIface> -> type:.namedata.FileIndexLow.
type:func() (uint32, error) <UsedInIface> -> type:.namedata.*func() (uint32, error)-
type:func(int, int) (int, error) <UsedInIface> -> type:.namedata.*func(int, int) (int, error)-
type:func(string, bool) (string, error) <UsedInIface> -> type:.namedata.*func(string, bool) (string, error)-
type:func([]uint8) (int, syscall.Sockaddr, error) <UsedInIface> -> type:.namedata.*func([]uint8) (int, syscall.Sockaddr, error)-
type:func([]uint8, *syscall.SockaddrInet4) (int, error) <UsedInIface> -> type:.namedata.*func([]uint8, *syscall.SockaddrInet4) (int, error)-
type:func([]uint8, *syscall.SockaddrInet6) (int, error) <UsedInIface> -> type:.namedata.*func([]uint8, *syscall.SockaddrInet6) (int, error)-
type:func([]uint8, []uint8, int) (int, int, int, syscall.Sockaddr, error) <UsedInIface> -> type:.namedata.*func([]uint8, []uint8, int) (int, int, int, syscall.Sockaddr, error)-
type:func([]uint8, []uint8, int, *syscall.SockaddrInet4) (int, int, int, error) <UsedInIface> -> type:.namedata.*func([]uint8, []uint8, int, *syscall.SockaddrInet4) (int, int, int, error)-
type:func([]uint8, []uint8, int, *syscall.SockaddrInet6) (int, int, int, error) <UsedInIface> -> type:.namedata.*func([]uint8, []uint8, int, *syscall.SockaddrInet6) (int, int, int, error)-
type:func(int32, int32, *uint8, int32) error <UsedInIface> -> type:.namedata.*func(int32, int32, *uint8, int32) error-
type:func(int, int, *syscall.IPMreq) error <UsedInIface> -> type:.namedata.*func(int, int, *syscall.IPMreq) error-
type:func(int, int, *syscall.IPMreq) error <UsedInIface> -> type:*syscall.IPMreq <UsedInIface>
type:*syscall.IPMreq <UsedInIface> -> type:.namedata.*syscall.IPMreq.
type:*syscall.IPMreq <UsedInIface> -> type:syscall.IPMreq <UsedInIface>
type:syscall.IPMreq <UsedInIface> -> type:.namedata.Multiaddr.
type:func(int, int, *syscall.IPv6Mreq) error <UsedInIface> -> type:.namedata.*func(int, int, *syscall.IPv6Mreq) error-
type:func(int, int, *syscall.IPv6Mreq) error <UsedInIface> -> type:*syscall.IPv6Mreq <UsedInIface>
type:*syscall.IPv6Mreq <UsedInIface> -> type:.namedata.*syscall.IPv6Mreq.
type:*syscall.IPv6Mreq <UsedInIface> -> type:syscall.IPv6Mreq <UsedInIface>
type:syscall.IPv6Mreq <UsedInIface> -> type:.eqfunc20
type:func(int, int, [4]uint8) error <UsedInIface> -> type:.namedata.*func(int, int, [4]uint8) error-
type:func(int, int, int) error <UsedInIface> -> type:.namedata.*func(int, int, int) error-
type:func(int, int, *syscall.Linger) error <UsedInIface> -> type:.namedata.*func(int, int, *syscall.Linger) error-
type:func(int, int, *syscall.Linger) error <UsedInIface> -> type:*syscall.Linger <UsedInIface>
type:*syscall.Linger <UsedInIface> -> type:.namedata.*syscall.Linger.
type:*syscall.Linger <UsedInIface> -> type:syscall.Linger <UsedInIface>
type:syscall.Linger <UsedInIface> -> type:.namedata.Onoff.
type:syscall.Linger <UsedInIface> -> type:.namedata.Linger.
type:func(int) error <UsedInIface> -> type:.namedata.*func(int) error-
type:func(uint32, *uint8, uint32, *uint8, uint32, *uint32, *syscall.Overlapped, uintptr) error <UsedInIface> -> type:.namedata.*func(uint32, *uint8, uint32, *uint8, uint32, *uint32, *syscall.Overlapped, uintptr) error-
type:func([]uint8, []uint8, syscall.Sockaddr) (int, int, error) <UsedInIface> -> type:.namedata.*func([]uint8, []uint8, syscall.Sockaddr) (int, int, error)-
type:func([]uint8, []uint8, *syscall.SockaddrInet4) (int, int, error) <UsedInIface> -> type:.namedata.*func([]uint8, []uint8, *syscall.SockaddrInet4) (int, int, error)-
type:func([]uint8, []uint8, *syscall.SockaddrInet6) (int, int, error) <UsedInIface> -> type:.namedata.*func([]uint8, []uint8, *syscall.SockaddrInet6) (int, int, error)-
type:func([]uint8, syscall.Sockaddr) (int, error) <UsedInIface> -> type:.namedata.*func([]uint8, syscall.Sockaddr) (int, error)-
type:func(*[][]uint8) (int64, error) <UsedInIface> -> type:.namedata.*func(*[][]uint8) (int64, error)-
type:[2]syscall.RawSockaddrAny -> type:.eqfunc232
type:[2]syscall.RawSockaddrAny -> type:.namedata.*[2]syscall.RawSockaddrAny-
internal/poll.(*FD).ConnectEx.func1·f -> internal/poll.(*FD).ConnectEx.func1
internal/poll.(*FD).ConnectEx.func1 -> internal/poll.ConnectExFunc
internal/poll.ConnectExFunc -> syscall.ConnectEx·f
 -> go:info.func(syscall.Handle, syscall.Sockaddr, *uint8, uint32, *uint32, *syscall.Overlapped) error
internal/poll.(*FD).RawRead.func1·f -> internal/poll.(*FD).RawRead.func1
internal/poll.(*FD).RawRead.func1 -> syscall.WSARecv
syscall.WSARecv -> syscall.procWSARecv
syscall.WSARecv -> syscall.WSARecv.arginfo1
internal/poll.(*FD).Read.func1·f -> internal/poll.(*FD).Read.func1
internal/poll.(*FD).ReadFrom.func1·f -> internal/poll.(*FD).ReadFrom.func1
internal/poll.(*FD).ReadFrom.func1 -> syscall.WSARecvFrom
syscall.WSARecvFrom -> syscall.procWSARecvFrom
syscall.WSARecvFrom -> gclocals·tYBImsO1qkdSf6v7AnPOCw==
syscall.WSARecvFrom -> gclocals·DwD8Ml3eh+461YaKNjU0aA==
syscall.WSARecvFrom -> syscall.LookupAccountName.stkobj
syscall.WSARecvFrom -> syscall.WSARecvFrom.arginfo1
syscall.WSARecvFrom -> syscall.WSARecvFrom.argliveinfo
internal/poll.(*FD).ReadFromInet4.func1·f -> internal/poll.(*FD).ReadFromInet4.func1
internal/poll.(*FD).ReadFromInet6.func1·f -> internal/poll.(*FD).ReadFromInet6.func1
internal/poll.(*FD).ReadMsg.func1·f -> internal/poll.(*FD).ReadMsg.func1
internal/poll.(*FD).ReadMsg.func1 -> internal/syscall/windows.WSARecvMsg
internal/syscall/windows.WSARecvMsg -> internal/syscall/windows.loadWSASendRecvMsg
internal/syscall/windows.WSARecvMsg -> internal/syscall/windows.sendRecvMsgFunc
internal/syscall/windows.WSARecvMsg -> gclocals·8PU/naNFpPDAhMcIazbEjA==
internal/syscall/windows.WSARecvMsg -> gclocals·E0Kdujic7k32vhYy9W07jA==
internal/syscall/windows.loadWSASendRecvMsg -> internal/syscall/windows.loadWSASendRecvMsg.func1·f
 -> go:info.struct { internal/syscall/windows.once sync.Once; internal/syscall/windows.sendAddr uintptr; internal/syscall/windows.recvAddr uintptr; internal/syscall/windows.err error }
internal/syscall/windows.loadWSASendRecvMsg.func1·f -> internal/syscall/windows.loadWSASendRecvMsg.func1
internal/syscall/windows.loadWSASendRecvMsg.func1 -> syscall.Socket
internal/syscall/windows.loadWSASendRecvMsg.func1 -> internal/syscall/windows.loadWSASendRecvMsg.func1.1
internal/syscall/windows.loadWSASendRecvMsg.func1 -> internal/syscall/windows.WSAID_WSARECVMSG
internal/syscall/windows.loadWSASendRecvMsg.func1 -> internal/syscall/windows.WSAID_WSASENDMSG
internal/syscall/windows.loadWSASendRecvMsg.func1 -> internal/syscall/windows.loadWSASendRecvMsg.func1.opendefer
internal/syscall/windows.loadWSASendRecvMsg.func1.1 -> syscall.CloseHandle.wrapinfo
 -> go:info.syscall.GUID
syscall.Socket -> syscall.SocketDisableIPv6
syscall.Socket -> syscall.socket
syscall.socket -> syscall.procsocket
syscall.socket -> math/bits.Add32.arginfo1
internal/poll.(*FD).ReadMsgInet4.func1·f -> internal/poll.(*FD).ReadMsgInet4.func1
internal/poll.(*FD).ReadMsgInet6.func1·f -> internal/poll.(*FD).ReadMsgInet6.func1
internal/poll.(*FD).Write.func1·f -> internal/poll.(*FD).Write.func1
internal/poll.(*FD).Write.func1 -> syscall.WSASend
syscall.WSASend -> syscall.procWSASend
syscall.WSASend -> gclocals·4mitKMb/y/rdU4C4mk8tjw==
syscall.WSASend -> syscall.connectEx.arginfo1
internal/poll.(*FD).WriteMsg.func1·f -> internal/poll.(*FD).WriteMsg.func1
internal/poll.(*FD).WriteMsg.func1 -> internal/syscall/windows.WSASendMsg
internal/syscall/windows.WSASendMsg -> gclocals·ElHsL/z0Y7h98ZMemj4EvA==
internal/syscall/windows.WSASendMsg -> internal/syscall/windows.WSASendMsg.arginfo1
internal/syscall/windows.WSASendMsg -> fmt.(*ss).okVerb.argliveinfo
internal/poll.(*FD).WriteMsgInet4.func1·f -> internal/poll.(*FD).WriteMsgInet4.func1
internal/poll.(*FD).WriteMsgInet6.func1·f -> internal/poll.(*FD).WriteMsgInet6.func1
internal/poll.(*FD).WriteTo.func1·f -> internal/poll.(*FD).WriteTo.func1
internal/poll.(*FD).WriteTo.func1 -> syscall.WSASendto
syscall.WSASendto -> gclocals·mbCjG2a/FVAtKz2Jul5TaA==
syscall.WSASendto -> gclocals·Apua3eb1/P7ykvpNCoWQmg==
syscall.WSASendto -> syscall.WSASendto.arginfo1
syscall.WSASendto -> syscall.WSASendto.argliveinfo
internal/poll.(*FD).WriteTo.func2·f -> internal/poll.(*FD).WriteTo.func2
internal/poll.(*FD).Writev.func1·f -> internal/poll.(*FD).Writev.func1
internal/poll.glob..func1·f -> internal/poll.glob..func1
syscall.AcceptEx·f -> syscall.AcceptEx
syscall.AcceptEx -> syscall.procAcceptEx
syscall.AcceptEx -> gclocals·eSFjwfd0YsR1Yjy/YcFubw==
syscall.AcceptEx -> syscall.AcceptEx.arginfo1
syscall.ConnectEx·f -> syscall.ConnectEx
syscall.ConnectEx -> syscall.LoadConnectEx
syscall.ConnectEx -> go:string."failed to find ConnectEx: "
syscall.ConnectEx -> syscall.connectEx
syscall.ConnectEx -> gclocals·Uwyc16WFUxayr7wipOBiTw==
syscall.ConnectEx -> gclocals·RRGMOD1UTigT+bU81sCgbA==
syscall.ConnectEx -> syscall.ConnectEx.arginfo1
syscall.LoadConnectEx -> syscall.connectExFunc
syscall.LoadConnectEx -> syscall.LoadConnectEx.func1·f
syscall.connectEx -> gclocals·btvhTBrjMtxzcvhkY2Se3w==
 -> go:info.struct { syscall.once sync.Once; syscall.addr uintptr; syscall.err error }
syscall.LoadConnectEx.func1·f -> syscall.LoadConnectEx.func1
syscall.LoadConnectEx.func1 -> syscall.LoadConnectEx.func1.1
syscall.LoadConnectEx.func1 -> syscall.WSAID_CONNECTEX
syscall.LoadConnectEx.func1 -> syscall.LoadConnectEx.func1.opendefer
syscall.ReadConsole·f -> syscall.ReadConsole
syscall.ReadConsole -> syscall.procReadConsoleW
type:func(uint32) uint32 <UsedInIface> -> type:.namedata.*func(uint32) uint32-
type:func(uint32, uint32) bool <UsedInIface> -> type:.namedata.*func(uint32, uint32) bool-
type:.eqfunc.time.zone -> type:.eq.time.zone
 -> go:info.*time.zone
type:[]time.zone <UsedInIface> -> type:.namedata.*[]time.zone-
type:[]time.zoneTrans <UsedInIface> -> type:.namedata.*[]time.zoneTrans-
type:[]time.zoneTrans <UsedInIface> -> type:time.zoneTrans <UsedInIface>
type:time.zoneTrans <UsedInIface> -> type:.eqfunc.time.zoneTrans
type:time.zoneTrans <UsedInIface> -> type:.namedata.*time.zoneTrans-
type:time.zoneTrans <UsedInIface> -> type:*time.zoneTrans <UsedInIface>
type:time.zoneTrans <UsedInIface> -> type:.namedata.isstd-
type:time.zoneTrans <UsedInIface> -> type:.namedata.isutc-
type:.eqfunc.time.zoneTrans -> type:.eq.time.zoneTrans
 -> go:info.*time.zoneTrans
type:func() uint8 <UsedInIface> -> type:.namedata.*func() uint8-
type:func(int32) uint32 <UsedInIface> -> type:.namedata.*func(int32) uint32-
type:*os.fileStat <UsedInIface> -> os.(*fileStat).IsDir
type:*os.fileStat <UsedInIface> -> os.(*fileStat).Lock
type:*os.fileStat <UsedInIface> -> os.(*fileStat).ModTime
type:*os.fileStat <UsedInIface> -> os.(*fileStat).Mode
type:*os.fileStat <UsedInIface> -> os.(*fileStat).Name
type:*os.fileStat <UsedInIface> -> os.(*fileStat).Size
type:*os.fileStat <UsedInIface> -> os.(*fileStat).Sys
type:*os.fileStat <UsedInIface> -> os.(*fileStat).TryLock
type:*os.fileStat <UsedInIface> -> os.(*fileStat).Unlock
type:*os.rawConn <UsedInIface> -> os.(*rawConn).Control
type:*os.rawConn <UsedInIface> -> os.(*rawConn).Read
type:*os.rawConn <UsedInIface> -> os.(*rawConn).Write
type:*syscall.SockaddrUnix <UsedInIface> -> syscall.(*SockaddrUnix).sockaddr
type:*syscall.SockaddrInet4 <UsedInIface> -> syscall.(*SockaddrInet4).sockaddr
type:*syscall.SockaddrInet6 <UsedInIface> -> syscall.(*SockaddrInet6).sockaddr
type:*syscall.Filetime <UsedInIface> -> syscall.(*Filetime).Nanoseconds
type:*reflect.MapIter <UsedInIface> -> reflect.(*MapIter).Reset
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).Align
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).ArrayType
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).ChanDir
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).Common
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).ExportedMethods
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).FieldAlign
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).FuncType
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).GcSlice
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).HasName
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).IfaceIndir
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).InterfaceType
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).IsDirectIface
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).Key
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).Kind
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).MapType
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).NumMethod
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).Pointers
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).Size
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).StructType
type:*internal/abi.ArrayType <UsedInIface> -> internal/abi.(*ArrayType).Uncommon
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).Align
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).ArrayType
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).ChanDir
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).Common
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).Elem
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).ExportedMethods
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).FieldAlign
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).FuncType
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).GcSlice
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).HasName
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).IfaceIndir
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).InterfaceType
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).IsDirectIface
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).Key
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).Kind
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).Len
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).MapType
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).NumMethod
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).Pointers
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).Size
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).StructType
type:*internal/abi.InterfaceType <UsedInIface> -> internal/abi.(*InterfaceType).Uncommon
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).Align
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).ArrayType
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).ChanDir
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).Common
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).ExportedMethods
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).FieldAlign
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).FuncType
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).GcSlice
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).HasName
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).HashMightPanic
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).IfaceIndir
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).IndirectElem
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).IndirectKey
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).InterfaceType
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).IsDirectIface
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).Kind
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).Len
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).MapType
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).NeedKeyUpdate
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).NumMethod
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).Pointers
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).ReflexiveKey
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).Size
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).StructType
type:*internal/abi.MapType <UsedInIface> -> internal/abi.(*MapType).Uncommon
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Chdir
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Chmod
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Chown
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Close
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Fd
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Name
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Read
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.ReadAt
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.ReadDir
type:os.fileWithoutReadFrom <UsedInIface> -> type:func(os.fileWithoutReadFrom) <UsedInIface>
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.ReadFrom
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Readdir
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Readdirnames
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Seek
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.SetDeadline
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.SetReadDeadline
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.SetWriteDeadline
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Stat
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Sync
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.SyscallConn
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Truncate
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.Write
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.WriteAt
type:os.fileWithoutReadFrom <UsedInIface> -> os.fileWithoutReadFrom.WriteString
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Chdir
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Chmod
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Chown
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Close
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Fd
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Name
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Read
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).ReadAt
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).ReadDir
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).ReadFrom
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Readdir
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Readdirnames
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Seek
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).SetDeadline
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).SetReadDeadline
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).SetWriteDeadline
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Stat
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Sync
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).SyscallConn
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Truncate
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).Write
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).WriteAt
type:*os.fileWithoutReadFrom <UsedInIface> -> os.(*fileWithoutReadFrom).WriteString
type:os.dirEntry <UsedInIface> -> os.dirEntry.Info
type:os.dirEntry <UsedInIface> -> os.dirEntry.IsDir
type:os.dirEntry <UsedInIface> -> os.dirEntry.Name
type:os.dirEntry <UsedInIface> -> os.dirEntry.String
type:os.dirEntry <UsedInIface> -> os.dirEntry.Type
type:*os.dirEntry <UsedInIface> -> os.(*dirEntry).Info
type:*os.dirEntry <UsedInIface> -> os.(*dirEntry).IsDir
type:*os.dirEntry <UsedInIface> -> os.(*dirEntry).Name
type:*os.dirEntry <UsedInIface> -> os.(*dirEntry).String
type:*os.dirEntry <UsedInIface> -> os.(*dirEntry).Type
type:time.Time <UsedInIface> -> type:func(time.Duration) time.Time <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).Add
type:time.Time <UsedInIface> -> type:func(int, int, int) time.Time <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).AddDate
type:time.Time <UsedInIface> -> time.Time.AddDate
type:time.Time <UsedInIface> -> type:func(time.Time) bool <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).After
type:time.Time <UsedInIface> -> time.Time.After
type:time.Time <UsedInIface> -> type:func([]uint8, string) []uint8 <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).AppendFormat
type:time.Time <UsedInIface> -> time.Time.AppendFormat
type:time.Time <UsedInIface> -> time.(*Time).Before
type:time.Time <UsedInIface> -> type:func() (int, int, int) <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).Clock
type:time.Time <UsedInIface> -> time.Time.Clock
type:time.Time <UsedInIface> -> type:func(time.Time) int <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).Compare
type:time.Time <UsedInIface> -> time.Time.Compare
type:time.Time <UsedInIface> -> type:func() (int, time.Month, int) <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).Date
type:time.Time <UsedInIface> -> time.Time.Date
type:time.Time <UsedInIface> -> time.(*Time).Day
type:time.Time <UsedInIface> -> time.Time.Day
type:time.Time <UsedInIface> -> time.(*Time).Equal
type:time.Time <UsedInIface> -> time.(*Time).Format
type:time.Time <UsedInIface> -> time.Time.Format
type:time.Time <UsedInIface> -> time.(*Time).GoString
type:time.Time <UsedInIface> -> time.Time.GoString
type:time.Time <UsedInIface> -> type:func() ([]uint8, error) <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).GobEncode
type:time.Time <UsedInIface> -> time.Time.GobEncode
type:time.Time <UsedInIface> -> time.(*Time).Hour
type:time.Time <UsedInIface> -> time.Time.Hour
type:time.Time <UsedInIface> -> type:func() (int, int) <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).ISOWeek
type:time.Time <UsedInIface> -> time.Time.ISOWeek
type:time.Time <UsedInIface> -> type:func(*time.Location) time.Time <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).In
type:time.Time <UsedInIface> -> time.Time.In
type:time.Time <UsedInIface> -> time.(*Time).IsDST
type:time.Time <UsedInIface> -> time.Time.IsDST
type:time.Time <UsedInIface> -> time.(*Time).IsZero
type:time.Time <UsedInIface> -> time.Time.IsZero
type:time.Time <UsedInIface> -> time.(*Time).Local
type:time.Time <UsedInIface> -> time.Time.Local
type:time.Time <UsedInIface> -> type:func() *time.Location <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).Location
type:time.Time <UsedInIface> -> time.Time.Location
type:time.Time <UsedInIface> -> time.(*Time).MarshalBinary
type:time.Time <UsedInIface> -> time.Time.MarshalBinary
type:time.Time <UsedInIface> -> time.(*Time).MarshalJSON
type:time.Time <UsedInIface> -> time.Time.MarshalJSON
type:time.Time <UsedInIface> -> time.(*Time).MarshalText
type:time.Time <UsedInIface> -> time.Time.MarshalText
type:time.Time <UsedInIface> -> time.(*Time).Minute
type:time.Time <UsedInIface> -> time.Time.Minute
type:time.Time <UsedInIface> -> type:func() time.Month <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).Month
type:time.Time <UsedInIface> -> time.Time.Month
type:time.Time <UsedInIface> -> time.(*Time).Nanosecond
type:time.Time <UsedInIface> -> time.Time.Nanosecond
type:time.Time <UsedInIface> -> time.(*Time).Round
type:time.Time <UsedInIface> -> time.Time.Round
type:time.Time <UsedInIface> -> time.(*Time).Second
type:time.Time <UsedInIface> -> time.Time.Second
type:time.Time <UsedInIface> -> time.(*Time).String
type:time.Time <UsedInIface> -> time.Time.String
type:time.Time <UsedInIface> -> type:func(time.Time) time.Duration <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).Sub
type:time.Time <UsedInIface> -> time.(*Time).Truncate
type:time.Time <UsedInIface> -> time.Time.Truncate
type:time.Time <UsedInIface> -> time.(*Time).UTC
type:time.Time <UsedInIface> -> time.Time.UTC
type:time.Time <UsedInIface> -> time.(*Time).Unix
type:time.Time <UsedInIface> -> time.Time.Unix
type:time.Time <UsedInIface> -> time.(*Time).UnixMicro
type:time.Time <UsedInIface> -> time.Time.UnixMicro
type:time.Time <UsedInIface> -> time.(*Time).UnixMilli
type:time.Time <UsedInIface> -> time.Time.UnixMilli
type:time.Time <UsedInIface> -> time.(*Time).UnixNano
type:time.Time <UsedInIface> -> time.Time.UnixNano
type:time.Time <UsedInIface> -> type:func() time.Weekday <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).Weekday
type:time.Time <UsedInIface> -> time.Time.Weekday
type:time.Time <UsedInIface> -> time.(*Time).Year
type:time.Time <UsedInIface> -> time.Time.Year
type:time.Time <UsedInIface> -> time.(*Time).YearDay
type:time.Time <UsedInIface> -> time.Time.YearDay
type:time.Time <UsedInIface> -> type:func() (string, int) <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).Zone
type:time.Time <UsedInIface> -> time.Time.Zone
type:time.Time <UsedInIface> -> type:func() (time.Time, time.Time) <UsedInIface>
type:time.Time <UsedInIface> -> time.(*Time).ZoneBounds
type:time.Time <UsedInIface> -> time.Time.ZoneBounds
type:*time.Location <UsedInIface> -> time.(*Location).String
type:*time.Time <UsedInIface> -> type:func([]uint8) error <UsedInIface>
type:*time.Time <UsedInIface> -> time.(*Time).GobDecode
type:*time.Time <UsedInIface> -> time.(*Time).UnmarshalBinary
type:*time.Time <UsedInIface> -> time.(*Time).UnmarshalJSON
type:*time.Time <UsedInIface> -> time.(*Time).UnmarshalText
type:io/fs.FileMode <UsedInIface> -> io/fs.(*FileMode).IsDir
type:io/fs.FileMode <UsedInIface> -> io/fs.FileMode.IsDir
type:io/fs.FileMode <UsedInIface> -> io/fs.(*FileMode).IsRegular
type:io/fs.FileMode <UsedInIface> -> io/fs.FileMode.IsRegular
type:io/fs.FileMode <UsedInIface> -> io/fs.(*FileMode).Perm
type:io/fs.FileMode <UsedInIface> -> io/fs.FileMode.Perm
type:io/fs.FileMode <UsedInIface> -> io/fs.(*FileMode).String
type:io/fs.FileMode <UsedInIface> -> io/fs.FileMode.String
type:io/fs.FileMode <UsedInIface> -> io/fs.(*FileMode).Type
type:io/fs.FileMode <UsedInIface> -> io/fs.FileMode.Type
reflect.(*MapIter).Reset -> gclocals·rL1CRQQXreqwmA1Jra1Ybw==
os.dirEntry.String -> io/fs.FormatDirEntry
os.fileWithoutReadFrom.ReadFrom -> os.fileWithoutReadFrom.ReadFrom.arginfo1
os.(*rawConn).Control -> gclocals·odMZdLmsojEGRRGAW9SbqA==
os.(*fileStat).Sys -> type:syscall.Win32FileAttributeData
os.(*fileStat).Sys -> type:*syscall.Win32FileAttributeData <UsedInIface>
 -> go:info.os.dirEntry.Name$abstract
 -> go:info.os.(*fileStat).Name$abstract
 -> go:info.os.dirEntry.IsDir$abstract
 -> go:info.os.dirEntry.Type$abstract
 -> go:info.os.(*fileStat).Mode$abstract
 -> go:info.os.(*fileStat).isSymlink$abstract
 -> go:info.io/fs.FileMode.Type$abstract
 -> go:info.os.dirEntry.Info$abstract
 -> go:info.os.dirEntry.String$abstract
 -> go:info.os.fileWithoutReadFrom.ReadFrom$abstract
 -> go:info.*os.rawConn
 -> go:info.io/fs.FileMode.IsDir$abstract
 -> go:info.syscall.(*Filetime).Nanoseconds$abstract
 -> go:info.time.Unix$abstract
 -> go:info.time.unixTime$abstract
io/fs.FormatDirEntry -> gclocals·V3+vMt8ZDQ8M4ZVWFOwtFA==
io/fs.FormatDirEntry -> gclocals·bvX+fZJ9xIDJgA7Dv/t+KA==
io/fs.FormatDirEntry -> go:sehuw.12.ARMCBRMDEFAAAAAA
io/fs.FileMode.String -> go:string."dalTLDpSugct?"
io/fs.FileMode.String -> go:string."rwxrwxrwx"
 -> go:info.io/fs.DirEntry
 -> go:info.io/fs.FileMode.IsRegular$abstract
type:*syscall.Win32FileAttributeData <UsedInIface> -> type:.namedata.*syscall.Win32FileAttributeData.
type:*syscall.Win32FileAttributeData <UsedInIface> -> type:syscall.Win32FileAttributeData <UsedInIface>
type:syscall.Win32FileAttributeData <UsedInIface> -> type:.eqfunc36
time.Time.String -> go:string."2006-01-02 15:04:05.999999999 -0700 MST"
time.Time.String -> time.appendInt
time.Time.String -> go:sehuw.12.ARMCBRMDEFAAAAAA
time.Time.GoString -> time.Time.abs
time.Time.GoString -> time.absDate
time.Time.GoString -> time.longMonthNames
time.Time.GoString -> time.UTC
time.Time.GoString -> time.quote
time.Time.GoString -> gclocals·58z1mGvLs14h2/lZ3ir9cg==
time.Time.GoString -> gclocals·HbG2hk9lZcANNUMvK5kBrQ==
time.Time.GoString -> time.Time.GoString.stkobj
time.Time.GoString -> go:sehuw.12.ARYCBRYDE1AAAAAA
time.Time.AppendFormat -> go:string."2006-01-02T15:04:05.999999999Z07:00"
time.Time.AppendFormat -> time.Time.appendFormatRFC3339
time.Time.AppendFormat -> go:string."2006-01-02T15:04:05Z07:00"
time.Time.AppendFormat -> time.Time.appendFormat
time.Time.AppendFormat -> gclocals·VAl31sLNaHwRpAg1aHbVOw==
time.Time.AppendFormat -> time.Time.AppendFormat.arginfo1
time.Time.AppendFormat -> time.Time.AppendFormat.argliveinfo
time.Time.appendFormat -> time.Time.locabs
time.Time.appendFormat -> time.nextStdChunk
time.Time.appendFormat -> time.appendNano
time.Time.appendFormat -> time.longDayNames
time.Time.appendFormat -> go:string."%!Weekday("
time.Time.appendFormat -> go:string."%!Month("
time.Time.appendFormat -> gclocals·MiyH8QGE6Ig3mZqhb2cCdw==
time.Time.appendFormat -> gclocals·f+q/AQ0aUZgh1JpbD6oqHw==
time.nextStdChunk -> time.std0x
time.nextStdChunk -> go:sehuw.12.AQQCBQQDAVAAAAAA
time.Time.appendFormatRFC3339 -> gclocals·W3DkWmorokLPWdLTD1fQLQ==
time.Time.appendFormatRFC3339 -> gclocals·dUEftoxRTeuyFa0s2nAFyA==
time.Time.abs -> time.(*Location).get
time.Time.abs -> time.utcLoc
time.Time.abs -> time.(*Location).lookup
time.Time.locabs -> go:string."UTC"
time.Time.Date -> time.Time.date
time.Time.AddDate -> time.Date
time.absDate -> time.daysBefore
time.Time.In -> time..stmp_16
time.Time.ZoneBounds -> gclocals·7ROMz7tcEEYO6nr8ZXF9Jg==
time.Time.ZoneBounds -> time.Time.ZoneBounds.stkobj
time.Time.MarshalBinary -> go:string."Time.MarshalBinary: unexpected zone offset"
time.Time.MarshalBinary -> type:[15]uint8
time.(*Time).UnmarshalBinary -> go:string."Time.UnmarshalBinary: unsupported version"
time.(*Time).UnmarshalBinary -> time.FixedZone
time.(*Time).UnmarshalBinary -> go:string."Time.UnmarshalBinary: invalid length"
time.(*Time).UnmarshalBinary -> go:string."Time.UnmarshalBinary: no data"
time.Time.MarshalJSON -> time.Time.appendStrictRFC3339
time.Time.MarshalJSON -> go:string."Time.MarshalJSON: "
time.Time.MarshalJSON -> gclocals·co8FNWpSzfxCtvpQXO3HlA==
time.Time.MarshalJSON -> gclocals·r3bqP//WDynhHqEPOkz91Q==
time.Time.appendStrictRFC3339 -> go:string."timezone hour outside of range [0,23]"
time.Time.appendStrictRFC3339 -> go:string."year outside of range [0,9999]"
time.(*Time).UnmarshalJSON -> go:string."Time.UnmarshalJSON: input is not a JSON string"
time.(*Time).UnmarshalJSON -> time.parseStrictRFC3339
time.parseStrictRFC3339 -> time..dict.parseRFC3339[[]uint8]
time.parseStrictRFC3339 -> time.parseRFC3339[go.shape.[]uint8]
time.parseStrictRFC3339 -> time.Parse
time.Parse -> time..dict.parseRFC3339[string]
time.Parse -> time.parseRFC3339[go.shape.string]
time.Parse -> time.parse
time.parse -> time.skip
time.parse -> time.parseTimeZone
time.parse -> time.errBad
time.parse -> go:string."00"
time.parse -> time.getnum
time.parse -> time..dict.parseNanoseconds[string]
time.parse -> time.parseNanoseconds[go.shape.string]
time.parse -> time.shortMonthNames
time.parse -> time.lookup
time.parse -> time.shortDayNames
time.parse -> go:string."month"
time.parse -> time..dict.atoi[string]
time.parse -> time.atoi[go.shape.string]
time.parse -> go:string."hour"
time.parse -> go:string."second"
time.parse -> go:string."minute"
time.parse -> type:time.ParseError
time.parse -> go:string.": day-of-year does not match month"
time.parse -> go:itab.*time.ParseError,error
time.parse -> go:string.": day-of-year does not match day"
time.parse -> go:string.": day-of-year out of range"
time.parse -> go:string.": day out of range"
time.parse -> time.(*Location).lookupName
time.parse -> go:string.": extra text: "
time.parse -> go:string." out of range"
time.parse -> gclocals·CNljmfuAxUH+rnPvODX8ww==
time.parse -> gclocals·T86d1iZAWPDQpqDi7jqcKw==
time.parse -> os.Chtimes.func1.stkobj
time.parse -> time.parse.arginfo1
time.parseTimeZone -> time.parseSignedOffset
time.parseSignedOffset -> time.errLeadingInt
time.Time.MarshalText -> go:string."Time.MarshalText: "
time.Date -> time..stmp_17
time.Date -> gclocals·8tQ7dPsIQw2sNm3lqUMC8Q==
time.Date -> time.Date.argliveinfo
time.Time.Truncate -> time.div
time.(*Location).get -> time.localOnce
time.(*Location).get -> time.initLocal·f
time.FixedZone -> time.unnamedFixedZonesOnce
time.FixedZone -> time.FixedZone.func1·f
time.FixedZone -> time.unnamedFixedZones
time.FixedZone -> type:[1]time.zone
time.FixedZone -> type:[1]time.zoneTrans
time.(*Location).lookup -> time.(*Location).lookupFirstZone
time.(*Location).lookup -> time.tzset
time.tzset -> time.tzsetName
time.tzset -> time.tzsetOffset
time.tzset -> go:string.",M3.2.0,M11.1.0"
time.tzset -> time.tzsetRule
time.tzset -> time.tzruleTime
time.tzset -> gclocals·CE1FQgh0mjM/tyIqvYScPg==
time.tzsetRule -> gclocals·SvLktiEPfjtM1AF1Pm3duQ==
time.tzsetRule -> gclocals·oXuWcfSUPVX2co00OPP3Yg==
time.tzruleTime -> time.tzruleTime.arginfo1
time.tzruleTime -> runtime.(*abiPart).tryMerge.argliveinfo
time.(*Location).lookupName -> gclocals·/QMwGeqLy7yvPWkBXoIGaw==
type:time.ParseError -> type:.eqfunc.time.ParseError
type:time.ParseError -> type:.namedata.*time.ParseError.
type:time.ParseError -> type:*time.ParseError <UsedInIface>
type:time.ParseError -> type:.namedata.Layout.
type:time.ParseError -> type:.namedata.LayoutElem.
type:time.ParseError -> type:.namedata.ValueElem.
type:time.ParseError -> type:.namedata.Message.
type:*time.ParseError <UsedInIface> -> type:time.ParseError <UsedInIface>
 -> go:info.[6]int
time.longDayNames -> time..stmp_0
time.shortDayNames -> time..stmp_1
time.shortMonthNames -> time..stmp_2
time.longMonthNames -> time..stmp_3
time.errBad -> time..stmp_5
time.errLeadingInt -> time..stmp_6
 -> go:info.[13]int32
 -> go:info.[]*time.Location
time..stmp_0 -> go:string."Sunday"
time..stmp_0 -> go:string."Monday"
time..stmp_0 -> go:string."Tuesday"
time..stmp_0 -> go:string."Wednesday"
time..stmp_0 -> go:string."Thursday"
time..stmp_0 -> go:string."Friday"
time..stmp_0 -> go:string."Saturday"
time..stmp_1 -> go:string."Sun"
time..stmp_1 -> go:string."Mon"
time..stmp_1 -> go:string."Tue"
time..stmp_1 -> go:string."Wed"
time..stmp_1 -> go:string."Thu"
time..stmp_1 -> go:string."Fri"
time..stmp_1 -> go:string."Sat"
time..stmp_2 -> go:string."Jan"
time..stmp_2 -> go:string."Feb"
time..stmp_2 -> go:string."Mar"
time..stmp_2 -> go:string."Apr"
time..stmp_2 -> go:string."May"
time..stmp_2 -> go:string."Jun"
time..stmp_2 -> go:string."Jul"
time..stmp_2 -> go:string."Aug"
time..stmp_2 -> go:string."Sep"
time..stmp_2 -> go:string."Oct"
time..stmp_2 -> go:string."Nov"
time..stmp_2 -> go:string."Dec"
time..stmp_3 -> go:string."January"
time..stmp_3 -> go:string."February"
time..stmp_3 -> go:string."March"
time..stmp_3 -> go:string."April"
time..stmp_3 -> go:string."June"
time..stmp_3 -> go:string."July"
time..stmp_3 -> go:string."August"
time..stmp_3 -> go:string."September"
time..stmp_3 -> go:string."October"
time..stmp_3 -> go:string."November"
time..stmp_3 -> go:string."December"
time..stmp_5 -> go:string."bad value for field"
time..stmp_6 -> go:string."time: bad [0-9]*"
 -> go:info.time.startsWithLowerCase$abstract
 -> go:info.time.isDigit[go.shape.string]$abstract
 -> go:info.time.stdFracSecond$abstract
 -> go:info.time.match$abstract
 -> go:info.time.appendInt.func1$abstract
 -> go:info.time.digitsLen$abstract
 -> go:info.time.separator$abstract
 -> go:info.time.Month
 -> go:info.time.absClock$abstract
 -> go:info.time.Time.Nanosecond$abstract
 -> go:info.time.Time.Location$abstract
 -> go:info.time.absWeekday$abstract
 -> go:info.time.Month.String$abstract
 -> go:info.time.fmtInt$abstract
 -> go:info.time.Weekday.String$abstract
 -> go:info.time.cutspace$abstract
 -> go:info.time.newParseError$abstract
 -> go:info.time.cloneString$abstract
 -> go:info.time.commaOrPeriod$abstract
 -> go:info.time.isLeap$abstract
 -> go:info.time.daysIn$abstract
 -> go:info.time.(*Time).unixSec$abstract
 -> go:info.time.(*Time).setLoc$abstract
 -> go:info.time.getnum3$abstract
 -> go:info.time.parseGMT$abstract
 -> go:info.time.leadingInt[go.shape.string]$abstract
 -> go:info.time.Time.appendStrictRFC3339.func1$abstract
 -> go:info.time.Time.Date$abstract
 -> go:info.time.Time.Year$abstract
 -> go:info.time.Time.Month$abstract
 -> go:info.time.Time.Day$abstract
 -> go:info.time.Time.Weekday$abstract
 -> go:info.time.Weekday
 -> go:info.time.Time.Hour$abstract
 -> go:info.time.Time.Minute$abstract
 -> go:info.time.Time.Second$abstract
 -> go:info.time.Time.YearDay$abstract
 -> go:info.time.Time.UTC$abstract
 -> go:info.time.Time.Local$abstract
 -> go:info.time.Time.In$abstract
 -> go:info.time.Time.Unix$abstract
 -> go:info.time.Time.UnixMilli$abstract
 -> go:info.time.Time.UnixMicro$abstract
 -> go:info.time.Time.UnixNano$abstract
 -> go:info.int16
 -> go:info.int8
 -> go:info.time.Time.GobEncode$abstract
 -> go:info.time.norm$abstract
 -> go:info.time.daysSinceEpoch$abstract
 -> go:info.time.lessThanHalf$abstract
 -> go:info.time.fixedZone$abstract
 -> go:info.time.(*Location).firstZoneUsed$abstract
 -> go:info.time.rule
 -> go:info.time.tzsetNum$abstract
os.fileWithoutReadFrom.Read -> os.fileWithoutReadFrom.Read.arginfo1
os.fileWithoutReadFrom.ReadAt -> os.fileWithoutReadFrom.ReadAt.arginfo1
os.(*fileWithoutReadFrom).ReadFrom -> gclocals·Jog/qYB4a+fiwM7je5AA/g==
type:func(os.fileWithoutReadFrom) <UsedInIface> -> type:.namedata.*func(os.fileWithoutReadFrom)-
go:info.syscall.(*Filetime).Nanoseconds$abstract -> go:info.*syscall.Filetime
go:info.os.dirEntry.Info$abstract -> go:info.os.dirEntry
internal/abi.(*MapType).Uncommon -> internal/abi.(*MapType).Uncommon.jump7
internal/abi.(*ArrayType).Uncommon -> internal/abi.(*ArrayType).Uncommon.jump7
internal/abi.(*InterfaceType).Uncommon -> internal/abi.(*InterfaceType).Uncommon.jump7
io/fs.(*FileMode).IsDir -> go:sehuw.12.AQQCBQQDAVAAAAAA
time..stmp_16 -> go:string."time: missing Location in call to Time.In"
time..stmp_17 -> go:string."time: missing Location in call to Date"
time.parseRFC3339[go.shape.[]uint8] -> time.parseNanoseconds[go.shape.[]uint8]
time.parseRFC3339[go.shape.[]uint8] -> gclocals·wPjHh15siWtDHYHkYUT7UQ==
time.parseRFC3339[go.shape.[]uint8] -> gclocals·FF2IbuS5cqbhJrOkmNcZzw==
time.parseRFC3339[go.shape.[]uint8] -> time.parseRFC3339[go.shape.[]uint8].arginfo1
time.parseRFC3339[go.shape.[]uint8] -> time.parseRFC3339[go.shape.[]uint8].argliveinfo
 -> go:info.go.shape.[]uint8
 -> go:info.time.parseRFC3339[go.shape.[]uint8].func1$abstract
 -> go:info.time.isDigit[go.shape.[]uint8]$abstract
time.parseNanoseconds[go.shape.[]uint8] -> time.atoi[go.shape.[]uint8]
time.parseNanoseconds[go.shape.[]uint8] -> go:string."fractional second"
time.atoi[go.shape.[]uint8] -> time.errAtoi
time.atoi[go.shape.[]uint8] -> time.atoi[go.shape.[]uint8].arginfo1
time.errAtoi -> time..stmp_4
time..stmp_4 -> go:string."time: invalid number"
 -> go:info.time.leadingInt[go.shape.[]uint8]$abstract
time.parseNanoseconds[go.shape.string] -> time.parseNanoseconds[go.shape.string].arginfo1
 -> go:info.go.shape.string
time.atoi[go.shape.string] -> time.leadingInt[go.shape.string].arginfo1
time.parseRFC3339[go.shape.string] -> gclocals·M5hP89prLCfazoYwObsN/g==
time.parseRFC3339[go.shape.string] -> time.parseRFC3339[go.shape.string].argliveinfo
 -> go:info.time.parseRFC3339[go.shape.string].func1$abstract
time..dict.parseRFC3339[[]uint8] -> time..dict.isDigit[[]uint8]
time..dict.parseRFC3339[[]uint8] -> time..dict.parseNanoseconds[[]uint8]
time..dict.parseRFC3339[[]uint8] -> type:func([]uint8, int, int) int <UsedInIface>
time..dict.parseNanoseconds[[]uint8] -> time..dict.atoi[[]uint8]
time..dict.atoi[[]uint8] -> time..dict.leadingInt[[]uint8]
type:.eqfunc.time.ParseError -> type:.eq.time.ParseError
 -> go:info.*time.ParseError
time..dict.atoi[string] -> time..dict.leadingInt[string]
time..dict.parseRFC3339[string] -> time..dict.isDigit[string]
time..dict.parseRFC3339[string] -> type:func(string, int, int) int <UsedInIface>
go:info.time.(*Location).firstZoneUsed$abstract -> go:info.time.zoneTrans
type:func() *time.Location <UsedInIface> -> type:.namedata.*func() *time.Location-
type:func(time.Duration) time.Time <UsedInIface> -> type:.namedata.*func(time.Duration) time.Time-
type:func(time.Duration) time.Time <UsedInIface> -> type:time.Duration <UsedInIface>
type:time.Duration <UsedInIface> -> type:.namedata.*time.Duration.
type:time.Duration <UsedInIface> -> type:*time.Duration <UsedInIface>
type:time.Duration <UsedInIface> -> type:.namedata.Abs.
type:time.Duration <UsedInIface> -> type:.namedata.Hours.
type:time.Duration <UsedInIface> -> type:.namedata.Microseconds.
type:time.Duration <UsedInIface> -> type:.namedata.Milliseconds.
type:time.Duration <UsedInIface> -> type:.namedata.Minutes.
type:time.Duration <UsedInIface> -> type:.namedata.Seconds.
type:func(int, int, int) time.Time <UsedInIface> -> type:.namedata.*func(int, int, int) time.Time-
type:func(time.Time) bool <UsedInIface> -> type:.namedata.*func(time.Time) bool-
type:func([]uint8, string) []uint8 <UsedInIface> -> type:.namedata.*func([]uint8, string) []uint8-
type:func() (int, int, int) <UsedInIface> -> type:.namedata.*func() (int, int, int)-
type:func(time.Time) int <UsedInIface> -> type:.namedata.*func(time.Time) int-
type:func() (int, time.Month, int) <UsedInIface> -> type:.namedata.*func() (int, time.Month, int)-
type:func() (int, time.Month, int) <UsedInIface> -> type:time.Month <UsedInIface>
type:time.Month <UsedInIface> -> type:.namedata.*time.Month.
type:time.Month <UsedInIface> -> type:*time.Month <UsedInIface>
type:func([]uint8) error <UsedInIface> -> type:.namedata.*func([]uint8) error-
type:func() ([]uint8, error) <UsedInIface> -> type:.namedata.*func() ([]uint8, error)-
type:func() (int, int) <UsedInIface> -> type:.namedata.*func() (int, int)-
type:func(*time.Location) time.Time <UsedInIface> -> type:.namedata.*func(*time.Location) time.Time-
type:func() time.Month <UsedInIface> -> type:.namedata.*func() time.Month-
type:func(time.Time) time.Duration <UsedInIface> -> type:.namedata.*func(time.Time) time.Duration-
type:func() time.Weekday <UsedInIface> -> type:.namedata.*func() time.Weekday-
type:func() time.Weekday <UsedInIface> -> type:time.Weekday <UsedInIface>
type:time.Weekday <UsedInIface> -> type:.namedata.*time.Weekday.
type:time.Weekday <UsedInIface> -> type:*time.Weekday <UsedInIface>
type:func() (string, int) <UsedInIface> -> type:.namedata.*func() (string, int)-
type:func() (time.Time, time.Time) <UsedInIface> -> type:.namedata.*func() (time.Time, time.Time)-
type:[15]uint8 -> type:.eqfunc15
type:[15]uint8 -> type:.namedata.*[15]uint8-
type:[1]time.zone -> type:.eqfunc.[1]time.zone
type:[1]time.zone -> type:.namedata.*[1]time.zone-
type:.eqfunc.[1]time.zone -> type:.eq.[1]time.zone
 -> go:info.*[1]time.zone
type:[1]time.zoneTrans -> type:.eqfunc.[1]time.zoneTrans
type:[1]time.zoneTrans -> type:.namedata.*[1]time.zoneTrans-
type:.eqfunc.[1]time.zoneTrans -> type:.eq.[1]time.zoneTrans
 -> go:info.*[1]time.zoneTrans
type:func([]uint8, int, int) int <UsedInIface> -> type:.namedata.*func([]uint8, int, int) int-
type:func(string, int, int) int <UsedInIface> -> type:.namedata.*func(string, int, int) int-
time.FixedZone.func1·f -> time.FixedZone.func1
time.initLocal·f -> time.initLocal
time.initLocal -> syscall.GetTimeZoneInformation
time.initLocal -> time.initLocalFromTZI
syscall.GetTimeZoneInformation -> syscall.procGetTimeZoneInformation
 -> go:info.*syscall.Timezoneinformation
time.initLocalFromTZI -> go:string."Local"
time.initLocalFromTZI -> time.abbrev
time.initLocalFromTZI -> time.pseudoUnix
time.initLocalFromTZI -> gclocals·cf7VOICj0zcBVlMDnsePvA==
time.abbrev -> time.abbrs
time.abbrev -> type:map[string]time.abbr
time.abbrev -> time.toEnglishName
time.abbrev -> gclocals·QuQ1WCX1cl6XPp6QZtg9ag==
time.abbrev -> gclocals·V4pLL3H6l9FFNOChqG0S6Q==
time.toEnglishName -> go:string."SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"
time.toEnglishName -> internal/syscall/windows/registry.OpenKey
time.toEnglishName -> time.toEnglishName.func1
time.toEnglishName -> internal/syscall/windows/registry.Key.ReadSubKeyNames
time.toEnglishName -> time.matchZoneKey
time.toEnglishName -> go:string."English name for time zone \""
time.toEnglishName -> go:string."\" not found in registry"
time.toEnglishName -> gclocals·nRXfS69/NShccMUxwklFYg==
time.toEnglishName -> gclocals·1kt9XqEtm1i72x+3ZGdocA==
time.toEnglishName -> time.toEnglishName.opendefer
time.matchZoneKey -> time.matchZoneKey.func1
time.matchZoneKey -> internal/syscall/windows/registry.procRegLoadMUIStringW
time.matchZoneKey -> go:string."MUI_Std"
time.matchZoneKey -> internal/syscall/windows/registry.Key.GetMUIStringValue
time.matchZoneKey -> go:string."MUI_Dlt"
time.matchZoneKey -> go:string."Std"
time.matchZoneKey -> internal/syscall/windows/registry.Key.GetStringValue
time.matchZoneKey -> go:string."Dlt"
time.matchZoneKey -> gclocals·ICfq+2A7NmDHul2wxI7zwA==
time.matchZoneKey -> gclocals·dAM7fVbfbdS30ht8k3lz/w==
time.matchZoneKey.func1 -> internal/syscall/windows/registry.Key.Close
time.matchZoneKey.func1 -> internal/syscall/windows/registry.Key.Close.wrapinfo
time.pseudoUnix -> gclocals·weztxl41G4QdXmAByYVRiA==
time.abbrs -> time.map.init.1
time.map.init.1 -> time..stmp_24
time.map.init.1 -> time..stmp_23
 -> go:info.map[string]time.abbr
 -> go:info.internal/syscall/windows/registry.Key
 -> go:info.internal/syscall/windows/registry.LoadRegLoadMUIString$abstract
 -> go:info.time.extractCAPS$abstract
 -> go:info.*syscall.Systemtime
 -> go:info.syscall.Timezoneinformation
internal/syscall/windows/registry.Key.Close -> syscall.RegCloseKey
internal/syscall/windows/registry.Key.Close -> go:sehuw.12.AQoCBQoDB1AAAAAA
syscall.RegCloseKey -> syscall.procRegCloseKey
internal/syscall/windows/registry.OpenKey -> syscall.RegOpenKeyEx
syscall.RegOpenKeyEx -> syscall.procRegOpenKeyExW
syscall.RegOpenKeyEx -> gclocals·/WpA//FnCNa3erTfgcZQ8w==
syscall.RegOpenKeyEx -> syscall.RegOpenKeyEx.arginfo1
 -> go:info.*syscall.Handle
internal/syscall/windows/registry.Key.ReadSubKeyNames -> runtime.LockOSThread
internal/syscall/windows/registry.Key.ReadSubKeyNames -> runtime.UnlockOSThread·f
internal/syscall/windows/registry.Key.ReadSubKeyNames -> syscall.regEnumKeyEx
internal/syscall/windows/registry.Key.ReadSubKeyNames -> internal/syscall/windows/registry..stmp_11
internal/syscall/windows/registry.Key.ReadSubKeyNames -> runtime.UnlockOSThread
internal/syscall/windows/registry.Key.ReadSubKeyNames -> gclocals·xe7TPNrOTTbta+i6KsDEXg==
internal/syscall/windows/registry.Key.ReadSubKeyNames -> internal/syscall/windows/registry.Key.ReadSubKeyNames.opendefer
internal/syscall/windows/registry.Key.ReadSubKeyNames -> go:sehuw.12.ARYCBRYDE1AAAAAA
runtime.LockOSThread -> runtime..stmp_119
syscall.regEnumKeyEx -> syscall.procRegEnumKeyExW
syscall.regEnumKeyEx -> gclocals·ZhsUtq1y8uMR+g7y1+QBvg==
syscall.regEnumKeyEx -> gclocals·hHnDXJrc4Kavpmt8Z4Usjw==
syscall.regEnumKeyEx -> syscall.regEnumKeyEx.stkobj
syscall.regEnumKeyEx -> syscall.RegEnumKeyEx.arginfo1
internal/syscall/windows/registry.Key.GetStringValue -> internal/syscall/windows/registry.Key.getValue
internal/syscall/windows/registry.Key.GetStringValue -> internal/syscall/windows/registry.ErrUnexpectedType
internal/syscall/windows/registry.Key.getValue -> syscall.RegQueryValueEx
internal/syscall/windows/registry.Key.getValue -> gclocals·xXao9/lVRrkD/fSuX6KNOg==
internal/syscall/windows/registry.Key.getValue -> gclocals·gD9EZjDlCV6kZGMkcV+AFw==
internal/syscall/windows/registry.Key.getValue -> fmt.(*pp).doPrintf.arginfo1
syscall.RegQueryValueEx -> syscall.procRegQueryValueExW
syscall.RegQueryValueEx -> gclocals·AiUxN2C5k2Q4P77qQglP0A==
internal/syscall/windows/registry.Key.GetMUIStringValue -> internal/syscall/windows/registry.regLoadMUIString
internal/syscall/windows/registry.Key.GetMUIStringValue -> go:string."%SystemRoot%\\system32\\"
internal/syscall/windows/registry.Key.GetMUIStringValue -> internal/syscall/windows/registry.ExpandString
internal/syscall/windows/registry.Key.GetMUIStringValue -> gclocals·1ohyViFLEGRtfaTK0EFfgQ==
internal/syscall/windows/registry.ExpandString -> internal/syscall/windows/registry.expandEnvironmentStrings
internal/syscall/windows/registry.ExpandString -> go:sehuw.12.ARMCBRMDEFAAAAAA
internal/syscall/windows/registry.regLoadMUIString -> gclocals·peCrP3iFwX/K82pTwDoeFw==
internal/syscall/windows/registry.regLoadMUIString -> internal/syscall/windows/registry.regLoadMUIString.arginfo1
internal/syscall/windows/registry.regLoadMUIString -> internal/syscall/windows/registry.regLoadMUIString.argliveinfo
internal/syscall/windows/registry.expandEnvironmentStrings -> internal/syscall/windows/registry.procExpandEnvironmentStringsW
internal/syscall/windows/registry.expandEnvironmentStrings -> internal/syscall/windows/registry.errERROR_EINVAL
internal/syscall/windows/registry.expandEnvironmentStrings -> internal/syscall/windows/registry.errERROR_IO_PENDING
internal/syscall/windows/registry.ErrUnexpectedType -> internal/syscall/windows/registry..stmp_0
internal/syscall/windows/registry.errERROR_IO_PENDING -> internal/syscall/windows/registry..stmp_1
internal/syscall/windows/registry.errERROR_EINVAL -> internal/syscall/windows/registry..stmp_2
internal/syscall/windows/registry..stmp_0 -> go:string."unexpected key value type"
 -> go:info.internal/syscall/windows/registry.Key.Close$abstract
 -> go:info.syscall.RegEnumKeyEx$abstract
 -> go:info.internal/syscall/windows/registry.errnoErr$abstract
runtime..stmp_119 -> go:string."LockOSThread nesting overflow"
time..stmp_23 -> go:string."Egypt Standard Time"
time..stmp_23 -> go:string."Morocco Standard Time"
time..stmp_23 -> go:string."South Africa Standard Time"
time..stmp_23 -> go:string."South Sudan Standard Time"
time..stmp_23 -> go:string."Sudan Standard Time"
time..stmp_23 -> go:string."W. Central Africa Standard Time"
time..stmp_23 -> go:string."E. Africa Standard Time"
time..stmp_23 -> go:string."Sao Tome Standard Time"
time..stmp_23 -> go:string."Libya Standard Time"
time..stmp_23 -> go:string."Namibia Standard Time"
time..stmp_23 -> go:string."Aleutian Standard Time"
time..stmp_23 -> go:string."Alaskan Standard Time"
time..stmp_23 -> go:string."Tocantins Standard Time"
time..stmp_23 -> go:string."Paraguay Standard Time"
time..stmp_23 -> go:string."Bahia Standard Time"
time..stmp_23 -> go:string."SA Pacific Standard Time"
time..stmp_23 -> go:string."Argentina Standard Time"
time..stmp_23 -> go:string."Eastern Standard Time (Mexico)"
time..stmp_23 -> go:string."Venezuela Standard Time"
time..stmp_23 -> go:string."SA Eastern Standard Time"
time..stmp_23 -> go:string."Central Standard Time"
time..stmp_23 -> go:string."Central Brazilian Standard Time"
time..stmp_23 -> go:string."Mountain Standard Time"
time..stmp_23 -> go:string."Greenland Standard Time"
time..stmp_23 -> go:string."Turks And Caicos Standard Time"
time..stmp_23 -> go:string."Central America Standard Time"
time..stmp_23 -> go:string."Atlantic Standard Time"
time..stmp_23 -> go:string."Cuba Standard Time"
time..stmp_23 -> go:string."US Eastern Standard Time"
time..stmp_23 -> go:string."SA Western Standard Time"
time..stmp_23 -> go:string."Pacific Standard Time"
time..stmp_23 -> go:string."Mountain Standard Time (Mexico)"
time..stmp_23 -> go:string."Central Standard Time (Mexico)"
time..stmp_23 -> go:string."Saint Pierre Standard Time"
time..stmp_23 -> go:string."Montevideo Standard Time"
time..stmp_23 -> go:string."Eastern Standard Time"
time..stmp_23 -> go:string."US Mountain Standard Time"
time..stmp_23 -> go:string."Haiti Standard Time"
time..stmp_23 -> go:string."Magallanes Standard Time"
time..stmp_23 -> go:string."Canada Central Standard Time"
time..stmp_23 -> go:string."Pacific SA Standard Time"
time..stmp_23 -> go:string."E. South America Standard Time"
time..stmp_23 -> go:string."Newfoundland Standard Time"
time..stmp_23 -> go:string."Pacific Standard Time (Mexico)"
time..stmp_23 -> go:string."Yukon Standard Time"
time..stmp_23 -> go:string."Central Asia Standard Time"
time..stmp_23 -> go:string."Jordan Standard Time"
time..stmp_23 -> go:string."Arabic Standard Time"
time..stmp_23 -> go:string."Azerbaijan Standard Time"
time..stmp_23 -> go:string."SE Asia Standard Time"
time..stmp_23 -> go:string."Altai Standard Time"
time..stmp_23 -> go:string."Middle East Standard Time"
time..stmp_23 -> go:string."India Standard Time"
time..stmp_23 -> go:string."Transbaikal Standard Time"
time..stmp_23 -> go:string."Sri Lanka Standard Time"
time..stmp_23 -> go:string."Syria Standard Time"
time..stmp_23 -> go:string."Bangladesh Standard Time"
time..stmp_23 -> go:string."Arabian Standard Time"
time..stmp_23 -> go:string."West Bank Standard Time"
time..stmp_23 -> go:string."W. Mongolia Standard Time"
time..stmp_23 -> go:string."North Asia East Standard Time"
time..stmp_23 -> go:string."Israel Standard Time"
time..stmp_23 -> go:string."Afghanistan Standard Time"
time..stmp_23 -> go:string."Russia Time Zone 11"
time..stmp_23 -> go:string."Pakistan Standard Time"
time..stmp_23 -> go:string."Nepal Standard Time"
time..stmp_23 -> go:string."North Asia Standard Time"
time..stmp_23 -> go:string."Magadan Standard Time"
time..stmp_23 -> go:string."N. Central Asia Standard Time"
time..stmp_23 -> go:string."Omsk Standard Time"
time..stmp_23 -> go:string."North Korea Standard Time"
time..stmp_23 -> go:string."Qyzylorda Standard Time"
time..stmp_23 -> go:string."Myanmar Standard Time"
time..stmp_23 -> go:string."Arab Standard Time"
time..stmp_23 -> go:string."Sakhalin Standard Time"
time..stmp_23 -> go:string."Korea Standard Time"
time..stmp_23 -> go:string."China Standard Time"
time..stmp_23 -> go:string."Singapore Standard Time"
time..stmp_23 -> go:string."Russia Time Zone 10"
time..stmp_23 -> go:string."Taipei Standard Time"
time..stmp_23 -> go:string."West Asia Standard Time"
time..stmp_23 -> go:string."Georgian Standard Time"
time..stmp_23 -> go:string."Iran Standard Time"
time..stmp_23 -> go:string."Tokyo Standard Time"
time..stmp_23 -> go:string."Tomsk Standard Time"
time..stmp_23 -> go:string."Ulaanbaatar Standard Time"
time..stmp_23 -> go:string."Vladivostok Standard Time"
time..stmp_23 -> go:string."Yakutsk Standard Time"
time..stmp_23 -> go:string."Ekaterinburg Standard Time"
time..stmp_23 -> go:string."Caucasus Standard Time"
time..stmp_23 -> go:string."Azores Standard Time"
time..stmp_23 -> go:string."Cape Verde Standard Time"
time..stmp_23 -> go:string."Greenwich Standard Time"
time..stmp_23 -> go:string."Cen. Australia Standard Time"
time..stmp_23 -> go:string."E. Australia Standard Time"
time..stmp_23 -> go:string."AUS Central Standard Time"
time..stmp_23 -> go:string."Aus Central W. Standard Time"
time..stmp_23 -> go:string."Tasmania Standard Time"
time..stmp_23 -> go:string."Lord Howe Standard Time"
time..stmp_23 -> go:string."W. Australia Standard Time"
time..stmp_23 -> go:string."AUS Eastern Standard Time"
time..stmp_23 -> go:string."UTC-11"
time..stmp_23 -> go:string."Dateline Standard Time"
time..stmp_23 -> go:string."UTC-02"
time..stmp_23 -> go:string."UTC-08"
time..stmp_23 -> go:string."UTC-09"
time..stmp_23 -> go:string."UTC+12"
time..stmp_23 -> go:string."UTC+13"
time..stmp_23 -> go:string."Astrakhan Standard Time"
time..stmp_23 -> go:string."W. Europe Standard Time"
time..stmp_23 -> go:string."GTB Standard Time"
time..stmp_23 -> go:string."Central Europe Standard Time"
time..stmp_23 -> go:string."E. Europe Standard Time"
time..stmp_23 -> go:string."Turkey Standard Time"
time..stmp_23 -> go:string."Kaliningrad Standard Time"
time..stmp_23 -> go:string."FLE Standard Time"
time..stmp_23 -> go:string."GMT Standard Time"
time..stmp_23 -> go:string."Belarus Standard Time"
time..stmp_23 -> go:string."Russian Standard Time"
time..stmp_23 -> go:string."Romance Standard Time"
time..stmp_23 -> go:string."Russia Time Zone 3"
time..stmp_23 -> go:string."Saratov Standard Time"
time..stmp_23 -> go:string."Volgograd Standard Time"
time..stmp_23 -> go:string."Central European Standard Time"
time..stmp_23 -> go:string."Mauritius Standard Time"
time..stmp_23 -> go:string."Samoa Standard Time"
time..stmp_23 -> go:string."New Zealand Standard Time"
time..stmp_23 -> go:string."Bougainville Standard Time"
time..stmp_23 -> go:string."Chatham Islands Standard Time"
time..stmp_23 -> go:string."Easter Island Standard Time"
time..stmp_23 -> go:string."Fiji Standard Time"
time..stmp_23 -> go:string."Central Pacific Standard Time"
time..stmp_23 -> go:string."Hawaiian Standard Time"
time..stmp_23 -> go:string."Line Islands Standard Time"
time..stmp_23 -> go:string."Marquesas Standard Time"
time..stmp_23 -> go:string."Norfolk Standard Time"
time..stmp_23 -> go:string."West Pacific Standard Time"
time..stmp_23 -> go:string."Tonga Standard Time"
time..stmp_24 -> go:string."EET"
time..stmp_24 -> go:string."EEST"
time..stmp_24 -> go:string."+00"
time..stmp_24 -> go:string."+01"
time..stmp_24 -> go:string."SAST"
time..stmp_24 -> go:string."CAT"
time..stmp_24 -> go:string."WAT"
time..stmp_24 -> go:string."EAT"
time..stmp_24 -> go:string."GMT"
time..stmp_24 -> go:string."HST"
time..stmp_24 -> go:string."HDT"
time..stmp_24 -> go:string."AKST"
time..stmp_24 -> go:string."AKDT"
time..stmp_24 -> go:string."-03"
time..stmp_24 -> go:string."-04"
time..stmp_24 -> go:string."-05"
time..stmp_24 -> go:string."EST"
time..stmp_24 -> go:string."CST"
time..stmp_24 -> go:string."CDT"
time..stmp_24 -> go:string."MST"
time..stmp_24 -> go:string."MDT"
time..stmp_24 -> go:string."-02"
time..stmp_24 -> go:string."EDT"
time..stmp_24 -> go:string."AST"
time..stmp_24 -> go:string."ADT"
time..stmp_24 -> go:string."PST"
time..stmp_24 -> go:string."PDT"
time..stmp_24 -> go:string."NST"
time..stmp_24 -> go:string."NDT"
time..stmp_24 -> go:string."+06"
time..stmp_24 -> go:string."+03"
time..stmp_24 -> go:string."+04"
time..stmp_24 -> go:string."+07"
time..stmp_24 -> go:string."IST"
time..stmp_24 -> go:string."+09"
time..stmp_24 -> go:string."+0530"
time..stmp_24 -> go:string."+08"
time..stmp_24 -> go:string."IDT"
time..stmp_24 -> go:string."+0430"
time..stmp_24 -> go:string."+12"
time..stmp_24 -> go:string."PKT"
time..stmp_24 -> go:string."+0545"
time..stmp_24 -> go:string."+11"
time..stmp_24 -> go:string."KST"
time..stmp_24 -> go:string."+05"
time..stmp_24 -> go:string."+0630"
time..stmp_24 -> go:string."+0330"
time..stmp_24 -> go:string."JST"
time..stmp_24 -> go:string."+10"
time..stmp_24 -> go:string."-01"
time..stmp_24 -> go:string."ACST"
time..stmp_24 -> go:string."ACDT"
time..stmp_24 -> go:string."AEST"
time..stmp_24 -> go:string."+0845"
time..stmp_24 -> go:string."AEDT"
time..stmp_24 -> go:string."+1030"
time..stmp_24 -> go:string."AWST"
time..stmp_24 -> go:string."-11"
time..stmp_24 -> go:string."-12"
time..stmp_24 -> go:string."-08"
time..stmp_24 -> go:string."-09"
time..stmp_24 -> go:string."+13"
time..stmp_24 -> go:string."CET"
time..stmp_24 -> go:string."CEST"
time..stmp_24 -> go:string."BST"
time..stmp_24 -> go:string."MSK"
time..stmp_24 -> go:string."NZST"
time..stmp_24 -> go:string."NZDT"
time..stmp_24 -> go:string."+1245"
time..stmp_24 -> go:string."+1345"
time..stmp_24 -> go:string."-06"
time..stmp_24 -> go:string."+14"
time..stmp_24 -> go:string."-0930"
type:map[string]time.abbr -> type:.namedata.*map[string]time.abbr-
type:map[string]time.abbr -> type:time.abbr
type:map[string]time.abbr -> type:noalg.map.bucket[string]time.abbr
type:time.abbr -> type:.eqfunc.time.abbr
type:time.abbr -> type:.namedata.*time.abbr-
type:time.abbr -> type:*time.abbr
type:time.abbr -> type:.namedata.std-
type:time.abbr -> type:.namedata.dst-
type:.eqfunc.time.abbr -> type:.eq.time.abbr
 -> go:info.*time.abbr
type:noalg.map.bucket[string]time.abbr -> runtime.gcbits.aaaaaaaaaaaa0200
type:noalg.map.bucket[string]time.abbr -> type:.namedata.*map.bucket[string]time.abbr-
type:noalg.map.bucket[string]time.abbr -> type:noalg.[8]time.abbr
type:noalg.[8]time.abbr -> runtime.gcbits.5555555500000000
type:noalg.[8]time.abbr -> type:.namedata.*[8]time.abbr-
type:noalg.[8]time.abbr -> type:[]time.abbr
type:[]time.abbr -> type:.namedata.*[]time.abbr-
type:*time.ParseError <UsedInIface> -> time.(*ParseError).Error
type:time.Duration <UsedInIface> -> type:func() time.Duration <UsedInIface>
type:time.Duration <UsedInIface> -> time.(*Duration).Abs
type:time.Duration <UsedInIface> -> time.Duration.Abs
type:time.Duration <UsedInIface> -> time.(*Duration).Hours
type:time.Duration <UsedInIface> -> time.Duration.Hours
type:time.Duration <UsedInIface> -> time.(*Duration).Microseconds
type:time.Duration <UsedInIface> -> time.Duration.Microseconds
type:time.Duration <UsedInIface> -> time.(*Duration).Milliseconds
type:time.Duration <UsedInIface> -> time.Duration.Milliseconds
type:time.Duration <UsedInIface> -> time.(*Duration).Minutes
type:time.Duration <UsedInIface> -> time.Duration.Minutes
type:time.Duration <UsedInIface> -> time.(*Duration).Nanoseconds
type:time.Duration <UsedInIface> -> time.Duration.Nanoseconds
type:time.Duration <UsedInIface> -> type:func(time.Duration) time.Duration <UsedInIface>
type:time.Duration <UsedInIface> -> time.(*Duration).Round
type:time.Duration <UsedInIface> -> time.Duration.Round
type:time.Duration <UsedInIface> -> time.(*Duration).Seconds
type:time.Duration <UsedInIface> -> time.Duration.Seconds
type:time.Duration <UsedInIface> -> time.(*Duration).String
type:time.Duration <UsedInIface> -> time.Duration.String
type:time.Duration <UsedInIface> -> time.(*Duration).Truncate
type:time.Duration <UsedInIface> -> time.Duration.Truncate
type:time.Month <UsedInIface> -> time.(*Month).String
type:time.Month <UsedInIface> -> time.Month.String
type:time.Weekday <UsedInIface> -> time.(*Weekday).String
type:time.Weekday <UsedInIface> -> time.Weekday.String
time.(*ParseError).Error -> go:string."parsing time "
time.(*ParseError).Error -> go:string." as "
time.(*ParseError).Error -> go:string.": cannot parse "
time.(*ParseError).Error -> gclocals·8Uo8nkv1+Gqm7SScN0dNbA==
time.(*ParseError).Error -> time.(*ParseError).Error.stkobj
time.Duration.String -> go:string."0s"
time.Duration.Seconds -> $f64.41cdcd6500000000
time.Duration.Minutes -> $f64.422bf08eb0000000
time.Duration.Hours -> $f64.428a3185c5000000
 -> go:info.time.fmtFrac$abstract
 -> go:info.time.Duration.Nanoseconds$abstract
 -> go:info.time.Duration.Microseconds$abstract
 -> go:info.time.Duration.Milliseconds$abstract
 -> go:info.time.Duration.Seconds$abstract
 -> go:info.time.Duration.Minutes$abstract
 -> go:info.time.Duration.Hours$abstract
 -> go:info.time.Duration.Truncate$abstract
 -> go:info.time.Duration.Abs$abstract
type:func() time.Duration <UsedInIface> -> type:.namedata.*func() time.Duration-
type:func(time.Duration) time.Duration <UsedInIface> -> type:.namedata.*func(time.Duration) time.Duration-
